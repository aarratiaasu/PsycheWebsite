let un, ml;
let __tla = (async () => {
  (function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload")) return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]')) n(i);
    new MutationObserver((i) => {
      for (const r of i) if (r.type === "childList") for (const o of r.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && n(o);
    }).observe(document, {
      childList: true,
      subtree: true
    });
    function t(i) {
      const r = {};
      return i.integrity && (r.integrity = i.integrity), i.referrerPolicy && (r.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? r.credentials = "include" : i.crossOrigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r;
    }
    function n(i) {
      if (i.ep) return;
      i.ep = true;
      const r = t(i);
      fetch(i.href, r);
    }
  })();
  const xf = "173", p0 = 0, wd = 1, m0 = 2, Pm = 1, g0 = 2, mr = 3, Er = 0, Qn = 1, Wi = 2, Sr = 0, yo = 1, xc = 2, Ad = 3, Cd = 4, _0 = 5, Ms = 100, v0 = 101, y0 = 102, x0 = 103, b0 = 104, S0 = 200, M0 = 201, T0 = 202, E0 = 203, oh = 204, ah = 205, w0 = 206, A0 = 207, C0 = 208, R0 = 209, P0 = 210, D0 = 211, L0 = 212, I0 = 213, N0 = 214, lh = 0, ch = 1, uh = 2, Ao = 3, hh = 4, fh = 5, dh = 6, ph = 7, Dm = 0, U0 = 1, O0 = 2, Qr = 0, F0 = 1, k0 = 2, B0 = 3, z0 = 4, H0 = 5, V0 = 6, G0 = 7, Rd = "attached", W0 = "detached", Lm = 300, Co = 301, Ro = 302, mh = 303, gh = 304, kc = 306, Po = 1e3, Yr = 1001, bc = 1002, Yn = 1003, Im = 1004, Ia = 1005, fi = 1006, sc = 1007, xr = 1008, wr = 1009, Nm = 1010, Um = 1011, ja = 1012, bf = 1013, Us = 1014, Ni = 1015, Mr = 1016, Sf = 1017, Mf = 1018, Do = 1020, Om = 35902, Fm = 1021, km = 1022, Ti = 1023, Bm = 1024, zm = 1025, xo = 1026, Lo = 1027, Tf = 1028, Ef = 1029, Hm = 1030, wf = 1031, Af = 1033, oc = 33776, ac = 33777, lc = 33778, cc = 33779, _h = 35840, vh = 35841, yh = 35842, xh = 35843, bh = 36196, Sh = 37492, Mh = 37496, Th = 37808, Eh = 37809, wh = 37810, Ah = 37811, Ch = 37812, Rh = 37813, Ph = 37814, Dh = 37815, Lh = 37816, Ih = 37817, Nh = 37818, Uh = 37819, Oh = 37820, Fh = 37821, uc = 36492, kh = 36494, Bh = 36495, Vm = 36283, zh = 36284, Hh = 36285, Vh = 36286, $a = 2300, Ka = 2301, lu = 2302, Pd = 2400, Dd = 2401, Ld = 2402, X0 = 2500, q0 = 0, Gm = 1, Gh = 2, Y0 = 3200, j0 = 3201, Wm = 0, $0 = 1, qr = "", Dn = "srgb", $n = "srgb-linear", Sc = "linear", $t = "srgb", js = 7680, Id = 519, K0 = 512, Z0 = 513, J0 = 514, Xm = 515, Q0 = 516, ev = 517, tv = 518, nv = 519, Wh = 35044, Nd = "300 es", br = 2e3, Mc = 2001;
  class qo {
    addEventListener(e, t) {
      this._listeners === void 0 && (this._listeners = {});
      const n = this._listeners;
      n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
    }
    hasEventListener(e, t) {
      const n = this._listeners;
      return n === void 0 ? false : n[e] !== void 0 && n[e].indexOf(t) !== -1;
    }
    removeEventListener(e, t) {
      const n = this._listeners;
      if (n === void 0) return;
      const i = n[e];
      if (i !== void 0) {
        const r = i.indexOf(t);
        r !== -1 && i.splice(r, 1);
      }
    }
    dispatchEvent(e) {
      const t = this._listeners;
      if (t === void 0) return;
      const n = t[e.type];
      if (n !== void 0) {
        e.target = this;
        const i = n.slice(0);
        for (let r = 0, o = i.length; r < o; r++) i[r].call(this, e);
        e.target = null;
      }
    }
  }
  const Un = [
    "00",
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "0a",
    "0b",
    "0c",
    "0d",
    "0e",
    "0f",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "1a",
    "1b",
    "1c",
    "1d",
    "1e",
    "1f",
    "20",
    "21",
    "22",
    "23",
    "24",
    "25",
    "26",
    "27",
    "28",
    "29",
    "2a",
    "2b",
    "2c",
    "2d",
    "2e",
    "2f",
    "30",
    "31",
    "32",
    "33",
    "34",
    "35",
    "36",
    "37",
    "38",
    "39",
    "3a",
    "3b",
    "3c",
    "3d",
    "3e",
    "3f",
    "40",
    "41",
    "42",
    "43",
    "44",
    "45",
    "46",
    "47",
    "48",
    "49",
    "4a",
    "4b",
    "4c",
    "4d",
    "4e",
    "4f",
    "50",
    "51",
    "52",
    "53",
    "54",
    "55",
    "56",
    "57",
    "58",
    "59",
    "5a",
    "5b",
    "5c",
    "5d",
    "5e",
    "5f",
    "60",
    "61",
    "62",
    "63",
    "64",
    "65",
    "66",
    "67",
    "68",
    "69",
    "6a",
    "6b",
    "6c",
    "6d",
    "6e",
    "6f",
    "70",
    "71",
    "72",
    "73",
    "74",
    "75",
    "76",
    "77",
    "78",
    "79",
    "7a",
    "7b",
    "7c",
    "7d",
    "7e",
    "7f",
    "80",
    "81",
    "82",
    "83",
    "84",
    "85",
    "86",
    "87",
    "88",
    "89",
    "8a",
    "8b",
    "8c",
    "8d",
    "8e",
    "8f",
    "90",
    "91",
    "92",
    "93",
    "94",
    "95",
    "96",
    "97",
    "98",
    "99",
    "9a",
    "9b",
    "9c",
    "9d",
    "9e",
    "9f",
    "a0",
    "a1",
    "a2",
    "a3",
    "a4",
    "a5",
    "a6",
    "a7",
    "a8",
    "a9",
    "aa",
    "ab",
    "ac",
    "ad",
    "ae",
    "af",
    "b0",
    "b1",
    "b2",
    "b3",
    "b4",
    "b5",
    "b6",
    "b7",
    "b8",
    "b9",
    "ba",
    "bb",
    "bc",
    "bd",
    "be",
    "bf",
    "c0",
    "c1",
    "c2",
    "c3",
    "c4",
    "c5",
    "c6",
    "c7",
    "c8",
    "c9",
    "ca",
    "cb",
    "cc",
    "cd",
    "ce",
    "cf",
    "d0",
    "d1",
    "d2",
    "d3",
    "d4",
    "d5",
    "d6",
    "d7",
    "d8",
    "d9",
    "da",
    "db",
    "dc",
    "dd",
    "de",
    "df",
    "e0",
    "e1",
    "e2",
    "e3",
    "e4",
    "e5",
    "e6",
    "e7",
    "e8",
    "e9",
    "ea",
    "eb",
    "ec",
    "ed",
    "ee",
    "ef",
    "f0",
    "f1",
    "f2",
    "f3",
    "f4",
    "f5",
    "f6",
    "f7",
    "f8",
    "f9",
    "fa",
    "fb",
    "fc",
    "fd",
    "fe",
    "ff"
  ];
  let Ud = 1234567;
  const Fa = Math.PI / 180, Io = 180 / Math.PI;
  function wi() {
    const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
    return (Un[s & 255] + Un[s >> 8 & 255] + Un[s >> 16 & 255] + Un[s >> 24 & 255] + "-" + Un[e & 255] + Un[e >> 8 & 255] + "-" + Un[e >> 16 & 15 | 64] + Un[e >> 24 & 255] + "-" + Un[t & 63 | 128] + Un[t >> 8 & 255] + "-" + Un[t >> 16 & 255] + Un[t >> 24 & 255] + Un[n & 255] + Un[n >> 8 & 255] + Un[n >> 16 & 255] + Un[n >> 24 & 255]).toLowerCase();
  }
  function xt(s, e, t) {
    return Math.max(e, Math.min(t, s));
  }
  function Cf(s, e) {
    return (s % e + e) % e;
  }
  function iv(s, e, t, n, i) {
    return n + (s - e) * (i - n) / (t - e);
  }
  function rv(s, e, t) {
    return s !== e ? (t - s) / (e - s) : 0;
  }
  function ka(s, e, t) {
    return (1 - t) * s + t * e;
  }
  function sv(s, e, t, n) {
    return ka(s, e, 1 - Math.exp(-t * n));
  }
  function ov(s, e = 1) {
    return e - Math.abs(Cf(s, e * 2) - e);
  }
  function av(s, e, t) {
    return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e), s * s * (3 - 2 * s));
  }
  function lv(s, e, t) {
    return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e), s * s * s * (s * (s * 6 - 15) + 10));
  }
  function cv(s, e) {
    return s + Math.floor(Math.random() * (e - s + 1));
  }
  function uv(s, e) {
    return s + Math.random() * (e - s);
  }
  function hv(s) {
    return s * (0.5 - Math.random());
  }
  function fv(s) {
    s !== void 0 && (Ud = s);
    let e = Ud += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
  }
  function dv(s) {
    return s * Fa;
  }
  function pv(s) {
    return s * Io;
  }
  function mv(s) {
    return (s & s - 1) === 0 && s !== 0;
  }
  function gv(s) {
    return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
  }
  function _v(s) {
    return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
  }
  function vv(s, e, t, n, i) {
    const r = Math.cos, o = Math.sin, a = r(t / 2), l = o(t / 2), c = r((e + n) / 2), h = o((e + n) / 2), f = r((e - n) / 2), m = o((e - n) / 2), _ = r((n - e) / 2), y = o((n - e) / 2);
    switch (i) {
      case "XYX":
        s.set(a * h, l * f, l * m, a * c);
        break;
      case "YZY":
        s.set(l * m, a * h, l * f, a * c);
        break;
      case "ZXZ":
        s.set(l * f, l * m, a * h, a * c);
        break;
      case "XZX":
        s.set(a * h, l * y, l * _, a * c);
        break;
      case "YXY":
        s.set(l * _, a * h, l * y, a * c);
        break;
      case "ZYZ":
        s.set(l * y, l * _, a * h, a * c);
        break;
      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i);
    }
  }
  function Li(s, e) {
    switch (e.constructor) {
      case Float32Array:
        return s;
      case Uint32Array:
        return s / 4294967295;
      case Uint16Array:
        return s / 65535;
      case Uint8Array:
        return s / 255;
      case Int32Array:
        return Math.max(s / 2147483647, -1);
      case Int16Array:
        return Math.max(s / 32767, -1);
      case Int8Array:
        return Math.max(s / 127, -1);
      default:
        throw new Error("Invalid component type.");
    }
  }
  function qt(s, e) {
    switch (e.constructor) {
      case Float32Array:
        return s;
      case Uint32Array:
        return Math.round(s * 4294967295);
      case Uint16Array:
        return Math.round(s * 65535);
      case Uint8Array:
        return Math.round(s * 255);
      case Int32Array:
        return Math.round(s * 2147483647);
      case Int16Array:
        return Math.round(s * 32767);
      case Int8Array:
        return Math.round(s * 127);
      default:
        throw new Error("Invalid component type.");
    }
  }
  const yv = {
    DEG2RAD: Fa,
    RAD2DEG: Io,
    generateUUID: wi,
    clamp: xt,
    euclideanModulo: Cf,
    mapLinear: iv,
    inverseLerp: rv,
    lerp: ka,
    damp: sv,
    pingpong: ov,
    smoothstep: av,
    smootherstep: lv,
    randInt: cv,
    randFloat: uv,
    randFloatSpread: hv,
    seededRandom: fv,
    degToRad: dv,
    radToDeg: pv,
    isPowerOfTwo: mv,
    ceilPowerOfTwo: gv,
    floorPowerOfTwo: _v,
    setQuaternionFromProperEuler: vv,
    normalize: qt,
    denormalize: Li
  };
  class Se {
    constructor(e = 0, t = 0) {
      Se.prototype.isVector2 = true, this.x = e, this.y = t;
    }
    get width() {
      return this.x;
    }
    set width(e) {
      this.x = e;
    }
    get height() {
      return this.y;
    }
    set height(e) {
      this.y = e;
    }
    set(e, t) {
      return this.x = e, this.y = t, this;
    }
    setScalar(e) {
      return this.x = e, this.y = e, this;
    }
    setX(e) {
      return this.x = e, this;
    }
    setY(e) {
      return this.y = e, this;
    }
    setComponent(e, t) {
      switch (e) {
        case 0:
          this.x = t;
          break;
        case 1:
          this.y = t;
          break;
        default:
          throw new Error("index is out of range: " + e);
      }
      return this;
    }
    getComponent(e) {
      switch (e) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + e);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(e) {
      return this.x = e.x, this.y = e.y, this;
    }
    add(e) {
      return this.x += e.x, this.y += e.y, this;
    }
    addScalar(e) {
      return this.x += e, this.y += e, this;
    }
    addVectors(e, t) {
      return this.x = e.x + t.x, this.y = e.y + t.y, this;
    }
    addScaledVector(e, t) {
      return this.x += e.x * t, this.y += e.y * t, this;
    }
    sub(e) {
      return this.x -= e.x, this.y -= e.y, this;
    }
    subScalar(e) {
      return this.x -= e, this.y -= e, this;
    }
    subVectors(e, t) {
      return this.x = e.x - t.x, this.y = e.y - t.y, this;
    }
    multiply(e) {
      return this.x *= e.x, this.y *= e.y, this;
    }
    multiplyScalar(e) {
      return this.x *= e, this.y *= e, this;
    }
    divide(e) {
      return this.x /= e.x, this.y /= e.y, this;
    }
    divideScalar(e) {
      return this.multiplyScalar(1 / e);
    }
    applyMatrix3(e) {
      const t = this.x, n = this.y, i = e.elements;
      return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this;
    }
    min(e) {
      return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
    }
    max(e) {
      return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
    }
    clamp(e, t) {
      return this.x = xt(this.x, e.x, t.x), this.y = xt(this.y, e.y, t.y), this;
    }
    clampScalar(e, t) {
      return this.x = xt(this.x, e, t), this.y = xt(this.y, e, t), this;
    }
    clampLength(e, t) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(xt(n, e, t));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    }
    roundToZero() {
      return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this;
    }
    dot(e) {
      return this.x * e.x + this.y * e.y;
    }
    cross(e) {
      return this.x * e.y - this.y * e.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    angleTo(e) {
      const t = Math.sqrt(this.lengthSq() * e.lengthSq());
      if (t === 0) return Math.PI / 2;
      const n = this.dot(e) / t;
      return Math.acos(xt(n, -1, 1));
    }
    distanceTo(e) {
      return Math.sqrt(this.distanceToSquared(e));
    }
    distanceToSquared(e) {
      const t = this.x - e.x, n = this.y - e.y;
      return t * t + n * n;
    }
    manhattanDistanceTo(e) {
      return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
    }
    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
      return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
    }
    lerpVectors(e, t, n) {
      return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
    }
    equals(e) {
      return e.x === this.x && e.y === this.y;
    }
    fromArray(e, t = 0) {
      return this.x = e[t], this.y = e[t + 1], this;
    }
    toArray(e = [], t = 0) {
      return e[t] = this.x, e[t + 1] = this.y, e;
    }
    fromBufferAttribute(e, t) {
      return this.x = e.getX(t), this.y = e.getY(t), this;
    }
    rotateAround(e, t) {
      const n = Math.cos(t), i = Math.sin(t), r = this.x - e.x, o = this.y - e.y;
      return this.x = r * n - o * i + e.x, this.y = r * i + o * n + e.y, this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y;
    }
  }
  class mt {
    constructor(e, t, n, i, r, o, a, l, c) {
      mt.prototype.isMatrix3 = true, this.elements = [
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ], e !== void 0 && this.set(e, t, n, i, r, o, a, l, c);
    }
    set(e, t, n, i, r, o, a, l, c) {
      const h = this.elements;
      return h[0] = e, h[1] = i, h[2] = a, h[3] = t, h[4] = r, h[5] = l, h[6] = n, h[7] = o, h[8] = c, this;
    }
    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(e) {
      const t = this.elements, n = e.elements;
      return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
    }
    extractBasis(e, t, n) {
      return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
    }
    setFromMatrix4(e) {
      const t = e.elements;
      return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
    }
    multiply(e) {
      return this.multiplyMatrices(this, e);
    }
    premultiply(e) {
      return this.multiplyMatrices(e, this);
    }
    multiplyMatrices(e, t) {
      const n = e.elements, i = t.elements, r = this.elements, o = n[0], a = n[3], l = n[6], c = n[1], h = n[4], f = n[7], m = n[2], _ = n[5], y = n[8], g = i[0], x = i[3], v = i[6], E = i[1], T = i[4], M = i[7], P = i[2], R = i[5], d = i[8];
      return r[0] = o * g + a * E + l * P, r[3] = o * x + a * T + l * R, r[6] = o * v + a * M + l * d, r[1] = c * g + h * E + f * P, r[4] = c * x + h * T + f * R, r[7] = c * v + h * M + f * d, r[2] = m * g + _ * E + y * P, r[5] = m * x + _ * T + y * R, r[8] = m * v + _ * M + y * d, this;
    }
    multiplyScalar(e) {
      const t = this.elements;
      return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
    }
    determinant() {
      const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], o = e[4], a = e[5], l = e[6], c = e[7], h = e[8];
      return t * o * h - t * a * c - n * r * h + n * a * l + i * r * c - i * o * l;
    }
    invert() {
      const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], o = e[4], a = e[5], l = e[6], c = e[7], h = e[8], f = h * o - a * c, m = a * l - h * r, _ = c * r - o * l, y = t * f + n * m + i * _;
      if (y === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const g = 1 / y;
      return e[0] = f * g, e[1] = (i * c - h * n) * g, e[2] = (a * n - i * o) * g, e[3] = m * g, e[4] = (h * t - i * l) * g, e[5] = (i * r - a * t) * g, e[6] = _ * g, e[7] = (n * l - c * t) * g, e[8] = (o * t - n * r) * g, this;
    }
    transpose() {
      let e;
      const t = this.elements;
      return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
    }
    getNormalMatrix(e) {
      return this.setFromMatrix4(e).invert().transpose();
    }
    transposeIntoArray(e) {
      const t = this.elements;
      return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
    }
    setUvTransform(e, t, n, i, r, o, a) {
      const l = Math.cos(r), c = Math.sin(r);
      return this.set(n * l, n * c, -n * (l * o + c * a) + o + e, -i * c, i * l, -i * (-c * o + l * a) + a + t, 0, 0, 1), this;
    }
    scale(e, t) {
      return this.premultiply(cu.makeScale(e, t)), this;
    }
    rotate(e) {
      return this.premultiply(cu.makeRotation(-e)), this;
    }
    translate(e, t) {
      return this.premultiply(cu.makeTranslation(e, t)), this;
    }
    makeTranslation(e, t) {
      return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
    }
    makeRotation(e) {
      const t = Math.cos(e), n = Math.sin(e);
      return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this;
    }
    makeScale(e, t) {
      return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
    }
    equals(e) {
      const t = this.elements, n = e.elements;
      for (let i = 0; i < 9; i++) if (t[i] !== n[i]) return false;
      return true;
    }
    fromArray(e, t = 0) {
      for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
      return this;
    }
    toArray(e = [], t = 0) {
      const n = this.elements;
      return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  }
  const cu = new mt();
  function qm(s) {
    for (let e = s.length - 1; e >= 0; --e) if (s[e] >= 65535) return true;
    return false;
  }
  function Za(s) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", s);
  }
  function xv() {
    const s = Za("canvas");
    return s.style.display = "block", s;
  }
  const Od = {};
  function ho(s) {
    s in Od || (Od[s] = true, console.warn(s));
  }
  function bv(s, e, t) {
    return new Promise(function(n, i) {
      function r() {
        switch (s.clientWaitSync(e, s.SYNC_FLUSH_COMMANDS_BIT, 0)) {
          case s.WAIT_FAILED:
            i();
            break;
          case s.TIMEOUT_EXPIRED:
            setTimeout(r, t);
            break;
          default:
            n();
        }
      }
      setTimeout(r, t);
    });
  }
  function Sv(s) {
    const e = s.elements;
    e[2] = 0.5 * e[2] + 0.5 * e[3], e[6] = 0.5 * e[6] + 0.5 * e[7], e[10] = 0.5 * e[10] + 0.5 * e[11], e[14] = 0.5 * e[14] + 0.5 * e[15];
  }
  function Mv(s) {
    const e = s.elements;
    e[11] === -1 ? (e[10] = -e[10] - 1, e[14] = -e[14]) : (e[10] = -e[10], e[14] = -e[14] + 1);
  }
  const Fd = new mt().set(0.4123908, 0.3575843, 0.1804808, 0.212639, 0.7151687, 0.0721923, 0.0193308, 0.1191948, 0.9505322), kd = new mt().set(3.2409699, -1.5373832, -0.4986108, -0.9692436, 1.8759675, 0.0415551, 0.0556301, -0.203977, 1.0569715);
  function Tv() {
    const s = {
      enabled: true,
      workingColorSpace: $n,
      spaces: {},
      convert: function(i, r, o) {
        return this.enabled === false || r === o || !r || !o || (this.spaces[r].transfer === $t && (i.r = Tr(i.r), i.g = Tr(i.g), i.b = Tr(i.b)), this.spaces[r].primaries !== this.spaces[o].primaries && (i.applyMatrix3(this.spaces[r].toXYZ), i.applyMatrix3(this.spaces[o].fromXYZ)), this.spaces[o].transfer === $t && (i.r = bo(i.r), i.g = bo(i.g), i.b = bo(i.b))), i;
      },
      fromWorkingColorSpace: function(i, r) {
        return this.convert(i, this.workingColorSpace, r);
      },
      toWorkingColorSpace: function(i, r) {
        return this.convert(i, r, this.workingColorSpace);
      },
      getPrimaries: function(i) {
        return this.spaces[i].primaries;
      },
      getTransfer: function(i) {
        return i === qr ? Sc : this.spaces[i].transfer;
      },
      getLuminanceCoefficients: function(i, r = this.workingColorSpace) {
        return i.fromArray(this.spaces[r].luminanceCoefficients);
      },
      define: function(i) {
        Object.assign(this.spaces, i);
      },
      _getMatrix: function(i, r, o) {
        return i.copy(this.spaces[r].toXYZ).multiply(this.spaces[o].fromXYZ);
      },
      _getDrawingBufferColorSpace: function(i) {
        return this.spaces[i].outputColorSpaceConfig.drawingBufferColorSpace;
      },
      _getUnpackColorSpace: function(i = this.workingColorSpace) {
        return this.spaces[i].workingColorSpaceConfig.unpackColorSpace;
      }
    }, e = [
      0.64,
      0.33,
      0.3,
      0.6,
      0.15,
      0.06
    ], t = [
      0.2126,
      0.7152,
      0.0722
    ], n = [
      0.3127,
      0.329
    ];
    return s.define({
      [$n]: {
        primaries: e,
        whitePoint: n,
        transfer: Sc,
        toXYZ: Fd,
        fromXYZ: kd,
        luminanceCoefficients: t,
        workingColorSpaceConfig: {
          unpackColorSpace: Dn
        },
        outputColorSpaceConfig: {
          drawingBufferColorSpace: Dn
        }
      },
      [Dn]: {
        primaries: e,
        whitePoint: n,
        transfer: $t,
        toXYZ: Fd,
        fromXYZ: kd,
        luminanceCoefficients: t,
        outputColorSpaceConfig: {
          drawingBufferColorSpace: Dn
        }
      }
    }), s;
  }
  const It = Tv();
  function Tr(s) {
    return s < 0.04045 ? s * 0.0773993808 : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
  }
  function bo(s) {
    return s < 31308e-7 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
  }
  let $s;
  class Ev {
    static getDataURL(e) {
      if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
      let t;
      if (e instanceof HTMLCanvasElement) t = e;
      else {
        $s === void 0 && ($s = Za("canvas")), $s.width = e.width, $s.height = e.height;
        const n = $s.getContext("2d");
        e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = $s;
      }
      return t.toDataURL("image/png");
    }
    static sRGBToLinear(e) {
      if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
        const t = Za("canvas");
        t.width = e.width, t.height = e.height;
        const n = t.getContext("2d");
        n.drawImage(e, 0, 0, e.width, e.height);
        const i = n.getImageData(0, 0, e.width, e.height), r = i.data;
        for (let o = 0; o < r.length; o++) r[o] = Tr(r[o] / 255) * 255;
        return n.putImageData(i, 0, 0), t;
      } else if (e.data) {
        const t = e.data.slice(0);
        for (let n = 0; n < t.length; n++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(Tr(t[n] / 255) * 255) : t[n] = Tr(t[n]);
        return {
          data: t,
          width: e.width,
          height: e.height
        };
      } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
    }
  }
  let wv = 0;
  class Ym {
    constructor(e = null) {
      this.isSource = true, Object.defineProperty(this, "id", {
        value: wv++
      }), this.uuid = wi(), this.data = e, this.dataReady = true, this.version = 0;
    }
    set needsUpdate(e) {
      e === true && this.version++;
    }
    toJSON(e) {
      const t = e === void 0 || typeof e == "string";
      if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
      const n = {
        uuid: this.uuid,
        url: ""
      }, i = this.data;
      if (i !== null) {
        let r;
        if (Array.isArray(i)) {
          r = [];
          for (let o = 0, a = i.length; o < a; o++) i[o].isDataTexture ? r.push(uu(i[o].image)) : r.push(uu(i[o]));
        } else r = uu(i);
        n.url = r;
      }
      return t || (e.images[this.uuid] = n), n;
    }
  }
  function uu(s) {
    return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && s instanceof ImageBitmap ? Ev.getDataURL(s) : s.data ? {
      data: Array.from(s.data),
      width: s.width,
      height: s.height,
      type: s.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
  }
  let Av = 0;
  class Mn extends qo {
    constructor(e = Mn.DEFAULT_IMAGE, t = Mn.DEFAULT_MAPPING, n = Yr, i = Yr, r = fi, o = xr, a = Ti, l = wr, c = Mn.DEFAULT_ANISOTROPY, h = qr) {
      super(), this.isTexture = true, Object.defineProperty(this, "id", {
        value: Av++
      }), this.uuid = wi(), this.name = "", this.source = new Ym(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = o, this.anisotropy = c, this.format = a, this.internalFormat = null, this.type = l, this.offset = new Se(0, 0), this.repeat = new Se(1, 1), this.center = new Se(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new mt(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.colorSpace = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = false, this.pmremVersion = 0;
    }
    get image() {
      return this.source.data;
    }
    set image(e = null) {
      this.source.data = e;
    }
    updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.renderTarget = e.renderTarget, this.isRenderTargetTexture = e.isRenderTargetTexture, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = true, this;
    }
    toJSON(e) {
      const t = e === void 0 || typeof e == "string";
      if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
      const n = {
        metadata: {
          version: 4.6,
          type: "Texture",
          generator: "Texture.toJSON"
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(e).uuid,
        mapping: this.mapping,
        channel: this.channel,
        repeat: [
          this.repeat.x,
          this.repeat.y
        ],
        offset: [
          this.offset.x,
          this.offset.y
        ],
        center: [
          this.center.x,
          this.center.y
        ],
        rotation: this.rotation,
        wrap: [
          this.wrapS,
          this.wrapT
        ],
        format: this.format,
        internalFormat: this.internalFormat,
        type: this.type,
        colorSpace: this.colorSpace,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        generateMipmaps: this.generateMipmaps,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment
      };
      return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n;
    }
    dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }
    transformUv(e) {
      if (this.mapping !== Lm) return e;
      if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
        case Po:
          e.x = e.x - Math.floor(e.x);
          break;
        case Yr:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case bc:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
      if (e.y < 0 || e.y > 1) switch (this.wrapT) {
        case Po:
          e.y = e.y - Math.floor(e.y);
          break;
        case Yr:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case bc:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
      return this.flipY && (e.y = 1 - e.y), e;
    }
    set needsUpdate(e) {
      e === true && (this.version++, this.source.needsUpdate = true);
    }
    set needsPMREMUpdate(e) {
      e === true && this.pmremVersion++;
    }
  }
  Mn.DEFAULT_IMAGE = null;
  Mn.DEFAULT_MAPPING = Lm;
  Mn.DEFAULT_ANISOTROPY = 1;
  class zt {
    constructor(e = 0, t = 0, n = 0, i = 1) {
      zt.prototype.isVector4 = true, this.x = e, this.y = t, this.z = n, this.w = i;
    }
    get width() {
      return this.z;
    }
    set width(e) {
      this.z = e;
    }
    get height() {
      return this.w;
    }
    set height(e) {
      this.w = e;
    }
    set(e, t, n, i) {
      return this.x = e, this.y = t, this.z = n, this.w = i, this;
    }
    setScalar(e) {
      return this.x = e, this.y = e, this.z = e, this.w = e, this;
    }
    setX(e) {
      return this.x = e, this;
    }
    setY(e) {
      return this.y = e, this;
    }
    setZ(e) {
      return this.z = e, this;
    }
    setW(e) {
      return this.w = e, this;
    }
    setComponent(e, t) {
      switch (e) {
        case 0:
          this.x = t;
          break;
        case 1:
          this.y = t;
          break;
        case 2:
          this.z = t;
          break;
        case 3:
          this.w = t;
          break;
        default:
          throw new Error("index is out of range: " + e);
      }
      return this;
    }
    getComponent(e) {
      switch (e) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + e);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(e) {
      return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
    }
    add(e) {
      return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
    }
    addScalar(e) {
      return this.x += e, this.y += e, this.z += e, this.w += e, this;
    }
    addVectors(e, t) {
      return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
    }
    addScaledVector(e, t) {
      return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
    }
    sub(e) {
      return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
    }
    subScalar(e) {
      return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
    }
    subVectors(e, t) {
      return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
    }
    multiply(e) {
      return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
    }
    multiplyScalar(e) {
      return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
    }
    applyMatrix4(e) {
      const t = this.x, n = this.y, i = this.z, r = this.w, o = e.elements;
      return this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * r, this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * r, this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * r, this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * r, this;
    }
    divide(e) {
      return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
    }
    divideScalar(e) {
      return this.multiplyScalar(1 / e);
    }
    setAxisAngleFromQuaternion(e) {
      this.w = 2 * Math.acos(e.w);
      const t = Math.sqrt(1 - e.w * e.w);
      return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
    }
    setAxisAngleFromRotationMatrix(e) {
      let t, n, i, r;
      const l = e.elements, c = l[0], h = l[4], f = l[8], m = l[1], _ = l[5], y = l[9], g = l[2], x = l[6], v = l[10];
      if (Math.abs(h - m) < 0.01 && Math.abs(f - g) < 0.01 && Math.abs(y - x) < 0.01) {
        if (Math.abs(h + m) < 0.1 && Math.abs(f + g) < 0.1 && Math.abs(y + x) < 0.1 && Math.abs(c + _ + v - 3) < 0.1) return this.set(1, 0, 0, 0), this;
        t = Math.PI;
        const T = (c + 1) / 2, M = (_ + 1) / 2, P = (v + 1) / 2, R = (h + m) / 4, d = (f + g) / 4, N = (y + x) / 4;
        return T > M && T > P ? T < 0.01 ? (n = 0, i = 0.707106781, r = 0.707106781) : (n = Math.sqrt(T), i = R / n, r = d / n) : M > P ? M < 0.01 ? (n = 0.707106781, i = 0, r = 0.707106781) : (i = Math.sqrt(M), n = R / i, r = N / i) : P < 0.01 ? (n = 0.707106781, i = 0.707106781, r = 0) : (r = Math.sqrt(P), n = d / r, i = N / r), this.set(n, i, r, t), this;
      }
      let E = Math.sqrt((x - y) * (x - y) + (f - g) * (f - g) + (m - h) * (m - h));
      return Math.abs(E) < 1e-3 && (E = 1), this.x = (x - y) / E, this.y = (f - g) / E, this.z = (m - h) / E, this.w = Math.acos((c + _ + v - 1) / 2), this;
    }
    setFromMatrixPosition(e) {
      const t = e.elements;
      return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this;
    }
    min(e) {
      return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
    }
    max(e) {
      return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
    }
    clamp(e, t) {
      return this.x = xt(this.x, e.x, t.x), this.y = xt(this.y, e.y, t.y), this.z = xt(this.z, e.z, t.z), this.w = xt(this.w, e.w, t.w), this;
    }
    clampScalar(e, t) {
      return this.x = xt(this.x, e, t), this.y = xt(this.y, e, t), this.z = xt(this.z, e, t), this.w = xt(this.w, e, t), this;
    }
    clampLength(e, t) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(xt(n, e, t));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
    }
    roundToZero() {
      return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
    }
    dot(e) {
      return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
      return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
    }
    lerpVectors(e, t, n) {
      return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this;
    }
    equals(e) {
      return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
    }
    fromArray(e, t = 0) {
      return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
    }
    toArray(e = [], t = 0) {
      return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
    }
    fromBufferAttribute(e, t) {
      return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z, yield this.w;
    }
  }
  class Cv extends qo {
    constructor(e = 1, t = 1, n = {}) {
      super(), this.isRenderTarget = true, this.width = e, this.height = t, this.depth = 1, this.scissor = new zt(0, 0, e, t), this.scissorTest = false, this.viewport = new zt(0, 0, e, t);
      const i = {
        width: e,
        height: t,
        depth: 1
      };
      n = Object.assign({
        generateMipmaps: false,
        internalFormat: null,
        minFilter: fi,
        depthBuffer: true,
        stencilBuffer: false,
        resolveDepthBuffer: true,
        resolveStencilBuffer: true,
        depthTexture: null,
        samples: 0,
        count: 1
      }, n);
      const r = new Mn(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
      r.flipY = false, r.generateMipmaps = n.generateMipmaps, r.internalFormat = n.internalFormat, this.textures = [];
      const o = n.count;
      for (let a = 0; a < o; a++) this.textures[a] = r.clone(), this.textures[a].isRenderTargetTexture = true, this.textures[a].renderTarget = this;
      this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this._depthTexture = null, this.depthTexture = n.depthTexture, this.samples = n.samples;
    }
    get texture() {
      return this.textures[0];
    }
    set texture(e) {
      this.textures[0] = e;
    }
    set depthTexture(e) {
      this._depthTexture !== null && (this._depthTexture.renderTarget = null), e !== null && (e.renderTarget = this), this._depthTexture = e;
    }
    get depthTexture() {
      return this._depthTexture;
    }
    setSize(e, t, n = 1) {
      if (this.width !== e || this.height !== t || this.depth !== n) {
        this.width = e, this.height = t, this.depth = n;
        for (let i = 0, r = this.textures.length; i < r; i++) this.textures[i].image.width = e, this.textures[i].image.height = t, this.textures[i].image.depth = n;
        this.dispose();
      }
      this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
      for (let n = 0, i = e.textures.length; n < i; n++) this.textures[n] = e.textures[n].clone(), this.textures[n].isRenderTargetTexture = true, this.textures[n].renderTarget = this;
      const t = Object.assign({}, e.texture.image);
      return this.texture.source = new Ym(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
    }
    dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }
  }
  class Ui extends Cv {
    constructor(e = 1, t = 1, n = {}) {
      super(e, t, n), this.isWebGLRenderTarget = true;
    }
  }
  class jm extends Mn {
    constructor(e = null, t = 1, n = 1, i = 1) {
      super(null), this.isDataArrayTexture = true, this.image = {
        data: e,
        width: t,
        height: n,
        depth: i
      }, this.magFilter = Yn, this.minFilter = Yn, this.wrapR = Yr, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
    }
    addLayerUpdate(e) {
      this.layerUpdates.add(e);
    }
    clearLayerUpdates() {
      this.layerUpdates.clear();
    }
  }
  class Rv extends Mn {
    constructor(e = null, t = 1, n = 1, i = 1) {
      super(null), this.isData3DTexture = true, this.image = {
        data: e,
        width: t,
        height: n,
        depth: i
      }, this.magFilter = Yn, this.minFilter = Yn, this.wrapR = Yr, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
    }
  }
  class rs {
    constructor(e = 0, t = 0, n = 0, i = 1) {
      this.isQuaternion = true, this._x = e, this._y = t, this._z = n, this._w = i;
    }
    static slerpFlat(e, t, n, i, r, o, a) {
      let l = n[i + 0], c = n[i + 1], h = n[i + 2], f = n[i + 3];
      const m = r[o + 0], _ = r[o + 1], y = r[o + 2], g = r[o + 3];
      if (a === 0) {
        e[t + 0] = l, e[t + 1] = c, e[t + 2] = h, e[t + 3] = f;
        return;
      }
      if (a === 1) {
        e[t + 0] = m, e[t + 1] = _, e[t + 2] = y, e[t + 3] = g;
        return;
      }
      if (f !== g || l !== m || c !== _ || h !== y) {
        let x = 1 - a;
        const v = l * m + c * _ + h * y + f * g, E = v >= 0 ? 1 : -1, T = 1 - v * v;
        if (T > Number.EPSILON) {
          const P = Math.sqrt(T), R = Math.atan2(P, v * E);
          x = Math.sin(x * R) / P, a = Math.sin(a * R) / P;
        }
        const M = a * E;
        if (l = l * x + m * M, c = c * x + _ * M, h = h * x + y * M, f = f * x + g * M, x === 1 - a) {
          const P = 1 / Math.sqrt(l * l + c * c + h * h + f * f);
          l *= P, c *= P, h *= P, f *= P;
        }
      }
      e[t] = l, e[t + 1] = c, e[t + 2] = h, e[t + 3] = f;
    }
    static multiplyQuaternionsFlat(e, t, n, i, r, o) {
      const a = n[i], l = n[i + 1], c = n[i + 2], h = n[i + 3], f = r[o], m = r[o + 1], _ = r[o + 2], y = r[o + 3];
      return e[t] = a * y + h * f + l * _ - c * m, e[t + 1] = l * y + h * m + c * f - a * _, e[t + 2] = c * y + h * _ + a * m - l * f, e[t + 3] = h * y - a * f - l * m - c * _, e;
    }
    get x() {
      return this._x;
    }
    set x(e) {
      this._x = e, this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(e) {
      this._y = e, this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(e) {
      this._z = e, this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(e) {
      this._w = e, this._onChangeCallback();
    }
    set(e, t, n, i) {
      return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(e) {
      return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
    }
    setFromEuler(e, t = true) {
      const n = e._x, i = e._y, r = e._z, o = e._order, a = Math.cos, l = Math.sin, c = a(n / 2), h = a(i / 2), f = a(r / 2), m = l(n / 2), _ = l(i / 2), y = l(r / 2);
      switch (o) {
        case "XYZ":
          this._x = m * h * f + c * _ * y, this._y = c * _ * f - m * h * y, this._z = c * h * y + m * _ * f, this._w = c * h * f - m * _ * y;
          break;
        case "YXZ":
          this._x = m * h * f + c * _ * y, this._y = c * _ * f - m * h * y, this._z = c * h * y - m * _ * f, this._w = c * h * f + m * _ * y;
          break;
        case "ZXY":
          this._x = m * h * f - c * _ * y, this._y = c * _ * f + m * h * y, this._z = c * h * y + m * _ * f, this._w = c * h * f - m * _ * y;
          break;
        case "ZYX":
          this._x = m * h * f - c * _ * y, this._y = c * _ * f + m * h * y, this._z = c * h * y - m * _ * f, this._w = c * h * f + m * _ * y;
          break;
        case "YZX":
          this._x = m * h * f + c * _ * y, this._y = c * _ * f + m * h * y, this._z = c * h * y - m * _ * f, this._w = c * h * f - m * _ * y;
          break;
        case "XZY":
          this._x = m * h * f - c * _ * y, this._y = c * _ * f - m * h * y, this._z = c * h * y + m * _ * f, this._w = c * h * f + m * _ * y;
          break;
        default:
          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
      }
      return t === true && this._onChangeCallback(), this;
    }
    setFromAxisAngle(e, t) {
      const n = t / 2, i = Math.sin(n);
      return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this;
    }
    setFromRotationMatrix(e) {
      const t = e.elements, n = t[0], i = t[4], r = t[8], o = t[1], a = t[5], l = t[9], c = t[2], h = t[6], f = t[10], m = n + a + f;
      if (m > 0) {
        const _ = 0.5 / Math.sqrt(m + 1);
        this._w = 0.25 / _, this._x = (h - l) * _, this._y = (r - c) * _, this._z = (o - i) * _;
      } else if (n > a && n > f) {
        const _ = 2 * Math.sqrt(1 + n - a - f);
        this._w = (h - l) / _, this._x = 0.25 * _, this._y = (i + o) / _, this._z = (r + c) / _;
      } else if (a > f) {
        const _ = 2 * Math.sqrt(1 + a - n - f);
        this._w = (r - c) / _, this._x = (i + o) / _, this._y = 0.25 * _, this._z = (l + h) / _;
      } else {
        const _ = 2 * Math.sqrt(1 + f - n - a);
        this._w = (o - i) / _, this._x = (r + c) / _, this._y = (l + h) / _, this._z = 0.25 * _;
      }
      return this._onChangeCallback(), this;
    }
    setFromUnitVectors(e, t) {
      let n = e.dot(t) + 1;
      return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize();
    }
    angleTo(e) {
      return 2 * Math.acos(Math.abs(xt(this.dot(e), -1, 1)));
    }
    rotateTowards(e, t) {
      const n = this.angleTo(e);
      if (n === 0) return this;
      const i = Math.min(1, t / n);
      return this.slerp(e, i), this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
    }
    dot(e) {
      return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
    }
    lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
      let e = this.length();
      return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
    }
    multiply(e) {
      return this.multiplyQuaternions(this, e);
    }
    premultiply(e) {
      return this.multiplyQuaternions(e, this);
    }
    multiplyQuaternions(e, t) {
      const n = e._x, i = e._y, r = e._z, o = e._w, a = t._x, l = t._y, c = t._z, h = t._w;
      return this._x = n * h + o * a + i * c - r * l, this._y = i * h + o * l + r * a - n * c, this._z = r * h + o * c + n * l - i * a, this._w = o * h - n * a - i * l - r * c, this._onChangeCallback(), this;
    }
    slerp(e, t) {
      if (t === 0) return this;
      if (t === 1) return this.copy(e);
      const n = this._x, i = this._y, r = this._z, o = this._w;
      let a = o * e._w + n * e._x + i * e._y + r * e._z;
      if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = n, this._y = i, this._z = r, this;
      const l = 1 - a * a;
      if (l <= Number.EPSILON) {
        const _ = 1 - t;
        return this._w = _ * o + t * this._w, this._x = _ * n + t * this._x, this._y = _ * i + t * this._y, this._z = _ * r + t * this._z, this.normalize(), this;
      }
      const c = Math.sqrt(l), h = Math.atan2(c, a), f = Math.sin((1 - t) * h) / c, m = Math.sin(t * h) / c;
      return this._w = o * f + this._w * m, this._x = n * f + this._x * m, this._y = i * f + this._y * m, this._z = r * f + this._z * m, this._onChangeCallback(), this;
    }
    slerpQuaternions(e, t, n) {
      return this.copy(e).slerp(t, n);
    }
    random() {
      const e = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), n = Math.random(), i = Math.sqrt(1 - n), r = Math.sqrt(n);
      return this.set(i * Math.sin(e), i * Math.cos(e), r * Math.sin(t), r * Math.cos(t));
    }
    equals(e) {
      return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
    }
    fromArray(e, t = 0) {
      return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
    }
    toArray(e = [], t = 0) {
      return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
    }
    fromBufferAttribute(e, t) {
      return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this;
    }
    toJSON() {
      return this.toArray();
    }
    _onChange(e) {
      return this._onChangeCallback = e, this;
    }
    _onChangeCallback() {
    }
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._w;
    }
  }
  class V {
    constructor(e = 0, t = 0, n = 0) {
      V.prototype.isVector3 = true, this.x = e, this.y = t, this.z = n;
    }
    set(e, t, n) {
      return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this;
    }
    setScalar(e) {
      return this.x = e, this.y = e, this.z = e, this;
    }
    setX(e) {
      return this.x = e, this;
    }
    setY(e) {
      return this.y = e, this;
    }
    setZ(e) {
      return this.z = e, this;
    }
    setComponent(e, t) {
      switch (e) {
        case 0:
          this.x = t;
          break;
        case 1:
          this.y = t;
          break;
        case 2:
          this.z = t;
          break;
        default:
          throw new Error("index is out of range: " + e);
      }
      return this;
    }
    getComponent(e) {
      switch (e) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + e);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(e) {
      return this.x = e.x, this.y = e.y, this.z = e.z, this;
    }
    add(e) {
      return this.x += e.x, this.y += e.y, this.z += e.z, this;
    }
    addScalar(e) {
      return this.x += e, this.y += e, this.z += e, this;
    }
    addVectors(e, t) {
      return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
    }
    addScaledVector(e, t) {
      return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
    }
    sub(e) {
      return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
    }
    subScalar(e) {
      return this.x -= e, this.y -= e, this.z -= e, this;
    }
    subVectors(e, t) {
      return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
    }
    multiply(e) {
      return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
    }
    multiplyScalar(e) {
      return this.x *= e, this.y *= e, this.z *= e, this;
    }
    multiplyVectors(e, t) {
      return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
    }
    applyEuler(e) {
      return this.applyQuaternion(Bd.setFromEuler(e));
    }
    applyAxisAngle(e, t) {
      return this.applyQuaternion(Bd.setFromAxisAngle(e, t));
    }
    applyMatrix3(e) {
      const t = this.x, n = this.y, i = this.z, r = e.elements;
      return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this;
    }
    applyNormalMatrix(e) {
      return this.applyMatrix3(e).normalize();
    }
    applyMatrix4(e) {
      const t = this.x, n = this.y, i = this.z, r = e.elements, o = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
      return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * o, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * o, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * o, this;
    }
    applyQuaternion(e) {
      const t = this.x, n = this.y, i = this.z, r = e.x, o = e.y, a = e.z, l = e.w, c = 2 * (o * i - a * n), h = 2 * (a * t - r * i), f = 2 * (r * n - o * t);
      return this.x = t + l * c + o * f - a * h, this.y = n + l * h + a * c - r * f, this.z = i + l * f + r * h - o * c, this;
    }
    project(e) {
      return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
    }
    unproject(e) {
      return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
    }
    transformDirection(e) {
      const t = this.x, n = this.y, i = this.z, r = e.elements;
      return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize();
    }
    divide(e) {
      return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
    }
    divideScalar(e) {
      return this.multiplyScalar(1 / e);
    }
    min(e) {
      return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
    }
    max(e) {
      return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
    }
    clamp(e, t) {
      return this.x = xt(this.x, e.x, t.x), this.y = xt(this.y, e.y, t.y), this.z = xt(this.z, e.z, t.z), this;
    }
    clampScalar(e, t) {
      return this.x = xt(this.x, e, t), this.y = xt(this.y, e, t), this.z = xt(this.z, e, t), this;
    }
    clampLength(e, t) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(xt(n, e, t));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
    }
    roundToZero() {
      return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    }
    dot(e) {
      return this.x * e.x + this.y * e.y + this.z * e.z;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
      return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
    }
    lerpVectors(e, t, n) {
      return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this;
    }
    cross(e) {
      return this.crossVectors(this, e);
    }
    crossVectors(e, t) {
      const n = e.x, i = e.y, r = e.z, o = t.x, a = t.y, l = t.z;
      return this.x = i * l - r * a, this.y = r * o - n * l, this.z = n * a - i * o, this;
    }
    projectOnVector(e) {
      const t = e.lengthSq();
      if (t === 0) return this.set(0, 0, 0);
      const n = e.dot(this) / t;
      return this.copy(e).multiplyScalar(n);
    }
    projectOnPlane(e) {
      return hu.copy(this).projectOnVector(e), this.sub(hu);
    }
    reflect(e) {
      return this.sub(hu.copy(e).multiplyScalar(2 * this.dot(e)));
    }
    angleTo(e) {
      const t = Math.sqrt(this.lengthSq() * e.lengthSq());
      if (t === 0) return Math.PI / 2;
      const n = this.dot(e) / t;
      return Math.acos(xt(n, -1, 1));
    }
    distanceTo(e) {
      return Math.sqrt(this.distanceToSquared(e));
    }
    distanceToSquared(e) {
      const t = this.x - e.x, n = this.y - e.y, i = this.z - e.z;
      return t * t + n * n + i * i;
    }
    manhattanDistanceTo(e) {
      return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
    }
    setFromSpherical(e) {
      return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
    }
    setFromSphericalCoords(e, t, n) {
      const i = Math.sin(t) * e;
      return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this;
    }
    setFromCylindrical(e) {
      return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
    }
    setFromCylindricalCoords(e, t, n) {
      return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this;
    }
    setFromMatrixPosition(e) {
      const t = e.elements;
      return this.x = t[12], this.y = t[13], this.z = t[14], this;
    }
    setFromMatrixScale(e) {
      const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), i = this.setFromMatrixColumn(e, 2).length();
      return this.x = t, this.y = n, this.z = i, this;
    }
    setFromMatrixColumn(e, t) {
      return this.fromArray(e.elements, t * 4);
    }
    setFromMatrix3Column(e, t) {
      return this.fromArray(e.elements, t * 3);
    }
    setFromEuler(e) {
      return this.x = e._x, this.y = e._y, this.z = e._z, this;
    }
    setFromColor(e) {
      return this.x = e.r, this.y = e.g, this.z = e.b, this;
    }
    equals(e) {
      return e.x === this.x && e.y === this.y && e.z === this.z;
    }
    fromArray(e, t = 0) {
      return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
    }
    toArray(e = [], t = 0) {
      return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
    }
    fromBufferAttribute(e, t) {
      return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
    }
    randomDirection() {
      const e = Math.random() * Math.PI * 2, t = Math.random() * 2 - 1, n = Math.sqrt(1 - t * t);
      return this.x = n * Math.cos(e), this.y = t, this.z = n * Math.sin(e), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z;
    }
  }
  const hu = new V(), Bd = new rs();
  class Rr {
    constructor(e = new V(1 / 0, 1 / 0, 1 / 0), t = new V(-1 / 0, -1 / 0, -1 / 0)) {
      this.isBox3 = true, this.min = e, this.max = t;
    }
    set(e, t) {
      return this.min.copy(e), this.max.copy(t), this;
    }
    setFromArray(e) {
      this.makeEmpty();
      for (let t = 0, n = e.length; t < n; t += 3) this.expandByPoint(Ri.fromArray(e, t));
      return this;
    }
    setFromBufferAttribute(e) {
      this.makeEmpty();
      for (let t = 0, n = e.count; t < n; t++) this.expandByPoint(Ri.fromBufferAttribute(e, t));
      return this;
    }
    setFromPoints(e) {
      this.makeEmpty();
      for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
      return this;
    }
    setFromCenterAndSize(e, t) {
      const n = Ri.copy(t).multiplyScalar(0.5);
      return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
    }
    setFromObject(e, t = false) {
      return this.makeEmpty(), this.expandByObject(e, t);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.min.copy(e.min), this.max.copy(e.max), this;
    }
    makeEmpty() {
      return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(e) {
      return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(e) {
      return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
    }
    expandByPoint(e) {
      return this.min.min(e), this.max.max(e), this;
    }
    expandByVector(e) {
      return this.min.sub(e), this.max.add(e), this;
    }
    expandByScalar(e) {
      return this.min.addScalar(-e), this.max.addScalar(e), this;
    }
    expandByObject(e, t = false) {
      e.updateWorldMatrix(false, false);
      const n = e.geometry;
      if (n !== void 0) {
        const r = n.getAttribute("position");
        if (t === true && r !== void 0 && e.isInstancedMesh !== true) for (let o = 0, a = r.count; o < a; o++) e.isMesh === true ? e.getVertexPosition(o, Ri) : Ri.fromBufferAttribute(r, o), Ri.applyMatrix4(e.matrixWorld), this.expandByPoint(Ri);
        else e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), wl.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), wl.copy(n.boundingBox)), wl.applyMatrix4(e.matrixWorld), this.union(wl);
      }
      const i = e.children;
      for (let r = 0, o = i.length; r < o; r++) this.expandByObject(i[r], t);
      return this;
    }
    containsPoint(e) {
      return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
    }
    containsBox(e) {
      return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
    }
    getParameter(e, t) {
      return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z));
    }
    intersectsBox(e) {
      return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
    }
    intersectsSphere(e) {
      return this.clampPoint(e.center, Ri), Ri.distanceToSquared(e.center) <= e.radius * e.radius;
    }
    intersectsPlane(e) {
      let t, n;
      return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant;
    }
    intersectsTriangle(e) {
      if (this.isEmpty()) return false;
      this.getCenter(ya), Al.subVectors(this.max, ya), Ks.subVectors(e.a, ya), Zs.subVectors(e.b, ya), Js.subVectors(e.c, ya), Or.subVectors(Zs, Ks), Fr.subVectors(Js, Zs), hs.subVectors(Ks, Js);
      let t = [
        0,
        -Or.z,
        Or.y,
        0,
        -Fr.z,
        Fr.y,
        0,
        -hs.z,
        hs.y,
        Or.z,
        0,
        -Or.x,
        Fr.z,
        0,
        -Fr.x,
        hs.z,
        0,
        -hs.x,
        -Or.y,
        Or.x,
        0,
        -Fr.y,
        Fr.x,
        0,
        -hs.y,
        hs.x,
        0
      ];
      return !fu(t, Ks, Zs, Js, Al) || (t = [
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ], !fu(t, Ks, Zs, Js, Al)) ? false : (Cl.crossVectors(Or, Fr), t = [
        Cl.x,
        Cl.y,
        Cl.z
      ], fu(t, Ks, Zs, Js, Al));
    }
    clampPoint(e, t) {
      return t.copy(e).clamp(this.min, this.max);
    }
    distanceToPoint(e) {
      return this.clampPoint(e, Ri).distanceTo(e);
    }
    getBoundingSphere(e) {
      return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Ri).length() * 0.5), e;
    }
    intersect(e) {
      return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
    }
    union(e) {
      return this.min.min(e.min), this.max.max(e.max), this;
    }
    applyMatrix4(e) {
      return this.isEmpty() ? this : (cr[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), cr[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), cr[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), cr[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), cr[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), cr[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), cr[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), cr[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(cr), this);
    }
    translate(e) {
      return this.min.add(e), this.max.add(e), this;
    }
    equals(e) {
      return e.min.equals(this.min) && e.max.equals(this.max);
    }
  }
  const cr = [
    new V(),
    new V(),
    new V(),
    new V(),
    new V(),
    new V(),
    new V(),
    new V()
  ], Ri = new V(), wl = new Rr(), Ks = new V(), Zs = new V(), Js = new V(), Or = new V(), Fr = new V(), hs = new V(), ya = new V(), Al = new V(), Cl = new V(), fs = new V();
  function fu(s, e, t, n, i) {
    for (let r = 0, o = s.length - 3; r <= o; r += 3) {
      fs.fromArray(s, r);
      const a = i.x * Math.abs(fs.x) + i.y * Math.abs(fs.y) + i.z * Math.abs(fs.z), l = e.dot(fs), c = t.dot(fs), h = n.dot(fs);
      if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > a) return false;
    }
    return true;
  }
  const Pv = new Rr(), xa = new V(), du = new V();
  class Qi {
    constructor(e = new V(), t = -1) {
      this.isSphere = true, this.center = e, this.radius = t;
    }
    set(e, t) {
      return this.center.copy(e), this.radius = t, this;
    }
    setFromPoints(e, t) {
      const n = this.center;
      t !== void 0 ? n.copy(t) : Pv.setFromPoints(e).getCenter(n);
      let i = 0;
      for (let r = 0, o = e.length; r < o; r++) i = Math.max(i, n.distanceToSquared(e[r]));
      return this.radius = Math.sqrt(i), this;
    }
    copy(e) {
      return this.center.copy(e.center), this.radius = e.radius, this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      return this.center.set(0, 0, 0), this.radius = -1, this;
    }
    containsPoint(e) {
      return e.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(e) {
      return e.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(e) {
      const t = this.radius + e.radius;
      return e.center.distanceToSquared(this.center) <= t * t;
    }
    intersectsBox(e) {
      return e.intersectsSphere(this);
    }
    intersectsPlane(e) {
      return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(e, t) {
      const n = this.center.distanceToSquared(e);
      return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
    }
    getBoundingBox(e) {
      return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
    }
    applyMatrix4(e) {
      return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
    }
    translate(e) {
      return this.center.add(e), this;
    }
    expandByPoint(e) {
      if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
      xa.subVectors(e, this.center);
      const t = xa.lengthSq();
      if (t > this.radius * this.radius) {
        const n = Math.sqrt(t), i = (n - this.radius) * 0.5;
        this.center.addScaledVector(xa, i / n), this.radius += i;
      }
      return this;
    }
    union(e) {
      return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === true ? this.radius = Math.max(this.radius, e.radius) : (du.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(xa.copy(e.center).add(du)), this.expandByPoint(xa.copy(e.center).sub(du))), this);
    }
    equals(e) {
      return e.center.equals(this.center) && e.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const ur = new V(), pu = new V(), Rl = new V(), kr = new V(), mu = new V(), Pl = new V(), gu = new V();
  class ul {
    constructor(e = new V(), t = new V(0, 0, -1)) {
      this.origin = e, this.direction = t;
    }
    set(e, t) {
      return this.origin.copy(e), this.direction.copy(t), this;
    }
    copy(e) {
      return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
    }
    at(e, t) {
      return t.copy(this.origin).addScaledVector(this.direction, e);
    }
    lookAt(e) {
      return this.direction.copy(e).sub(this.origin).normalize(), this;
    }
    recast(e) {
      return this.origin.copy(this.at(e, ur)), this;
    }
    closestPointToPoint(e, t) {
      t.subVectors(e, this.origin);
      const n = t.dot(this.direction);
      return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n);
    }
    distanceToPoint(e) {
      return Math.sqrt(this.distanceSqToPoint(e));
    }
    distanceSqToPoint(e) {
      const t = ur.subVectors(e, this.origin).dot(this.direction);
      return t < 0 ? this.origin.distanceToSquared(e) : (ur.copy(this.origin).addScaledVector(this.direction, t), ur.distanceToSquared(e));
    }
    distanceSqToSegment(e, t, n, i) {
      pu.copy(e).add(t).multiplyScalar(0.5), Rl.copy(t).sub(e).normalize(), kr.copy(this.origin).sub(pu);
      const r = e.distanceTo(t) * 0.5, o = -this.direction.dot(Rl), a = kr.dot(this.direction), l = -kr.dot(Rl), c = kr.lengthSq(), h = Math.abs(1 - o * o);
      let f, m, _, y;
      if (h > 0) if (f = o * l - a, m = o * a - l, y = r * h, f >= 0) if (m >= -y) if (m <= y) {
        const g = 1 / h;
        f *= g, m *= g, _ = f * (f + o * m + 2 * a) + m * (o * f + m + 2 * l) + c;
      } else m = r, f = Math.max(0, -(o * m + a)), _ = -f * f + m * (m + 2 * l) + c;
      else m = -r, f = Math.max(0, -(o * m + a)), _ = -f * f + m * (m + 2 * l) + c;
      else m <= -y ? (f = Math.max(0, -(-o * r + a)), m = f > 0 ? -r : Math.min(Math.max(-r, -l), r), _ = -f * f + m * (m + 2 * l) + c) : m <= y ? (f = 0, m = Math.min(Math.max(-r, -l), r), _ = m * (m + 2 * l) + c) : (f = Math.max(0, -(o * r + a)), m = f > 0 ? r : Math.min(Math.max(-r, -l), r), _ = -f * f + m * (m + 2 * l) + c);
      else m = o > 0 ? -r : r, f = Math.max(0, -(o * m + a)), _ = -f * f + m * (m + 2 * l) + c;
      return n && n.copy(this.origin).addScaledVector(this.direction, f), i && i.copy(pu).addScaledVector(Rl, m), _;
    }
    intersectSphere(e, t) {
      ur.subVectors(e.center, this.origin);
      const n = ur.dot(this.direction), i = ur.dot(ur) - n * n, r = e.radius * e.radius;
      if (i > r) return null;
      const o = Math.sqrt(r - i), a = n - o, l = n + o;
      return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
    }
    intersectsSphere(e) {
      return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
    }
    distanceToPlane(e) {
      const t = e.normal.dot(this.direction);
      if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
      const n = -(this.origin.dot(e.normal) + e.constant) / t;
      return n >= 0 ? n : null;
    }
    intersectPlane(e, t) {
      const n = this.distanceToPlane(e);
      return n === null ? null : this.at(n, t);
    }
    intersectsPlane(e) {
      const t = e.distanceToPoint(this.origin);
      return t === 0 || e.normal.dot(this.direction) * t < 0;
    }
    intersectBox(e, t) {
      let n, i, r, o, a, l;
      const c = 1 / this.direction.x, h = 1 / this.direction.y, f = 1 / this.direction.z, m = this.origin;
      return c >= 0 ? (n = (e.min.x - m.x) * c, i = (e.max.x - m.x) * c) : (n = (e.max.x - m.x) * c, i = (e.min.x - m.x) * c), h >= 0 ? (r = (e.min.y - m.y) * h, o = (e.max.y - m.y) * h) : (r = (e.max.y - m.y) * h, o = (e.min.y - m.y) * h), n > o || r > i || ((r > n || isNaN(n)) && (n = r), (o < i || isNaN(i)) && (i = o), f >= 0 ? (a = (e.min.z - m.z) * f, l = (e.max.z - m.z) * f) : (a = (e.max.z - m.z) * f, l = (e.min.z - m.z) * f), n > l || a > i) || ((a > n || n !== n) && (n = a), (l < i || i !== i) && (i = l), i < 0) ? null : this.at(n >= 0 ? n : i, t);
    }
    intersectsBox(e) {
      return this.intersectBox(e, ur) !== null;
    }
    intersectTriangle(e, t, n, i, r) {
      mu.subVectors(t, e), Pl.subVectors(n, e), gu.crossVectors(mu, Pl);
      let o = this.direction.dot(gu), a;
      if (o > 0) {
        if (i) return null;
        a = 1;
      } else if (o < 0) a = -1, o = -o;
      else return null;
      kr.subVectors(this.origin, e);
      const l = a * this.direction.dot(Pl.crossVectors(kr, Pl));
      if (l < 0) return null;
      const c = a * this.direction.dot(mu.cross(kr));
      if (c < 0 || l + c > o) return null;
      const h = -a * kr.dot(gu);
      return h < 0 ? null : this.at(h / o, r);
    }
    applyMatrix4(e) {
      return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
    }
    equals(e) {
      return e.origin.equals(this.origin) && e.direction.equals(this.direction);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class pt {
    constructor(e, t, n, i, r, o, a, l, c, h, f, m, _, y, g, x) {
      pt.prototype.isMatrix4 = true, this.elements = [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ], e !== void 0 && this.set(e, t, n, i, r, o, a, l, c, h, f, m, _, y, g, x);
    }
    set(e, t, n, i, r, o, a, l, c, h, f, m, _, y, g, x) {
      const v = this.elements;
      return v[0] = e, v[4] = t, v[8] = n, v[12] = i, v[1] = r, v[5] = o, v[9] = a, v[13] = l, v[2] = c, v[6] = h, v[10] = f, v[14] = m, v[3] = _, v[7] = y, v[11] = g, v[15] = x, this;
    }
    identity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    clone() {
      return new pt().fromArray(this.elements);
    }
    copy(e) {
      const t = this.elements, n = e.elements;
      return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this;
    }
    copyPosition(e) {
      const t = this.elements, n = e.elements;
      return t[12] = n[12], t[13] = n[13], t[14] = n[14], this;
    }
    setFromMatrix3(e) {
      const t = e.elements;
      return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this;
    }
    extractBasis(e, t, n) {
      return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
    }
    makeBasis(e, t, n) {
      return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this;
    }
    extractRotation(e) {
      const t = this.elements, n = e.elements, i = 1 / Qs.setFromMatrixColumn(e, 0).length(), r = 1 / Qs.setFromMatrixColumn(e, 1).length(), o = 1 / Qs.setFromMatrixColumn(e, 2).length();
      return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * o, t[9] = n[9] * o, t[10] = n[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
    }
    makeRotationFromEuler(e) {
      const t = this.elements, n = e.x, i = e.y, r = e.z, o = Math.cos(n), a = Math.sin(n), l = Math.cos(i), c = Math.sin(i), h = Math.cos(r), f = Math.sin(r);
      if (e.order === "XYZ") {
        const m = o * h, _ = o * f, y = a * h, g = a * f;
        t[0] = l * h, t[4] = -l * f, t[8] = c, t[1] = _ + y * c, t[5] = m - g * c, t[9] = -a * l, t[2] = g - m * c, t[6] = y + _ * c, t[10] = o * l;
      } else if (e.order === "YXZ") {
        const m = l * h, _ = l * f, y = c * h, g = c * f;
        t[0] = m + g * a, t[4] = y * a - _, t[8] = o * c, t[1] = o * f, t[5] = o * h, t[9] = -a, t[2] = _ * a - y, t[6] = g + m * a, t[10] = o * l;
      } else if (e.order === "ZXY") {
        const m = l * h, _ = l * f, y = c * h, g = c * f;
        t[0] = m - g * a, t[4] = -o * f, t[8] = y + _ * a, t[1] = _ + y * a, t[5] = o * h, t[9] = g - m * a, t[2] = -o * c, t[6] = a, t[10] = o * l;
      } else if (e.order === "ZYX") {
        const m = o * h, _ = o * f, y = a * h, g = a * f;
        t[0] = l * h, t[4] = y * c - _, t[8] = m * c + g, t[1] = l * f, t[5] = g * c + m, t[9] = _ * c - y, t[2] = -c, t[6] = a * l, t[10] = o * l;
      } else if (e.order === "YZX") {
        const m = o * l, _ = o * c, y = a * l, g = a * c;
        t[0] = l * h, t[4] = g - m * f, t[8] = y * f + _, t[1] = f, t[5] = o * h, t[9] = -a * h, t[2] = -c * h, t[6] = _ * f + y, t[10] = m - g * f;
      } else if (e.order === "XZY") {
        const m = o * l, _ = o * c, y = a * l, g = a * c;
        t[0] = l * h, t[4] = -f, t[8] = c * h, t[1] = m * f + g, t[5] = o * h, t[9] = _ * f - y, t[2] = y * f - _, t[6] = a * h, t[10] = g * f + m;
      }
      return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
    }
    makeRotationFromQuaternion(e) {
      return this.compose(Dv, e, Lv);
    }
    lookAt(e, t, n) {
      const i = this.elements;
      return oi.subVectors(e, t), oi.lengthSq() === 0 && (oi.z = 1), oi.normalize(), Br.crossVectors(n, oi), Br.lengthSq() === 0 && (Math.abs(n.z) === 1 ? oi.x += 1e-4 : oi.z += 1e-4, oi.normalize(), Br.crossVectors(n, oi)), Br.normalize(), Dl.crossVectors(oi, Br), i[0] = Br.x, i[4] = Dl.x, i[8] = oi.x, i[1] = Br.y, i[5] = Dl.y, i[9] = oi.y, i[2] = Br.z, i[6] = Dl.z, i[10] = oi.z, this;
    }
    multiply(e) {
      return this.multiplyMatrices(this, e);
    }
    premultiply(e) {
      return this.multiplyMatrices(e, this);
    }
    multiplyMatrices(e, t) {
      const n = e.elements, i = t.elements, r = this.elements, o = n[0], a = n[4], l = n[8], c = n[12], h = n[1], f = n[5], m = n[9], _ = n[13], y = n[2], g = n[6], x = n[10], v = n[14], E = n[3], T = n[7], M = n[11], P = n[15], R = i[0], d = i[4], N = i[8], w = i[12], D = i[1], B = i[5], Z = i[9], G = i[13], Q = i[2], ue = i[6], te = i[10], he = i[14], ie = i[3], Me = i[7], Ce = i[11], Le = i[15];
      return r[0] = o * R + a * D + l * Q + c * ie, r[4] = o * d + a * B + l * ue + c * Me, r[8] = o * N + a * Z + l * te + c * Ce, r[12] = o * w + a * G + l * he + c * Le, r[1] = h * R + f * D + m * Q + _ * ie, r[5] = h * d + f * B + m * ue + _ * Me, r[9] = h * N + f * Z + m * te + _ * Ce, r[13] = h * w + f * G + m * he + _ * Le, r[2] = y * R + g * D + x * Q + v * ie, r[6] = y * d + g * B + x * ue + v * Me, r[10] = y * N + g * Z + x * te + v * Ce, r[14] = y * w + g * G + x * he + v * Le, r[3] = E * R + T * D + M * Q + P * ie, r[7] = E * d + T * B + M * ue + P * Me, r[11] = E * N + T * Z + M * te + P * Ce, r[15] = E * w + T * G + M * he + P * Le, this;
    }
    multiplyScalar(e) {
      const t = this.elements;
      return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
    }
    determinant() {
      const e = this.elements, t = e[0], n = e[4], i = e[8], r = e[12], o = e[1], a = e[5], l = e[9], c = e[13], h = e[2], f = e[6], m = e[10], _ = e[14], y = e[3], g = e[7], x = e[11], v = e[15];
      return y * (+r * l * f - i * c * f - r * a * m + n * c * m + i * a * _ - n * l * _) + g * (+t * l * _ - t * c * m + r * o * m - i * o * _ + i * c * h - r * l * h) + x * (+t * c * f - t * a * _ - r * o * f + n * o * _ + r * a * h - n * c * h) + v * (-i * a * h - t * l * f + t * a * m + i * o * f - n * o * m + n * l * h);
    }
    transpose() {
      const e = this.elements;
      let t;
      return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
    }
    setPosition(e, t, n) {
      const i = this.elements;
      return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this;
    }
    invert() {
      const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], o = e[4], a = e[5], l = e[6], c = e[7], h = e[8], f = e[9], m = e[10], _ = e[11], y = e[12], g = e[13], x = e[14], v = e[15], E = f * x * c - g * m * c + g * l * _ - a * x * _ - f * l * v + a * m * v, T = y * m * c - h * x * c - y * l * _ + o * x * _ + h * l * v - o * m * v, M = h * g * c - y * f * c + y * a * _ - o * g * _ - h * a * v + o * f * v, P = y * f * l - h * g * l - y * a * m + o * g * m + h * a * x - o * f * x, R = t * E + n * T + i * M + r * P;
      if (R === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const d = 1 / R;
      return e[0] = E * d, e[1] = (g * m * r - f * x * r - g * i * _ + n * x * _ + f * i * v - n * m * v) * d, e[2] = (a * x * r - g * l * r + g * i * c - n * x * c - a * i * v + n * l * v) * d, e[3] = (f * l * r - a * m * r - f * i * c + n * m * c + a * i * _ - n * l * _) * d, e[4] = T * d, e[5] = (h * x * r - y * m * r + y * i * _ - t * x * _ - h * i * v + t * m * v) * d, e[6] = (y * l * r - o * x * r - y * i * c + t * x * c + o * i * v - t * l * v) * d, e[7] = (o * m * r - h * l * r + h * i * c - t * m * c - o * i * _ + t * l * _) * d, e[8] = M * d, e[9] = (y * f * r - h * g * r - y * n * _ + t * g * _ + h * n * v - t * f * v) * d, e[10] = (o * g * r - y * a * r + y * n * c - t * g * c - o * n * v + t * a * v) * d, e[11] = (h * a * r - o * f * r - h * n * c + t * f * c + o * n * _ - t * a * _) * d, e[12] = P * d, e[13] = (h * g * i - y * f * i + y * n * m - t * g * m - h * n * x + t * f * x) * d, e[14] = (y * a * i - o * g * i - y * n * l + t * g * l + o * n * x - t * a * x) * d, e[15] = (o * f * i - h * a * i + h * n * l - t * f * l - o * n * m + t * a * m) * d, this;
    }
    scale(e) {
      const t = this.elements, n = e.x, i = e.y, r = e.z;
      return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this;
    }
    getMaxScaleOnAxis() {
      const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
      return Math.sqrt(Math.max(t, n, i));
    }
    makeTranslation(e, t, n) {
      return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
    }
    makeRotationX(e) {
      const t = Math.cos(e), n = Math.sin(e);
      return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
    }
    makeRotationY(e) {
      const t = Math.cos(e), n = Math.sin(e);
      return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
    }
    makeRotationZ(e) {
      const t = Math.cos(e), n = Math.sin(e);
      return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    makeRotationAxis(e, t) {
      const n = Math.cos(t), i = Math.sin(t), r = 1 - n, o = e.x, a = e.y, l = e.z, c = r * o, h = r * a;
      return this.set(c * o + n, c * a - i * l, c * l + i * a, 0, c * a + i * l, h * a + n, h * l - i * o, 0, c * l - i * a, h * l + i * o, r * l * l + n, 0, 0, 0, 0, 1), this;
    }
    makeScale(e, t, n) {
      return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
    }
    makeShear(e, t, n, i, r, o) {
      return this.set(1, n, r, 0, e, 1, o, 0, t, i, 1, 0, 0, 0, 0, 1), this;
    }
    compose(e, t, n) {
      const i = this.elements, r = t._x, o = t._y, a = t._z, l = t._w, c = r + r, h = o + o, f = a + a, m = r * c, _ = r * h, y = r * f, g = o * h, x = o * f, v = a * f, E = l * c, T = l * h, M = l * f, P = n.x, R = n.y, d = n.z;
      return i[0] = (1 - (g + v)) * P, i[1] = (_ + M) * P, i[2] = (y - T) * P, i[3] = 0, i[4] = (_ - M) * R, i[5] = (1 - (m + v)) * R, i[6] = (x + E) * R, i[7] = 0, i[8] = (y + T) * d, i[9] = (x - E) * d, i[10] = (1 - (m + g)) * d, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this;
    }
    decompose(e, t, n) {
      const i = this.elements;
      let r = Qs.set(i[0], i[1], i[2]).length();
      const o = Qs.set(i[4], i[5], i[6]).length(), a = Qs.set(i[8], i[9], i[10]).length();
      this.determinant() < 0 && (r = -r), e.x = i[12], e.y = i[13], e.z = i[14], Pi.copy(this);
      const c = 1 / r, h = 1 / o, f = 1 / a;
      return Pi.elements[0] *= c, Pi.elements[1] *= c, Pi.elements[2] *= c, Pi.elements[4] *= h, Pi.elements[5] *= h, Pi.elements[6] *= h, Pi.elements[8] *= f, Pi.elements[9] *= f, Pi.elements[10] *= f, t.setFromRotationMatrix(Pi), n.x = r, n.y = o, n.z = a, this;
    }
    makePerspective(e, t, n, i, r, o, a = br) {
      const l = this.elements, c = 2 * r / (t - e), h = 2 * r / (n - i), f = (t + e) / (t - e), m = (n + i) / (n - i);
      let _, y;
      if (a === br) _ = -(o + r) / (o - r), y = -2 * o * r / (o - r);
      else if (a === Mc) _ = -o / (o - r), y = -o * r / (o - r);
      else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
      return l[0] = c, l[4] = 0, l[8] = f, l[12] = 0, l[1] = 0, l[5] = h, l[9] = m, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = _, l[14] = y, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
    }
    makeOrthographic(e, t, n, i, r, o, a = br) {
      const l = this.elements, c = 1 / (t - e), h = 1 / (n - i), f = 1 / (o - r), m = (t + e) * c, _ = (n + i) * h;
      let y, g;
      if (a === br) y = (o + r) * f, g = -2 * f;
      else if (a === Mc) y = r * f, g = -1 * f;
      else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
      return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -m, l[1] = 0, l[5] = 2 * h, l[9] = 0, l[13] = -_, l[2] = 0, l[6] = 0, l[10] = g, l[14] = -y, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
    }
    equals(e) {
      const t = this.elements, n = e.elements;
      for (let i = 0; i < 16; i++) if (t[i] !== n[i]) return false;
      return true;
    }
    fromArray(e, t = 0) {
      for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
      return this;
    }
    toArray(e = [], t = 0) {
      const n = this.elements;
      return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e;
    }
  }
  const Qs = new V(), Pi = new pt(), Dv = new V(0, 0, 0), Lv = new V(1, 1, 1), Br = new V(), Dl = new V(), oi = new V(), zd = new pt(), Hd = new rs();
  class Zi {
    constructor(e = 0, t = 0, n = 0, i = Zi.DEFAULT_ORDER) {
      this.isEuler = true, this._x = e, this._y = t, this._z = n, this._order = i;
    }
    get x() {
      return this._x;
    }
    set x(e) {
      this._x = e, this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(e) {
      this._y = e, this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(e) {
      this._z = e, this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(e) {
      this._order = e, this._onChangeCallback();
    }
    set(e, t, n, i = this._order) {
      return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(e) {
      return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
    }
    setFromRotationMatrix(e, t = this._order, n = true) {
      const i = e.elements, r = i[0], o = i[4], a = i[8], l = i[1], c = i[5], h = i[9], f = i[2], m = i[6], _ = i[10];
      switch (t) {
        case "XYZ":
          this._y = Math.asin(xt(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(-h, _), this._z = Math.atan2(-o, r)) : (this._x = Math.atan2(m, c), this._z = 0);
          break;
        case "YXZ":
          this._x = Math.asin(-xt(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(a, _), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-f, r), this._z = 0);
          break;
        case "ZXY":
          this._x = Math.asin(xt(m, -1, 1)), Math.abs(m) < 0.9999999 ? (this._y = Math.atan2(-f, _), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, r));
          break;
        case "ZYX":
          this._y = Math.asin(-xt(f, -1, 1)), Math.abs(f) < 0.9999999 ? (this._x = Math.atan2(m, _), this._z = Math.atan2(l, r)) : (this._x = 0, this._z = Math.atan2(-o, c));
          break;
        case "YZX":
          this._z = Math.asin(xt(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-f, r)) : (this._x = 0, this._y = Math.atan2(a, _));
          break;
        case "XZY":
          this._z = Math.asin(-xt(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(m, c), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-h, _), this._y = 0);
          break;
        default:
          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
      }
      return this._order = t, n === true && this._onChangeCallback(), this;
    }
    setFromQuaternion(e, t, n) {
      return zd.makeRotationFromQuaternion(e), this.setFromRotationMatrix(zd, t, n);
    }
    setFromVector3(e, t = this._order) {
      return this.set(e.x, e.y, e.z, t);
    }
    reorder(e) {
      return Hd.setFromEuler(this), this.setFromQuaternion(Hd, e);
    }
    equals(e) {
      return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
    }
    fromArray(e) {
      return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
    }
    toArray(e = [], t = 0) {
      return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
    }
    _onChange(e) {
      return this._onChangeCallback = e, this;
    }
    _onChangeCallback() {
    }
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._order;
    }
  }
  Zi.DEFAULT_ORDER = "XYZ";
  class Rf {
    constructor() {
      this.mask = 1;
    }
    set(e) {
      this.mask = (1 << e | 0) >>> 0;
    }
    enable(e) {
      this.mask |= 1 << e | 0;
    }
    enableAll() {
      this.mask = -1;
    }
    toggle(e) {
      this.mask ^= 1 << e | 0;
    }
    disable(e) {
      this.mask &= ~(1 << e | 0);
    }
    disableAll() {
      this.mask = 0;
    }
    test(e) {
      return (this.mask & e.mask) !== 0;
    }
    isEnabled(e) {
      return (this.mask & (1 << e | 0)) !== 0;
    }
  }
  let Iv = 0;
  const Vd = new V(), eo = new rs(), hr = new pt(), Ll = new V(), ba = new V(), Nv = new V(), Uv = new rs(), Gd = new V(1, 0, 0), Wd = new V(0, 1, 0), Xd = new V(0, 0, 1), qd = {
    type: "added"
  }, Ov = {
    type: "removed"
  }, to = {
    type: "childadded",
    child: null
  }, _u = {
    type: "childremoved",
    child: null
  };
  class on extends qo {
    constructor() {
      super(), this.isObject3D = true, Object.defineProperty(this, "id", {
        value: Iv++
      }), this.uuid = wi(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = on.DEFAULT_UP.clone();
      const e = new V(), t = new Zi(), n = new rs(), i = new V(1, 1, 1);
      function r() {
        n.setFromEuler(t, false);
      }
      function o() {
        t.setFromQuaternion(n, void 0, false);
      }
      t._onChange(r), n._onChange(o), Object.defineProperties(this, {
        position: {
          configurable: true,
          enumerable: true,
          value: e
        },
        rotation: {
          configurable: true,
          enumerable: true,
          value: t
        },
        quaternion: {
          configurable: true,
          enumerable: true,
          value: n
        },
        scale: {
          configurable: true,
          enumerable: true,
          value: i
        },
        modelViewMatrix: {
          value: new pt()
        },
        normalMatrix: {
          value: new mt()
        }
      }), this.matrix = new pt(), this.matrixWorld = new pt(), this.matrixAutoUpdate = on.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = on.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = false, this.layers = new Rf(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
    }
    onBeforeShadow() {
    }
    onAfterShadow() {
    }
    onBeforeRender() {
    }
    onAfterRender() {
    }
    applyMatrix4(e) {
      this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(e) {
      return this.quaternion.premultiply(e), this;
    }
    setRotationFromAxisAngle(e, t) {
      this.quaternion.setFromAxisAngle(e, t);
    }
    setRotationFromEuler(e) {
      this.quaternion.setFromEuler(e, true);
    }
    setRotationFromMatrix(e) {
      this.quaternion.setFromRotationMatrix(e);
    }
    setRotationFromQuaternion(e) {
      this.quaternion.copy(e);
    }
    rotateOnAxis(e, t) {
      return eo.setFromAxisAngle(e, t), this.quaternion.multiply(eo), this;
    }
    rotateOnWorldAxis(e, t) {
      return eo.setFromAxisAngle(e, t), this.quaternion.premultiply(eo), this;
    }
    rotateX(e) {
      return this.rotateOnAxis(Gd, e);
    }
    rotateY(e) {
      return this.rotateOnAxis(Wd, e);
    }
    rotateZ(e) {
      return this.rotateOnAxis(Xd, e);
    }
    translateOnAxis(e, t) {
      return Vd.copy(e).applyQuaternion(this.quaternion), this.position.add(Vd.multiplyScalar(t)), this;
    }
    translateX(e) {
      return this.translateOnAxis(Gd, e);
    }
    translateY(e) {
      return this.translateOnAxis(Wd, e);
    }
    translateZ(e) {
      return this.translateOnAxis(Xd, e);
    }
    localToWorld(e) {
      return this.updateWorldMatrix(true, false), e.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(e) {
      return this.updateWorldMatrix(true, false), e.applyMatrix4(hr.copy(this.matrixWorld).invert());
    }
    lookAt(e, t, n) {
      e.isVector3 ? Ll.copy(e) : Ll.set(e, t, n);
      const i = this.parent;
      this.updateWorldMatrix(true, false), ba.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? hr.lookAt(ba, Ll, this.up) : hr.lookAt(Ll, ba, this.up), this.quaternion.setFromRotationMatrix(hr), i && (hr.extractRotation(i.matrixWorld), eo.setFromRotationMatrix(hr), this.quaternion.premultiply(eo.invert()));
    }
    add(e) {
      if (arguments.length > 1) {
        for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
        return this;
      }
      return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(qd), to.child = e, this.dispatchEvent(to), to.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
    }
    remove(e) {
      if (arguments.length > 1) {
        for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
        return this;
      }
      const t = this.children.indexOf(e);
      return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(Ov), _u.child = e, this.dispatchEvent(_u), _u.child = null), this;
    }
    removeFromParent() {
      const e = this.parent;
      return e !== null && e.remove(this), this;
    }
    clear() {
      return this.remove(...this.children);
    }
    attach(e) {
      return this.updateWorldMatrix(true, false), hr.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(true, false), hr.multiply(e.parent.matrixWorld)), e.applyMatrix4(hr), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(false, true), e.dispatchEvent(qd), to.child = e, this.dispatchEvent(to), to.child = null, this;
    }
    getObjectById(e) {
      return this.getObjectByProperty("id", e);
    }
    getObjectByName(e) {
      return this.getObjectByProperty("name", e);
    }
    getObjectByProperty(e, t) {
      if (this[e] === t) return this;
      for (let n = 0, i = this.children.length; n < i; n++) {
        const o = this.children[n].getObjectByProperty(e, t);
        if (o !== void 0) return o;
      }
    }
    getObjectsByProperty(e, t, n = []) {
      this[e] === t && n.push(this);
      const i = this.children;
      for (let r = 0, o = i.length; r < o; r++) i[r].getObjectsByProperty(e, t, n);
      return n;
    }
    getWorldPosition(e) {
      return this.updateWorldMatrix(true, false), e.setFromMatrixPosition(this.matrixWorld);
    }
    getWorldQuaternion(e) {
      return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(ba, e, Nv), e;
    }
    getWorldScale(e) {
      return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(ba, Uv, e), e;
    }
    getWorldDirection(e) {
      this.updateWorldMatrix(true, false);
      const t = this.matrixWorld.elements;
      return e.set(t[8], t[9], t[10]).normalize();
    }
    raycast() {
    }
    traverse(e) {
      e(this);
      const t = this.children;
      for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
    }
    traverseVisible(e) {
      if (this.visible === false) return;
      e(this);
      const t = this.children;
      for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
    }
    traverseAncestors(e) {
      const t = this.parent;
      t !== null && (e(t), t.traverseAncestors(e));
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
    }
    updateMatrixWorld(e) {
      this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === true && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = false, e = true);
      const t = this.children;
      for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e);
    }
    updateWorldMatrix(e, t) {
      const n = this.parent;
      if (e === true && n !== null && n.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === true && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), t === true) {
        const i = this.children;
        for (let r = 0, o = i.length; r < o; r++) i[r].updateWorldMatrix(false, true);
      }
    }
    toJSON(e) {
      const t = e === void 0 || typeof e == "string", n = {};
      t && (e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      }, n.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON"
      });
      const i = {};
      i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === true && (i.castShadow = true), this.receiveShadow === true && (i.receiveShadow = true), this.visible === false && (i.visible = false), this.frustumCulled === false && (i.frustumCulled = false), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === false && (i.matrixAutoUpdate = false), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.visibility = this._visibility, i.active = this._active, i.bounds = this._bounds.map((a) => ({
        boxInitialized: a.boxInitialized,
        boxMin: a.box.min.toArray(),
        boxMax: a.box.max.toArray(),
        sphereInitialized: a.sphereInitialized,
        sphereRadius: a.sphere.radius,
        sphereCenter: a.sphere.center.toArray()
      })), i.maxInstanceCount = this._maxInstanceCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.geometryCount = this._geometryCount, i.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (i.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (i.boundingSphere = {
        center: i.boundingSphere.center.toArray(),
        radius: i.boundingSphere.radius
      }), this.boundingBox !== null && (i.boundingBox = {
        min: i.boundingBox.min.toArray(),
        max: i.boundingBox.max.toArray()
      }));
      function r(a, l) {
        return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
      }
      if (this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true && (i.environment = this.environment.toJSON(e).uuid);
      else if (this.isMesh || this.isLine || this.isPoints) {
        i.geometry = r(e.geometries, this.geometry);
        const a = this.geometry.parameters;
        if (a !== void 0 && a.shapes !== void 0) {
          const l = a.shapes;
          if (Array.isArray(l)) for (let c = 0, h = l.length; c < h; c++) {
            const f = l[c];
            r(e.shapes, f);
          }
          else r(e.shapes, l);
        }
      }
      if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) {
        const a = [];
        for (let l = 0, c = this.material.length; l < c; l++) a.push(r(e.materials, this.material[l]));
        i.material = a;
      } else i.material = r(e.materials, this.material);
      if (this.children.length > 0) {
        i.children = [];
        for (let a = 0; a < this.children.length; a++) i.children.push(this.children[a].toJSON(e).object);
      }
      if (this.animations.length > 0) {
        i.animations = [];
        for (let a = 0; a < this.animations.length; a++) {
          const l = this.animations[a];
          i.animations.push(r(e.animations, l));
        }
      }
      if (t) {
        const a = o(e.geometries), l = o(e.materials), c = o(e.textures), h = o(e.images), f = o(e.shapes), m = o(e.skeletons), _ = o(e.animations), y = o(e.nodes);
        a.length > 0 && (n.geometries = a), l.length > 0 && (n.materials = l), c.length > 0 && (n.textures = c), h.length > 0 && (n.images = h), f.length > 0 && (n.shapes = f), m.length > 0 && (n.skeletons = m), _.length > 0 && (n.animations = _), y.length > 0 && (n.nodes = y);
      }
      return n.object = i, n;
      function o(a) {
        const l = [];
        for (const c in a) {
          const h = a[c];
          delete h.metadata, l.push(h);
        }
        return l;
      }
    }
    clone(e) {
      return new this.constructor().copy(this, e);
    }
    copy(e, t = true) {
      if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === true) for (let n = 0; n < e.children.length; n++) {
        const i = e.children[n];
        this.add(i.clone());
      }
      return this;
    }
  }
  on.DEFAULT_UP = new V(0, 1, 0);
  on.DEFAULT_MATRIX_AUTO_UPDATE = true;
  on.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
  const Di = new V(), fr = new V(), vu = new V(), dr = new V(), no = new V(), io = new V(), Yd = new V(), yu = new V(), xu = new V(), bu = new V(), Su = new zt(), Mu = new zt(), Tu = new zt();
  class Ii {
    constructor(e = new V(), t = new V(), n = new V()) {
      this.a = e, this.b = t, this.c = n;
    }
    static getNormal(e, t, n, i) {
      i.subVectors(n, t), Di.subVectors(e, t), i.cross(Di);
      const r = i.lengthSq();
      return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
    }
    static getBarycoord(e, t, n, i, r) {
      Di.subVectors(i, t), fr.subVectors(n, t), vu.subVectors(e, t);
      const o = Di.dot(Di), a = Di.dot(fr), l = Di.dot(vu), c = fr.dot(fr), h = fr.dot(vu), f = o * c - a * a;
      if (f === 0) return r.set(0, 0, 0), null;
      const m = 1 / f, _ = (c * l - a * h) * m, y = (o * h - a * l) * m;
      return r.set(1 - _ - y, y, _);
    }
    static containsPoint(e, t, n, i) {
      return this.getBarycoord(e, t, n, i, dr) === null ? false : dr.x >= 0 && dr.y >= 0 && dr.x + dr.y <= 1;
    }
    static getInterpolation(e, t, n, i, r, o, a, l) {
      return this.getBarycoord(e, t, n, i, dr) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(r, dr.x), l.addScaledVector(o, dr.y), l.addScaledVector(a, dr.z), l);
    }
    static getInterpolatedAttribute(e, t, n, i, r, o) {
      return Su.setScalar(0), Mu.setScalar(0), Tu.setScalar(0), Su.fromBufferAttribute(e, t), Mu.fromBufferAttribute(e, n), Tu.fromBufferAttribute(e, i), o.setScalar(0), o.addScaledVector(Su, r.x), o.addScaledVector(Mu, r.y), o.addScaledVector(Tu, r.z), o;
    }
    static isFrontFacing(e, t, n, i) {
      return Di.subVectors(n, t), fr.subVectors(e, t), Di.cross(fr).dot(i) < 0;
    }
    set(e, t, n) {
      return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
    }
    setFromPointsAndIndices(e, t, n, i) {
      return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
    }
    setFromAttributeAndIndices(e, t, n, i) {
      return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
    }
    getArea() {
      return Di.subVectors(this.c, this.b), fr.subVectors(this.a, this.b), Di.cross(fr).length() * 0.5;
    }
    getMidpoint(e) {
      return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(e) {
      return Ii.getNormal(this.a, this.b, this.c, e);
    }
    getPlane(e) {
      return e.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(e, t) {
      return Ii.getBarycoord(e, this.a, this.b, this.c, t);
    }
    getInterpolation(e, t, n, i, r) {
      return Ii.getInterpolation(e, this.a, this.b, this.c, t, n, i, r);
    }
    containsPoint(e) {
      return Ii.containsPoint(e, this.a, this.b, this.c);
    }
    isFrontFacing(e) {
      return Ii.isFrontFacing(this.a, this.b, this.c, e);
    }
    intersectsBox(e) {
      return e.intersectsTriangle(this);
    }
    closestPointToPoint(e, t) {
      const n = this.a, i = this.b, r = this.c;
      let o, a;
      no.subVectors(i, n), io.subVectors(r, n), yu.subVectors(e, n);
      const l = no.dot(yu), c = io.dot(yu);
      if (l <= 0 && c <= 0) return t.copy(n);
      xu.subVectors(e, i);
      const h = no.dot(xu), f = io.dot(xu);
      if (h >= 0 && f <= h) return t.copy(i);
      const m = l * f - h * c;
      if (m <= 0 && l >= 0 && h <= 0) return o = l / (l - h), t.copy(n).addScaledVector(no, o);
      bu.subVectors(e, r);
      const _ = no.dot(bu), y = io.dot(bu);
      if (y >= 0 && _ <= y) return t.copy(r);
      const g = _ * c - l * y;
      if (g <= 0 && c >= 0 && y <= 0) return a = c / (c - y), t.copy(n).addScaledVector(io, a);
      const x = h * y - _ * f;
      if (x <= 0 && f - h >= 0 && _ - y >= 0) return Yd.subVectors(r, i), a = (f - h) / (f - h + (_ - y)), t.copy(i).addScaledVector(Yd, a);
      const v = 1 / (x + g + m);
      return o = g * v, a = m * v, t.copy(n).addScaledVector(no, o).addScaledVector(io, a);
    }
    equals(e) {
      return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
    }
  }
  const $m = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  }, zr = {
    h: 0,
    s: 0,
    l: 0
  }, Il = {
    h: 0,
    s: 0,
    l: 0
  };
  function Eu(s, e, t) {
    return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? s + (e - s) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? s + (e - s) * 6 * (2 / 3 - t) : s;
  }
  class it {
    constructor(e, t, n) {
      return this.isColor = true, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n);
    }
    set(e, t, n) {
      if (t === void 0 && n === void 0) {
        const i = e;
        i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i);
      } else this.setRGB(e, t, n);
      return this;
    }
    setScalar(e) {
      return this.r = e, this.g = e, this.b = e, this;
    }
    setHex(e, t = Dn) {
      return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, It.toWorkingColorSpace(this, t), this;
    }
    setRGB(e, t, n, i = It.workingColorSpace) {
      return this.r = e, this.g = t, this.b = n, It.toWorkingColorSpace(this, i), this;
    }
    setHSL(e, t, n, i = It.workingColorSpace) {
      if (e = Cf(e, 1), t = xt(t, 0, 1), n = xt(n, 0, 1), t === 0) this.r = this.g = this.b = n;
      else {
        const r = n <= 0.5 ? n * (1 + t) : n + t - n * t, o = 2 * n - r;
        this.r = Eu(o, r, e + 1 / 3), this.g = Eu(o, r, e), this.b = Eu(o, r, e - 1 / 3);
      }
      return It.toWorkingColorSpace(this, i), this;
    }
    setStyle(e, t = Dn) {
      function n(r) {
        r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
      }
      let i;
      if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
        let r;
        const o = i[1], a = i[2];
        switch (o) {
          case "rgb":
          case "rgba":
            if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(r[4]), this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, t);
            if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(r[4]), this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, t);
            break;
          case "hsl":
          case "hsla":
            if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(r[4]), this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, t);
            break;
          default:
            console.warn("THREE.Color: Unknown color model " + e);
        }
      } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
        const r = i[1], o = r.length;
        if (o === 3) return this.setRGB(parseInt(r.charAt(0), 16) / 15, parseInt(r.charAt(1), 16) / 15, parseInt(r.charAt(2), 16) / 15, t);
        if (o === 6) return this.setHex(parseInt(r, 16), t);
        console.warn("THREE.Color: Invalid hex color " + e);
      } else if (e && e.length > 0) return this.setColorName(e, t);
      return this;
    }
    setColorName(e, t = Dn) {
      const n = $m[e.toLowerCase()];
      return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(e) {
      return this.r = e.r, this.g = e.g, this.b = e.b, this;
    }
    copySRGBToLinear(e) {
      return this.r = Tr(e.r), this.g = Tr(e.g), this.b = Tr(e.b), this;
    }
    copyLinearToSRGB(e) {
      return this.r = bo(e.r), this.g = bo(e.g), this.b = bo(e.b), this;
    }
    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }
    getHex(e = Dn) {
      return It.fromWorkingColorSpace(On.copy(this), e), Math.round(xt(On.r * 255, 0, 255)) * 65536 + Math.round(xt(On.g * 255, 0, 255)) * 256 + Math.round(xt(On.b * 255, 0, 255));
    }
    getHexString(e = Dn) {
      return ("000000" + this.getHex(e).toString(16)).slice(-6);
    }
    getHSL(e, t = It.workingColorSpace) {
      It.fromWorkingColorSpace(On.copy(this), t);
      const n = On.r, i = On.g, r = On.b, o = Math.max(n, i, r), a = Math.min(n, i, r);
      let l, c;
      const h = (a + o) / 2;
      if (a === o) l = 0, c = 0;
      else {
        const f = o - a;
        switch (c = h <= 0.5 ? f / (o + a) : f / (2 - o - a), o) {
          case n:
            l = (i - r) / f + (i < r ? 6 : 0);
            break;
          case i:
            l = (r - n) / f + 2;
            break;
          case r:
            l = (n - i) / f + 4;
            break;
        }
        l /= 6;
      }
      return e.h = l, e.s = c, e.l = h, e;
    }
    getRGB(e, t = It.workingColorSpace) {
      return It.fromWorkingColorSpace(On.copy(this), t), e.r = On.r, e.g = On.g, e.b = On.b, e;
    }
    getStyle(e = Dn) {
      It.fromWorkingColorSpace(On.copy(this), e);
      const t = On.r, n = On.g, i = On.b;
      return e !== Dn ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`;
    }
    offsetHSL(e, t, n) {
      return this.getHSL(zr), this.setHSL(zr.h + e, zr.s + t, zr.l + n);
    }
    add(e) {
      return this.r += e.r, this.g += e.g, this.b += e.b, this;
    }
    addColors(e, t) {
      return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
    }
    addScalar(e) {
      return this.r += e, this.g += e, this.b += e, this;
    }
    sub(e) {
      return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
    }
    multiply(e) {
      return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
    }
    multiplyScalar(e) {
      return this.r *= e, this.g *= e, this.b *= e, this;
    }
    lerp(e, t) {
      return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
    }
    lerpColors(e, t, n) {
      return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
    }
    lerpHSL(e, t) {
      this.getHSL(zr), e.getHSL(Il);
      const n = ka(zr.h, Il.h, t), i = ka(zr.s, Il.s, t), r = ka(zr.l, Il.l, t);
      return this.setHSL(n, i, r), this;
    }
    setFromVector3(e) {
      return this.r = e.x, this.g = e.y, this.b = e.z, this;
    }
    applyMatrix3(e) {
      const t = this.r, n = this.g, i = this.b, r = e.elements;
      return this.r = r[0] * t + r[3] * n + r[6] * i, this.g = r[1] * t + r[4] * n + r[7] * i, this.b = r[2] * t + r[5] * n + r[8] * i, this;
    }
    equals(e) {
      return e.r === this.r && e.g === this.g && e.b === this.b;
    }
    fromArray(e, t = 0) {
      return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
    }
    toArray(e = [], t = 0) {
      return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
    }
    fromBufferAttribute(e, t) {
      return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
    }
    toJSON() {
      return this.getHex();
    }
    *[Symbol.iterator]() {
      yield this.r, yield this.g, yield this.b;
    }
  }
  const On = new it();
  it.NAMES = $m;
  let Fv = 0;
  class ji extends qo {
    constructor() {
      super(), this.isMaterial = true, Object.defineProperty(this, "id", {
        value: Fv++
      }), this.uuid = wi(), this.name = "", this.type = "Material", this.blending = yo, this.side = Er, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.alphaHash = false, this.blendSrc = oh, this.blendDst = ah, this.blendEquation = Ms, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new it(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Ao, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = Id, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = js, this.stencilZFail = js, this.stencilZPass = js, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.forceSinglePass = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0;
    }
    get alphaTest() {
      return this._alphaTest;
    }
    set alphaTest(e) {
      this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
    }
    onBeforeRender() {
    }
    onBeforeCompile() {
    }
    customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
    setValues(e) {
      if (e !== void 0) for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
          continue;
        }
        i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n;
      }
    }
    toJSON(e) {
      const t = e === void 0 || typeof e == "string";
      t && (e = {
        textures: {},
        images: {}
      });
      const n = {
        metadata: {
          version: 4.6,
          type: "Material",
          generator: "Material.toJSON"
        }
      };
      n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (n.dispersion = this.dispersion), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== yo && (n.blending = this.blending), this.side !== Er && (n.side = this.side), this.vertexColors === true && (n.vertexColors = true), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === true && (n.transparent = true), this.blendSrc !== oh && (n.blendSrc = this.blendSrc), this.blendDst !== ah && (n.blendDst = this.blendDst), this.blendEquation !== Ms && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== Ao && (n.depthFunc = this.depthFunc), this.depthTest === false && (n.depthTest = this.depthTest), this.depthWrite === false && (n.depthWrite = this.depthWrite), this.colorWrite === false && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== Id && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== js && (n.stencilFail = this.stencilFail), this.stencilZFail !== js && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== js && (n.stencilZPass = this.stencilZPass), this.stencilWrite === true && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === true && (n.polygonOffset = true), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === true && (n.dithering = true), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === true && (n.alphaHash = true), this.alphaToCoverage === true && (n.alphaToCoverage = true), this.premultipliedAlpha === true && (n.premultipliedAlpha = true), this.forceSinglePass === true && (n.forceSinglePass = true), this.wireframe === true && (n.wireframe = true), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === true && (n.flatShading = true), this.visible === false && (n.visible = false), this.toneMapped === false && (n.toneMapped = false), this.fog === false && (n.fog = false), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
      function i(r) {
        const o = [];
        for (const a in r) {
          const l = r[a];
          delete l.metadata, o.push(l);
        }
        return o;
      }
      if (t) {
        const r = i(e.textures), o = i(e.images);
        r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o);
      }
      return n;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
      const t = e.clippingPlanes;
      let n = null;
      if (t !== null) {
        const i = t.length;
        n = new Array(i);
        for (let r = 0; r !== i; ++r) n[r] = t[r].clone();
      }
      return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
    }
    dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }
    set needsUpdate(e) {
      e === true && this.version++;
    }
    onBuild() {
      console.warn("Material: onBuild() has been removed.");
    }
  }
  class qi extends ji {
    constructor(e) {
      super(), this.isMeshBasicMaterial = true, this.type = "MeshBasicMaterial", this.color = new it(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Zi(), this.combine = Dm, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
    }
  }
  const pn = new V(), Nl = new Se();
  let kv = 0;
  class jn {
    constructor(e, t, n = false) {
      if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
      this.isBufferAttribute = true, Object.defineProperty(this, "id", {
        value: kv++
      }), this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n, this.usage = Wh, this.updateRanges = [], this.gpuType = Ni, this.version = 0;
    }
    onUploadCallback() {
    }
    set needsUpdate(e) {
      e === true && this.version++;
    }
    setUsage(e) {
      return this.usage = e, this;
    }
    addUpdateRange(e, t) {
      this.updateRanges.push({
        start: e,
        count: t
      });
    }
    clearUpdateRanges() {
      this.updateRanges.length = 0;
    }
    copy(e) {
      return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
    }
    copyAt(e, t, n) {
      e *= this.itemSize, n *= t.itemSize;
      for (let i = 0, r = this.itemSize; i < r; i++) this.array[e + i] = t.array[n + i];
      return this;
    }
    copyArray(e) {
      return this.array.set(e), this;
    }
    applyMatrix3(e) {
      if (this.itemSize === 2) for (let t = 0, n = this.count; t < n; t++) Nl.fromBufferAttribute(this, t), Nl.applyMatrix3(e), this.setXY(t, Nl.x, Nl.y);
      else if (this.itemSize === 3) for (let t = 0, n = this.count; t < n; t++) pn.fromBufferAttribute(this, t), pn.applyMatrix3(e), this.setXYZ(t, pn.x, pn.y, pn.z);
      return this;
    }
    applyMatrix4(e) {
      for (let t = 0, n = this.count; t < n; t++) pn.fromBufferAttribute(this, t), pn.applyMatrix4(e), this.setXYZ(t, pn.x, pn.y, pn.z);
      return this;
    }
    applyNormalMatrix(e) {
      for (let t = 0, n = this.count; t < n; t++) pn.fromBufferAttribute(this, t), pn.applyNormalMatrix(e), this.setXYZ(t, pn.x, pn.y, pn.z);
      return this;
    }
    transformDirection(e) {
      for (let t = 0, n = this.count; t < n; t++) pn.fromBufferAttribute(this, t), pn.transformDirection(e), this.setXYZ(t, pn.x, pn.y, pn.z);
      return this;
    }
    set(e, t = 0) {
      return this.array.set(e, t), this;
    }
    getComponent(e, t) {
      let n = this.array[e * this.itemSize + t];
      return this.normalized && (n = Li(n, this.array)), n;
    }
    setComponent(e, t, n) {
      return this.normalized && (n = qt(n, this.array)), this.array[e * this.itemSize + t] = n, this;
    }
    getX(e) {
      let t = this.array[e * this.itemSize];
      return this.normalized && (t = Li(t, this.array)), t;
    }
    setX(e, t) {
      return this.normalized && (t = qt(t, this.array)), this.array[e * this.itemSize] = t, this;
    }
    getY(e) {
      let t = this.array[e * this.itemSize + 1];
      return this.normalized && (t = Li(t, this.array)), t;
    }
    setY(e, t) {
      return this.normalized && (t = qt(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
    }
    getZ(e) {
      let t = this.array[e * this.itemSize + 2];
      return this.normalized && (t = Li(t, this.array)), t;
    }
    setZ(e, t) {
      return this.normalized && (t = qt(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
    }
    getW(e) {
      let t = this.array[e * this.itemSize + 3];
      return this.normalized && (t = Li(t, this.array)), t;
    }
    setW(e, t) {
      return this.normalized && (t = qt(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
    }
    setXY(e, t, n) {
      return e *= this.itemSize, this.normalized && (t = qt(t, this.array), n = qt(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this;
    }
    setXYZ(e, t, n, i) {
      return e *= this.itemSize, this.normalized && (t = qt(t, this.array), n = qt(n, this.array), i = qt(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this;
    }
    setXYZW(e, t, n, i, r) {
      return e *= this.itemSize, this.normalized && (t = qt(t, this.array), n = qt(n, this.array), i = qt(i, this.array), r = qt(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this;
    }
    onUpload(e) {
      return this.onUploadCallback = e, this;
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
      const e = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.from(this.array),
        normalized: this.normalized
      };
      return this.name !== "" && (e.name = this.name), this.usage !== Wh && (e.usage = this.usage), e;
    }
  }
  class Km extends jn {
    constructor(e, t, n) {
      super(new Uint16Array(e), t, n);
    }
  }
  class Zm extends jn {
    constructor(e, t, n) {
      super(new Uint32Array(e), t, n);
    }
  }
  class Ln extends jn {
    constructor(e, t, n) {
      super(new Float32Array(e), t, n);
    }
  }
  let Bv = 0;
  const xi = new pt(), wu = new on(), ro = new V(), ai = new Rr(), Sa = new Rr(), Cn = new V();
  class si extends qo {
    constructor() {
      super(), this.isBufferGeometry = true, Object.defineProperty(this, "id", {
        value: Bv++
      }), this.uuid = wi(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
        start: 0,
        count: 1 / 0
      }, this.userData = {};
    }
    getIndex() {
      return this.index;
    }
    setIndex(e) {
      return Array.isArray(e) ? this.index = new (qm(e) ? Zm : Km)(e, 1) : this.index = e, this;
    }
    setIndirect(e) {
      return this.indirect = e, this;
    }
    getIndirect() {
      return this.indirect;
    }
    getAttribute(e) {
      return this.attributes[e];
    }
    setAttribute(e, t) {
      return this.attributes[e] = t, this;
    }
    deleteAttribute(e) {
      return delete this.attributes[e], this;
    }
    hasAttribute(e) {
      return this.attributes[e] !== void 0;
    }
    addGroup(e, t, n = 0) {
      this.groups.push({
        start: e,
        count: t,
        materialIndex: n
      });
    }
    clearGroups() {
      this.groups = [];
    }
    setDrawRange(e, t) {
      this.drawRange.start = e, this.drawRange.count = t;
    }
    applyMatrix4(e) {
      const t = this.attributes.position;
      t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = true);
      const n = this.attributes.normal;
      if (n !== void 0) {
        const r = new mt().getNormalMatrix(e);
        n.applyNormalMatrix(r), n.needsUpdate = true;
      }
      const i = this.attributes.tangent;
      return i !== void 0 && (i.transformDirection(e), i.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
    }
    applyQuaternion(e) {
      return xi.makeRotationFromQuaternion(e), this.applyMatrix4(xi), this;
    }
    rotateX(e) {
      return xi.makeRotationX(e), this.applyMatrix4(xi), this;
    }
    rotateY(e) {
      return xi.makeRotationY(e), this.applyMatrix4(xi), this;
    }
    rotateZ(e) {
      return xi.makeRotationZ(e), this.applyMatrix4(xi), this;
    }
    translate(e, t, n) {
      return xi.makeTranslation(e, t, n), this.applyMatrix4(xi), this;
    }
    scale(e, t, n) {
      return xi.makeScale(e, t, n), this.applyMatrix4(xi), this;
    }
    lookAt(e) {
      return wu.lookAt(e), wu.updateMatrix(), this.applyMatrix4(wu.matrix), this;
    }
    center() {
      return this.computeBoundingBox(), this.boundingBox.getCenter(ro).negate(), this.translate(ro.x, ro.y, ro.z), this;
    }
    setFromPoints(e) {
      const t = this.getAttribute("position");
      if (t === void 0) {
        const n = [];
        for (let i = 0, r = e.length; i < r; i++) {
          const o = e[i];
          n.push(o.x, o.y, o.z || 0);
        }
        this.setAttribute("position", new Ln(n, 3));
      } else {
        const n = Math.min(e.length, t.count);
        for (let i = 0; i < n; i++) {
          const r = e[i];
          t.setXYZ(i, r.x, r.y, r.z || 0);
        }
        e.length > t.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), t.needsUpdate = true;
      }
      return this;
    }
    computeBoundingBox() {
      this.boundingBox === null && (this.boundingBox = new Rr());
      const e = this.attributes.position, t = this.morphAttributes.position;
      if (e && e.isGLBufferAttribute) {
        console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new V(-1 / 0, -1 / 0, -1 / 0), new V(1 / 0, 1 / 0, 1 / 0));
        return;
      }
      if (e !== void 0) {
        if (this.boundingBox.setFromBufferAttribute(e), t) for (let n = 0, i = t.length; n < i; n++) {
          const r = t[n];
          ai.setFromBufferAttribute(r), this.morphTargetsRelative ? (Cn.addVectors(this.boundingBox.min, ai.min), this.boundingBox.expandByPoint(Cn), Cn.addVectors(this.boundingBox.max, ai.max), this.boundingBox.expandByPoint(Cn)) : (this.boundingBox.expandByPoint(ai.min), this.boundingBox.expandByPoint(ai.max));
        }
      } else this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
    computeBoundingSphere() {
      this.boundingSphere === null && (this.boundingSphere = new Qi());
      const e = this.attributes.position, t = this.morphAttributes.position;
      if (e && e.isGLBufferAttribute) {
        console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new V(), 1 / 0);
        return;
      }
      if (e) {
        const n = this.boundingSphere.center;
        if (ai.setFromBufferAttribute(e), t) for (let r = 0, o = t.length; r < o; r++) {
          const a = t[r];
          Sa.setFromBufferAttribute(a), this.morphTargetsRelative ? (Cn.addVectors(ai.min, Sa.min), ai.expandByPoint(Cn), Cn.addVectors(ai.max, Sa.max), ai.expandByPoint(Cn)) : (ai.expandByPoint(Sa.min), ai.expandByPoint(Sa.max));
        }
        ai.getCenter(n);
        let i = 0;
        for (let r = 0, o = e.count; r < o; r++) Cn.fromBufferAttribute(e, r), i = Math.max(i, n.distanceToSquared(Cn));
        if (t) for (let r = 0, o = t.length; r < o; r++) {
          const a = t[r], l = this.morphTargetsRelative;
          for (let c = 0, h = a.count; c < h; c++) Cn.fromBufferAttribute(a, c), l && (ro.fromBufferAttribute(e, c), Cn.add(ro)), i = Math.max(i, n.distanceToSquared(Cn));
        }
        this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
    computeTangents() {
      const e = this.index, t = this.attributes;
      if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
        console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
        return;
      }
      const n = t.position, i = t.normal, r = t.uv;
      this.hasAttribute("tangent") === false && this.setAttribute("tangent", new jn(new Float32Array(4 * n.count), 4));
      const o = this.getAttribute("tangent"), a = [], l = [];
      for (let N = 0; N < n.count; N++) a[N] = new V(), l[N] = new V();
      const c = new V(), h = new V(), f = new V(), m = new Se(), _ = new Se(), y = new Se(), g = new V(), x = new V();
      function v(N, w, D) {
        c.fromBufferAttribute(n, N), h.fromBufferAttribute(n, w), f.fromBufferAttribute(n, D), m.fromBufferAttribute(r, N), _.fromBufferAttribute(r, w), y.fromBufferAttribute(r, D), h.sub(c), f.sub(c), _.sub(m), y.sub(m);
        const B = 1 / (_.x * y.y - y.x * _.y);
        isFinite(B) && (g.copy(h).multiplyScalar(y.y).addScaledVector(f, -_.y).multiplyScalar(B), x.copy(f).multiplyScalar(_.x).addScaledVector(h, -y.x).multiplyScalar(B), a[N].add(g), a[w].add(g), a[D].add(g), l[N].add(x), l[w].add(x), l[D].add(x));
      }
      let E = this.groups;
      E.length === 0 && (E = [
        {
          start: 0,
          count: e.count
        }
      ]);
      for (let N = 0, w = E.length; N < w; ++N) {
        const D = E[N], B = D.start, Z = D.count;
        for (let G = B, Q = B + Z; G < Q; G += 3) v(e.getX(G + 0), e.getX(G + 1), e.getX(G + 2));
      }
      const T = new V(), M = new V(), P = new V(), R = new V();
      function d(N) {
        P.fromBufferAttribute(i, N), R.copy(P);
        const w = a[N];
        T.copy(w), T.sub(P.multiplyScalar(P.dot(w))).normalize(), M.crossVectors(R, w);
        const B = M.dot(l[N]) < 0 ? -1 : 1;
        o.setXYZW(N, T.x, T.y, T.z, B);
      }
      for (let N = 0, w = E.length; N < w; ++N) {
        const D = E[N], B = D.start, Z = D.count;
        for (let G = B, Q = B + Z; G < Q; G += 3) d(e.getX(G + 0)), d(e.getX(G + 1)), d(e.getX(G + 2));
      }
    }
    computeVertexNormals() {
      const e = this.index, t = this.getAttribute("position");
      if (t !== void 0) {
        let n = this.getAttribute("normal");
        if (n === void 0) n = new jn(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
        else for (let m = 0, _ = n.count; m < _; m++) n.setXYZ(m, 0, 0, 0);
        const i = new V(), r = new V(), o = new V(), a = new V(), l = new V(), c = new V(), h = new V(), f = new V();
        if (e) for (let m = 0, _ = e.count; m < _; m += 3) {
          const y = e.getX(m + 0), g = e.getX(m + 1), x = e.getX(m + 2);
          i.fromBufferAttribute(t, y), r.fromBufferAttribute(t, g), o.fromBufferAttribute(t, x), h.subVectors(o, r), f.subVectors(i, r), h.cross(f), a.fromBufferAttribute(n, y), l.fromBufferAttribute(n, g), c.fromBufferAttribute(n, x), a.add(h), l.add(h), c.add(h), n.setXYZ(y, a.x, a.y, a.z), n.setXYZ(g, l.x, l.y, l.z), n.setXYZ(x, c.x, c.y, c.z);
        }
        else for (let m = 0, _ = t.count; m < _; m += 3) i.fromBufferAttribute(t, m + 0), r.fromBufferAttribute(t, m + 1), o.fromBufferAttribute(t, m + 2), h.subVectors(o, r), f.subVectors(i, r), h.cross(f), n.setXYZ(m + 0, h.x, h.y, h.z), n.setXYZ(m + 1, h.x, h.y, h.z), n.setXYZ(m + 2, h.x, h.y, h.z);
        this.normalizeNormals(), n.needsUpdate = true;
      }
    }
    normalizeNormals() {
      const e = this.attributes.normal;
      for (let t = 0, n = e.count; t < n; t++) Cn.fromBufferAttribute(e, t), Cn.normalize(), e.setXYZ(t, Cn.x, Cn.y, Cn.z);
    }
    toNonIndexed() {
      function e(a, l) {
        const c = a.array, h = a.itemSize, f = a.normalized, m = new c.constructor(l.length * h);
        let _ = 0, y = 0;
        for (let g = 0, x = l.length; g < x; g++) {
          a.isInterleavedBufferAttribute ? _ = l[g] * a.data.stride + a.offset : _ = l[g] * h;
          for (let v = 0; v < h; v++) m[y++] = c[_++];
        }
        return new jn(m, h, f);
      }
      if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
      const t = new si(), n = this.index.array, i = this.attributes;
      for (const a in i) {
        const l = i[a], c = e(l, n);
        t.setAttribute(a, c);
      }
      const r = this.morphAttributes;
      for (const a in r) {
        const l = [], c = r[a];
        for (let h = 0, f = c.length; h < f; h++) {
          const m = c[h], _ = e(m, n);
          l.push(_);
        }
        t.morphAttributes[a] = l;
      }
      t.morphTargetsRelative = this.morphTargetsRelative;
      const o = this.groups;
      for (let a = 0, l = o.length; a < l; a++) {
        const c = o[a];
        t.addGroup(c.start, c.count, c.materialIndex);
      }
      return t;
    }
    toJSON() {
      const e = {
        metadata: {
          version: 4.6,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON"
        }
      };
      if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
        const l = this.parameters;
        for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
        return e;
      }
      e.data = {
        attributes: {}
      };
      const t = this.index;
      t !== null && (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array)
      });
      const n = this.attributes;
      for (const l in n) {
        const c = n[l];
        e.data.attributes[l] = c.toJSON(e.data);
      }
      const i = {};
      let r = false;
      for (const l in this.morphAttributes) {
        const c = this.morphAttributes[l], h = [];
        for (let f = 0, m = c.length; f < m; f++) {
          const _ = c[f];
          h.push(_.toJSON(e.data));
        }
        h.length > 0 && (i[l] = h, r = true);
      }
      r && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
      const o = this.groups;
      o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
      const a = this.boundingSphere;
      return a !== null && (e.data.boundingSphere = {
        center: a.center.toArray(),
        radius: a.radius
      }), e;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
      const t = {};
      this.name = e.name;
      const n = e.index;
      n !== null && this.setIndex(n.clone(t));
      const i = e.attributes;
      for (const c in i) {
        const h = i[c];
        this.setAttribute(c, h.clone(t));
      }
      const r = e.morphAttributes;
      for (const c in r) {
        const h = [], f = r[c];
        for (let m = 0, _ = f.length; m < _; m++) h.push(f[m].clone(t));
        this.morphAttributes[c] = h;
      }
      this.morphTargetsRelative = e.morphTargetsRelative;
      const o = e.groups;
      for (let c = 0, h = o.length; c < h; c++) {
        const f = o[c];
        this.addGroup(f.start, f.count, f.materialIndex);
      }
      const a = e.boundingBox;
      a !== null && (this.boundingBox = a.clone());
      const l = e.boundingSphere;
      return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
    }
    dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }
  }
  const jd = new pt(), ds = new ul(), Ul = new Qi(), $d = new V(), Ol = new V(), Fl = new V(), kl = new V(), Au = new V(), Bl = new V(), Kd = new V(), zl = new V();
  class hn extends on {
    constructor(e = new si(), t = new qi()) {
      super(), this.isMesh = true, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
    }
    copy(e, t) {
      return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
    }
    updateMorphTargets() {
      const t = this.geometry.morphAttributes, n = Object.keys(t);
      if (n.length > 0) {
        const i = t[n[0]];
        if (i !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let r = 0, o = i.length; r < o; r++) {
            const a = i[r].name || String(r);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
          }
        }
      }
    }
    getVertexPosition(e, t) {
      const n = this.geometry, i = n.attributes.position, r = n.morphAttributes.position, o = n.morphTargetsRelative;
      t.fromBufferAttribute(i, e);
      const a = this.morphTargetInfluences;
      if (r && a) {
        Bl.set(0, 0, 0);
        for (let l = 0, c = r.length; l < c; l++) {
          const h = a[l], f = r[l];
          h !== 0 && (Au.fromBufferAttribute(f, e), o ? Bl.addScaledVector(Au, h) : Bl.addScaledVector(Au.sub(t), h));
        }
        t.add(Bl);
      }
      return t;
    }
    raycast(e, t) {
      const n = this.geometry, i = this.material, r = this.matrixWorld;
      i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), Ul.copy(n.boundingSphere), Ul.applyMatrix4(r), ds.copy(e.ray).recast(e.near), !(Ul.containsPoint(ds.origin) === false && (ds.intersectSphere(Ul, $d) === null || ds.origin.distanceToSquared($d) > (e.far - e.near) ** 2)) && (jd.copy(r).invert(), ds.copy(e.ray).applyMatrix4(jd), !(n.boundingBox !== null && ds.intersectsBox(n.boundingBox) === false) && this._computeIntersections(e, t, ds)));
    }
    _computeIntersections(e, t, n) {
      let i;
      const r = this.geometry, o = this.material, a = r.index, l = r.attributes.position, c = r.attributes.uv, h = r.attributes.uv1, f = r.attributes.normal, m = r.groups, _ = r.drawRange;
      if (a !== null) if (Array.isArray(o)) for (let y = 0, g = m.length; y < g; y++) {
        const x = m[y], v = o[x.materialIndex], E = Math.max(x.start, _.start), T = Math.min(a.count, Math.min(x.start + x.count, _.start + _.count));
        for (let M = E, P = T; M < P; M += 3) {
          const R = a.getX(M), d = a.getX(M + 1), N = a.getX(M + 2);
          i = Hl(this, v, e, n, c, h, f, R, d, N), i && (i.faceIndex = Math.floor(M / 3), i.face.materialIndex = x.materialIndex, t.push(i));
        }
      }
      else {
        const y = Math.max(0, _.start), g = Math.min(a.count, _.start + _.count);
        for (let x = y, v = g; x < v; x += 3) {
          const E = a.getX(x), T = a.getX(x + 1), M = a.getX(x + 2);
          i = Hl(this, o, e, n, c, h, f, E, T, M), i && (i.faceIndex = Math.floor(x / 3), t.push(i));
        }
      }
      else if (l !== void 0) if (Array.isArray(o)) for (let y = 0, g = m.length; y < g; y++) {
        const x = m[y], v = o[x.materialIndex], E = Math.max(x.start, _.start), T = Math.min(l.count, Math.min(x.start + x.count, _.start + _.count));
        for (let M = E, P = T; M < P; M += 3) {
          const R = M, d = M + 1, N = M + 2;
          i = Hl(this, v, e, n, c, h, f, R, d, N), i && (i.faceIndex = Math.floor(M / 3), i.face.materialIndex = x.materialIndex, t.push(i));
        }
      }
      else {
        const y = Math.max(0, _.start), g = Math.min(l.count, _.start + _.count);
        for (let x = y, v = g; x < v; x += 3) {
          const E = x, T = x + 1, M = x + 2;
          i = Hl(this, o, e, n, c, h, f, E, T, M), i && (i.faceIndex = Math.floor(x / 3), t.push(i));
        }
      }
    }
  }
  function zv(s, e, t, n, i, r, o, a) {
    let l;
    if (e.side === Qn ? l = n.intersectTriangle(o, r, i, true, a) : l = n.intersectTriangle(i, r, o, e.side === Er, a), l === null) return null;
    zl.copy(a), zl.applyMatrix4(s.matrixWorld);
    const c = t.ray.origin.distanceTo(zl);
    return c < t.near || c > t.far ? null : {
      distance: c,
      point: zl.clone(),
      object: s
    };
  }
  function Hl(s, e, t, n, i, r, o, a, l, c) {
    s.getVertexPosition(a, Ol), s.getVertexPosition(l, Fl), s.getVertexPosition(c, kl);
    const h = zv(s, e, t, n, Ol, Fl, kl, Kd);
    if (h) {
      const f = new V();
      Ii.getBarycoord(Kd, Ol, Fl, kl, f), i && (h.uv = Ii.getInterpolatedAttribute(i, a, l, c, f, new Se())), r && (h.uv1 = Ii.getInterpolatedAttribute(r, a, l, c, f, new Se())), o && (h.normal = Ii.getInterpolatedAttribute(o, a, l, c, f, new V()), h.normal.dot(n.direction) > 0 && h.normal.multiplyScalar(-1));
      const m = {
        a,
        b: l,
        c,
        normal: new V(),
        materialIndex: 0
      };
      Ii.getNormal(Ol, Fl, kl, m.normal), h.face = m, h.barycoord = f;
    }
    return h;
  }
  class ks extends si {
    constructor(e = 1, t = 1, n = 1, i = 1, r = 1, o = 1) {
      super(), this.type = "BoxGeometry", this.parameters = {
        width: e,
        height: t,
        depth: n,
        widthSegments: i,
        heightSegments: r,
        depthSegments: o
      };
      const a = this;
      i = Math.floor(i), r = Math.floor(r), o = Math.floor(o);
      const l = [], c = [], h = [], f = [];
      let m = 0, _ = 0;
      y("z", "y", "x", -1, -1, n, t, e, o, r, 0), y("z", "y", "x", 1, -1, n, t, -e, o, r, 1), y("x", "z", "y", 1, 1, e, n, t, i, o, 2), y("x", "z", "y", 1, -1, e, n, -t, i, o, 3), y("x", "y", "z", 1, -1, e, t, n, i, r, 4), y("x", "y", "z", -1, -1, e, t, -n, i, r, 5), this.setIndex(l), this.setAttribute("position", new Ln(c, 3)), this.setAttribute("normal", new Ln(h, 3)), this.setAttribute("uv", new Ln(f, 2));
      function y(g, x, v, E, T, M, P, R, d, N, w) {
        const D = M / d, B = P / N, Z = M / 2, G = P / 2, Q = R / 2, ue = d + 1, te = N + 1;
        let he = 0, ie = 0;
        const Me = new V();
        for (let Ce = 0; Ce < te; Ce++) {
          const Le = Ce * B - G;
          for (let Je = 0; Je < ue; Je++) {
            const dt = Je * D - Z;
            Me[g] = dt * E, Me[x] = Le * T, Me[v] = Q, c.push(Me.x, Me.y, Me.z), Me[g] = 0, Me[x] = 0, Me[v] = R > 0 ? 1 : -1, h.push(Me.x, Me.y, Me.z), f.push(Je / d), f.push(1 - Ce / N), he += 1;
          }
        }
        for (let Ce = 0; Ce < N; Ce++) for (let Le = 0; Le < d; Le++) {
          const Je = m + Le + ue * Ce, dt = m + Le + ue * (Ce + 1), ce = m + (Le + 1) + ue * (Ce + 1), ve = m + (Le + 1) + ue * Ce;
          l.push(Je, dt, ve), l.push(dt, ce, ve), ie += 6;
        }
        a.addGroup(_, ie, w), _ += ie, m += he;
      }
    }
    copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
    }
    static fromJSON(e) {
      return new ks(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
    }
  }
  function No(s) {
    const e = {};
    for (const t in s) {
      e[t] = {};
      for (const n in s[t]) {
        const i = s[t][n];
        i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][n] = null) : e[t][n] = i.clone() : Array.isArray(i) ? e[t][n] = i.slice() : e[t][n] = i;
      }
    }
    return e;
  }
  function Wn(s) {
    const e = {};
    for (let t = 0; t < s.length; t++) {
      const n = No(s[t]);
      for (const i in n) e[i] = n[i];
    }
    return e;
  }
  function Hv(s) {
    const e = [];
    for (let t = 0; t < s.length; t++) e.push(s[t].clone());
    return e;
  }
  function Jm(s) {
    const e = s.getRenderTarget();
    return e === null ? s.outputColorSpace : e.isXRRenderTarget === true ? e.texture.colorSpace : It.workingColorSpace;
  }
  const Tc = {
    clone: No,
    merge: Wn
  };
  var Vv = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, Gv = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
  class kn extends ji {
    constructor(e) {
      super(), this.isShaderMaterial = true, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = Vv, this.fragmentShader = Gv, this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.forceSinglePass = true, this.extensions = {
        clipCullDistance: false,
        multiDraw: false
      }, this.defaultAttributeValues = {
        color: [
          1,
          1,
          1
        ],
        uv: [
          0,
          0
        ],
        uv1: [
          0,
          0
        ]
      }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, e !== void 0 && this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = No(e.uniforms), this.uniformsGroups = Hv(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
    }
    toJSON(e) {
      const t = super.toJSON(e);
      t.glslVersion = this.glslVersion, t.uniforms = {};
      for (const i in this.uniforms) {
        const o = this.uniforms[i].value;
        o && o.isTexture ? t.uniforms[i] = {
          type: "t",
          value: o.toJSON(e).uuid
        } : o && o.isColor ? t.uniforms[i] = {
          type: "c",
          value: o.getHex()
        } : o && o.isVector2 ? t.uniforms[i] = {
          type: "v2",
          value: o.toArray()
        } : o && o.isVector3 ? t.uniforms[i] = {
          type: "v3",
          value: o.toArray()
        } : o && o.isVector4 ? t.uniforms[i] = {
          type: "v4",
          value: o.toArray()
        } : o && o.isMatrix3 ? t.uniforms[i] = {
          type: "m3",
          value: o.toArray()
        } : o && o.isMatrix4 ? t.uniforms[i] = {
          type: "m4",
          value: o.toArray()
        } : t.uniforms[i] = {
          value: o
        };
      }
      Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
      const n = {};
      for (const i in this.extensions) this.extensions[i] === true && (n[i] = true);
      return Object.keys(n).length > 0 && (t.extensions = n), t;
    }
  }
  class Qm extends on {
    constructor() {
      super(), this.isCamera = true, this.type = "Camera", this.matrixWorldInverse = new pt(), this.projectionMatrix = new pt(), this.projectionMatrixInverse = new pt(), this.coordinateSystem = br;
    }
    copy(e, t) {
      return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
    }
    getWorldDirection(e) {
      return super.getWorldDirection(e).negate();
    }
    updateMatrixWorld(e) {
      super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(e, t) {
      super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const Hr = new V(), Zd = new Se(), Jd = new Se();
  class Xn extends Qm {
    constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
      super(), this.isPerspectiveCamera = true, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
    }
    copy(e, t) {
      return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
    }
    setFocalLength(e) {
      const t = 0.5 * this.getFilmHeight() / e;
      this.fov = Io * 2 * Math.atan(t), this.updateProjectionMatrix();
    }
    getFocalLength() {
      const e = Math.tan(Fa * 0.5 * this.fov);
      return 0.5 * this.getFilmHeight() / e;
    }
    getEffectiveFOV() {
      return Io * 2 * Math.atan(Math.tan(Fa * 0.5 * this.fov) / this.zoom);
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    getViewBounds(e, t, n) {
      Hr.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), t.set(Hr.x, Hr.y).multiplyScalar(-e / Hr.z), Hr.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(Hr.x, Hr.y).multiplyScalar(-e / Hr.z);
    }
    getViewSize(e, t) {
      return this.getViewBounds(e, Zd, Jd), t.subVectors(Jd, Zd);
    }
    setViewOffset(e, t, n, i, r, o) {
      this.aspect = e / t, this.view === null && (this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }), this.view.enabled = true, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix();
    }
    clearViewOffset() {
      this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const e = this.near;
      let t = e * Math.tan(Fa * 0.5 * this.fov) / this.zoom, n = 2 * t, i = this.aspect * n, r = -0.5 * i;
      const o = this.view;
      if (this.view !== null && this.view.enabled) {
        const l = o.fullWidth, c = o.fullHeight;
        r += o.offsetX * i / l, t -= o.offsetY * n / c, i *= o.width / l, n *= o.height / c;
      }
      const a = this.filmOffset;
      a !== 0 && (r += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(e) {
      const t = super.toJSON(e);
      return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
    }
  }
  const so = -90, oo = 1;
  class Wv extends on {
    constructor(e, t, n) {
      super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
      const i = new Xn(so, oo, e, t);
      i.layers = this.layers, this.add(i);
      const r = new Xn(so, oo, e, t);
      r.layers = this.layers, this.add(r);
      const o = new Xn(so, oo, e, t);
      o.layers = this.layers, this.add(o);
      const a = new Xn(so, oo, e, t);
      a.layers = this.layers, this.add(a);
      const l = new Xn(so, oo, e, t);
      l.layers = this.layers, this.add(l);
      const c = new Xn(so, oo, e, t);
      c.layers = this.layers, this.add(c);
    }
    updateCoordinateSystem() {
      const e = this.coordinateSystem, t = this.children.concat(), [n, i, r, o, a, l] = t;
      for (const c of t) this.remove(c);
      if (e === br) n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
      else if (e === Mc) n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
      else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
      for (const c of t) this.add(c), c.updateMatrixWorld();
    }
    update(e, t) {
      this.parent === null && this.updateMatrixWorld();
      const { renderTarget: n, activeMipmapLevel: i } = this;
      this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
      const [r, o, a, l, c, h] = this.children, f = e.getRenderTarget(), m = e.getActiveCubeFace(), _ = e.getActiveMipmapLevel(), y = e.xr.enabled;
      e.xr.enabled = false;
      const g = n.texture.generateMipmaps;
      n.texture.generateMipmaps = false, e.setRenderTarget(n, 0, i), e.render(t, r), e.setRenderTarget(n, 1, i), e.render(t, o), e.setRenderTarget(n, 2, i), e.render(t, a), e.setRenderTarget(n, 3, i), e.render(t, l), e.setRenderTarget(n, 4, i), e.render(t, c), n.texture.generateMipmaps = g, e.setRenderTarget(n, 5, i), e.render(t, h), e.setRenderTarget(f, m, _), e.xr.enabled = y, n.texture.needsPMREMUpdate = true;
    }
  }
  class eg extends Mn {
    constructor(e, t, n, i, r, o, a, l, c, h) {
      e = e !== void 0 ? e : [], t = t !== void 0 ? t : Co, super(e, t, n, i, r, o, a, l, c, h), this.isCubeTexture = true, this.flipY = false;
    }
    get images() {
      return this.image;
    }
    set images(e) {
      this.image = e;
    }
  }
  class Xv extends Ui {
    constructor(e = 1, t = {}) {
      super(e, e, t), this.isWebGLCubeRenderTarget = true;
      const n = {
        width: e,
        height: e,
        depth: 1
      }, i = [
        n,
        n,
        n,
        n,
        n,
        n
      ];
      this.texture = new eg(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : false, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : fi;
    }
    fromEquirectangularTexture(e, t) {
      this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
      const n = {
        uniforms: {
          tEquirect: {
            value: null
          }
        },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      }, i = new ks(5, 5, 5), r = new kn({
        name: "CubemapFromEquirect",
        uniforms: No(n.uniforms),
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        side: Qn,
        blending: Sr
      });
      r.uniforms.tEquirect.value = t;
      const o = new hn(i, r), a = t.minFilter;
      return t.minFilter === xr && (t.minFilter = fi), new Wv(1, 10, this).update(e, o), t.minFilter = a, o.geometry.dispose(), o.material.dispose(), this;
    }
    clear(e, t, n, i) {
      const r = e.getRenderTarget();
      for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, n, i);
      e.setRenderTarget(r);
    }
  }
  class jr extends on {
    constructor() {
      super(), this.isGroup = true, this.type = "Group";
    }
  }
  const qv = {
    type: "move"
  };
  class Cu {
    constructor() {
      this._targetRay = null, this._grip = null, this._hand = null;
    }
    getHandSpace() {
      return this._hand === null && (this._hand = new jr(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = {
        pinching: false
      }), this._hand;
    }
    getTargetRaySpace() {
      return this._targetRay === null && (this._targetRay = new jr(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new V(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new V()), this._targetRay;
    }
    getGripSpace() {
      return this._grip === null && (this._grip = new jr(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new V(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new V()), this._grip;
    }
    dispatchEvent(e) {
      return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
    }
    connect(e) {
      if (e && e.hand) {
        const t = this._hand;
        if (t) for (const n of e.hand.values()) this._getHandJoint(t, n);
      }
      return this.dispatchEvent({
        type: "connected",
        data: e
      }), this;
    }
    disconnect(e) {
      return this.dispatchEvent({
        type: "disconnected",
        data: e
      }), this._targetRay !== null && (this._targetRay.visible = false), this._grip !== null && (this._grip.visible = false), this._hand !== null && (this._hand.visible = false), this;
    }
    update(e, t, n) {
      let i = null, r = null, o = null;
      const a = this._targetRay, l = this._grip, c = this._hand;
      if (e && t.session.visibilityState !== "visible-blurred") {
        if (c && e.hand) {
          o = true;
          for (const g of e.hand.values()) {
            const x = t.getJointPose(g, n), v = this._getHandJoint(c, g);
            x !== null && (v.matrix.fromArray(x.transform.matrix), v.matrix.decompose(v.position, v.rotation, v.scale), v.matrixWorldNeedsUpdate = true, v.jointRadius = x.radius), v.visible = x !== null;
          }
          const h = c.joints["index-finger-tip"], f = c.joints["thumb-tip"], m = h.position.distanceTo(f.position), _ = 0.02, y = 5e-3;
          c.inputState.pinching && m > _ + y ? (c.inputState.pinching = false, this.dispatchEvent({
            type: "pinchend",
            handedness: e.handedness,
            target: this
          })) : !c.inputState.pinching && m <= _ - y && (c.inputState.pinching = true, this.dispatchEvent({
            type: "pinchstart",
            handedness: e.handedness,
            target: this
          }));
        } else l !== null && e.gripSpace && (r = t.getPose(e.gripSpace, n), r !== null && (l.matrix.fromArray(r.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = true, r.linearVelocity ? (l.hasLinearVelocity = true, l.linearVelocity.copy(r.linearVelocity)) : l.hasLinearVelocity = false, r.angularVelocity ? (l.hasAngularVelocity = true, l.angularVelocity.copy(r.angularVelocity)) : l.hasAngularVelocity = false));
        a !== null && (i = t.getPose(e.targetRaySpace, n), i === null && r !== null && (i = r), i !== null && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = true, i.linearVelocity ? (a.hasLinearVelocity = true, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = false, i.angularVelocity ? (a.hasAngularVelocity = true, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = false, this.dispatchEvent(qv)));
      }
      return a !== null && (a.visible = i !== null), l !== null && (l.visible = r !== null), c !== null && (c.visible = o !== null), this;
    }
    _getHandJoint(e, t) {
      if (e.joints[t.jointName] === void 0) {
        const n = new jr();
        n.matrixAutoUpdate = false, n.visible = false, e.joints[t.jointName] = n, e.add(n);
      }
      return e.joints[t.jointName];
    }
  }
  class Yv extends on {
    constructor() {
      super(), this.isScene = true, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Zi(), this.environmentIntensity = 1, this.environmentRotation = new Zi(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
        detail: this
      }));
    }
    copy(e, t) {
      return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
    }
    toJSON(e) {
      const t = super.toJSON(e);
      return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t;
    }
  }
  class jv {
    constructor(e, t) {
      this.isInterleavedBuffer = true, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = Wh, this.updateRanges = [], this.version = 0, this.uuid = wi();
    }
    onUploadCallback() {
    }
    set needsUpdate(e) {
      e === true && this.version++;
    }
    setUsage(e) {
      return this.usage = e, this;
    }
    addUpdateRange(e, t) {
      this.updateRanges.push({
        start: e,
        count: t
      });
    }
    clearUpdateRanges() {
      this.updateRanges.length = 0;
    }
    copy(e) {
      return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
    }
    copyAt(e, t, n) {
      e *= this.stride, n *= t.stride;
      for (let i = 0, r = this.stride; i < r; i++) this.array[e + i] = t.array[n + i];
      return this;
    }
    set(e, t = 0) {
      return this.array.set(e, t), this;
    }
    clone(e) {
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = wi()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
      const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride);
      return n.setUsage(this.usage), n;
    }
    onUpload(e) {
      return this.onUploadCallback = e, this;
    }
    toJSON(e) {
      return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = wi()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride
      };
    }
  }
  const Gn = new V();
  class Pf {
    constructor(e, t, n, i = false) {
      this.isInterleavedBufferAttribute = true, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = i;
    }
    get count() {
      return this.data.count;
    }
    get array() {
      return this.data.array;
    }
    set needsUpdate(e) {
      this.data.needsUpdate = e;
    }
    applyMatrix4(e) {
      for (let t = 0, n = this.data.count; t < n; t++) Gn.fromBufferAttribute(this, t), Gn.applyMatrix4(e), this.setXYZ(t, Gn.x, Gn.y, Gn.z);
      return this;
    }
    applyNormalMatrix(e) {
      for (let t = 0, n = this.count; t < n; t++) Gn.fromBufferAttribute(this, t), Gn.applyNormalMatrix(e), this.setXYZ(t, Gn.x, Gn.y, Gn.z);
      return this;
    }
    transformDirection(e) {
      for (let t = 0, n = this.count; t < n; t++) Gn.fromBufferAttribute(this, t), Gn.transformDirection(e), this.setXYZ(t, Gn.x, Gn.y, Gn.z);
      return this;
    }
    getComponent(e, t) {
      let n = this.array[e * this.data.stride + this.offset + t];
      return this.normalized && (n = Li(n, this.array)), n;
    }
    setComponent(e, t, n) {
      return this.normalized && (n = qt(n, this.array)), this.data.array[e * this.data.stride + this.offset + t] = n, this;
    }
    setX(e, t) {
      return this.normalized && (t = qt(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
    }
    setY(e, t) {
      return this.normalized && (t = qt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
    }
    setZ(e, t) {
      return this.normalized && (t = qt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
    }
    setW(e, t) {
      return this.normalized && (t = qt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
    }
    getX(e) {
      let t = this.data.array[e * this.data.stride + this.offset];
      return this.normalized && (t = Li(t, this.array)), t;
    }
    getY(e) {
      let t = this.data.array[e * this.data.stride + this.offset + 1];
      return this.normalized && (t = Li(t, this.array)), t;
    }
    getZ(e) {
      let t = this.data.array[e * this.data.stride + this.offset + 2];
      return this.normalized && (t = Li(t, this.array)), t;
    }
    getW(e) {
      let t = this.data.array[e * this.data.stride + this.offset + 3];
      return this.normalized && (t = Li(t, this.array)), t;
    }
    setXY(e, t, n) {
      return e = e * this.data.stride + this.offset, this.normalized && (t = qt(t, this.array), n = qt(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this;
    }
    setXYZ(e, t, n, i) {
      return e = e * this.data.stride + this.offset, this.normalized && (t = qt(t, this.array), n = qt(n, this.array), i = qt(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this;
    }
    setXYZW(e, t, n, i, r) {
      return e = e * this.data.stride + this.offset, this.normalized && (t = qt(t, this.array), n = qt(n, this.array), i = qt(i, this.array), r = qt(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = r, this;
    }
    clone(e) {
      if (e === void 0) {
        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
        const t = [];
        for (let n = 0; n < this.count; n++) {
          const i = n * this.data.stride + this.offset;
          for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[i + r]);
        }
        return new jn(new this.array.constructor(t), this.itemSize, this.normalized);
      } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Pf(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
    toJSON(e) {
      if (e === void 0) {
        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
        const t = [];
        for (let n = 0; n < this.count; n++) {
          const i = n * this.data.stride + this.offset;
          for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[i + r]);
        }
        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: t,
          normalized: this.normalized
        };
      } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
  const Qd = new V(), ep = new zt(), tp = new zt(), $v = new V(), np = new pt(), Vl = new V(), Ru = new Qi(), ip = new pt(), Pu = new ul();
  class Kv extends hn {
    constructor(e, t) {
      super(e, t), this.isSkinnedMesh = true, this.type = "SkinnedMesh", this.bindMode = Rd, this.bindMatrix = new pt(), this.bindMatrixInverse = new pt(), this.boundingBox = null, this.boundingSphere = null;
    }
    computeBoundingBox() {
      const e = this.geometry;
      this.boundingBox === null && (this.boundingBox = new Rr()), this.boundingBox.makeEmpty();
      const t = e.getAttribute("position");
      for (let n = 0; n < t.count; n++) this.getVertexPosition(n, Vl), this.boundingBox.expandByPoint(Vl);
    }
    computeBoundingSphere() {
      const e = this.geometry;
      this.boundingSphere === null && (this.boundingSphere = new Qi()), this.boundingSphere.makeEmpty();
      const t = e.getAttribute("position");
      for (let n = 0; n < t.count; n++) this.getVertexPosition(n, Vl), this.boundingSphere.expandByPoint(Vl);
    }
    copy(e, t) {
      return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
    }
    raycast(e, t) {
      const n = this.material, i = this.matrixWorld;
      n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Ru.copy(this.boundingSphere), Ru.applyMatrix4(i), e.ray.intersectsSphere(Ru) !== false && (ip.copy(i).invert(), Pu.copy(e.ray).applyMatrix4(ip), !(this.boundingBox !== null && Pu.intersectsBox(this.boundingBox) === false) && this._computeIntersections(e, t, Pu)));
    }
    getVertexPosition(e, t) {
      return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
    }
    bind(e, t) {
      this.skeleton = e, t === void 0 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
    }
    pose() {
      this.skeleton.pose();
    }
    normalizeSkinWeights() {
      const e = new zt(), t = this.geometry.attributes.skinWeight;
      for (let n = 0, i = t.count; n < i; n++) {
        e.fromBufferAttribute(t, n);
        const r = 1 / e.manhattanLength();
        r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w);
      }
    }
    updateMatrixWorld(e) {
      super.updateMatrixWorld(e), this.bindMode === Rd ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === W0 ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
    applyBoneTransform(e, t) {
      const n = this.skeleton, i = this.geometry;
      ep.fromBufferAttribute(i.attributes.skinIndex, e), tp.fromBufferAttribute(i.attributes.skinWeight, e), Qd.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
      for (let r = 0; r < 4; r++) {
        const o = tp.getComponent(r);
        if (o !== 0) {
          const a = ep.getComponent(r);
          np.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]), t.addScaledVector($v.copy(Qd).applyMatrix4(np), o);
        }
      }
      return t.applyMatrix4(this.bindMatrixInverse);
    }
  }
  class tg extends on {
    constructor() {
      super(), this.isBone = true, this.type = "Bone";
    }
  }
  class ng extends Mn {
    constructor(e = null, t = 1, n = 1, i, r, o, a, l, c = Yn, h = Yn, f, m) {
      super(null, o, a, l, c, h, i, r, f, m), this.isDataTexture = true, this.image = {
        data: e,
        width: t,
        height: n
      }, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
    }
  }
  const rp = new pt(), Zv = new pt();
  class Df {
    constructor(e = [], t = []) {
      this.uuid = wi(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init();
    }
    init() {
      const e = this.bones, t = this.boneInverses;
      if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses();
      else if (e.length !== t.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
        for (let n = 0, i = this.bones.length; n < i; n++) this.boneInverses.push(new pt());
      }
    }
    calculateInverses() {
      this.boneInverses.length = 0;
      for (let e = 0, t = this.bones.length; e < t; e++) {
        const n = new pt();
        this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n);
      }
    }
    pose() {
      for (let e = 0, t = this.bones.length; e < t; e++) {
        const n = this.bones[e];
        n && n.matrixWorld.copy(this.boneInverses[e]).invert();
      }
      for (let e = 0, t = this.bones.length; e < t; e++) {
        const n = this.bones[e];
        n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
      }
    }
    update() {
      const e = this.bones, t = this.boneInverses, n = this.boneMatrices, i = this.boneTexture;
      for (let r = 0, o = e.length; r < o; r++) {
        const a = e[r] ? e[r].matrixWorld : Zv;
        rp.multiplyMatrices(a, t[r]), rp.toArray(n, r * 16);
      }
      i !== null && (i.needsUpdate = true);
    }
    clone() {
      return new Df(this.bones, this.boneInverses);
    }
    computeBoneTexture() {
      let e = Math.sqrt(this.bones.length * 4);
      e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
      const t = new Float32Array(e * e * 4);
      t.set(this.boneMatrices);
      const n = new ng(t, e, e, Ti, Ni);
      return n.needsUpdate = true, this.boneMatrices = t, this.boneTexture = n, this;
    }
    getBoneByName(e) {
      for (let t = 0, n = this.bones.length; t < n; t++) {
        const i = this.bones[t];
        if (i.name === e) return i;
      }
    }
    dispose() {
      this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
    }
    fromJSON(e, t) {
      this.uuid = e.uuid;
      for (let n = 0, i = e.bones.length; n < i; n++) {
        const r = e.bones[n];
        let o = t[r];
        o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r), o = new tg()), this.bones.push(o), this.boneInverses.push(new pt().fromArray(e.boneInverses[n]));
      }
      return this.init(), this;
    }
    toJSON() {
      const e = {
        metadata: {
          version: 4.6,
          type: "Skeleton",
          generator: "Skeleton.toJSON"
        },
        bones: [],
        boneInverses: []
      };
      e.uuid = this.uuid;
      const t = this.bones, n = this.boneInverses;
      for (let i = 0, r = t.length; i < r; i++) {
        const o = t[i];
        e.bones.push(o.uuid);
        const a = n[i];
        e.boneInverses.push(a.toArray());
      }
      return e;
    }
  }
  class Xh extends jn {
    constructor(e, t, n, i = 1) {
      super(e, t, n), this.isInstancedBufferAttribute = true, this.meshPerAttribute = i;
    }
    copy(e) {
      return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = true, e;
    }
  }
  const ao = new pt(), sp = new pt(), Gl = [], op = new Rr(), Jv = new pt(), Ma = new hn(), Ta = new Qi();
  class Qv extends hn {
    constructor(e, t, n) {
      super(e, t), this.isInstancedMesh = true, this.instanceMatrix = new Xh(new Float32Array(n * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
      for (let i = 0; i < n; i++) this.setMatrixAt(i, Jv);
    }
    computeBoundingBox() {
      const e = this.geometry, t = this.count;
      this.boundingBox === null && (this.boundingBox = new Rr()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
      for (let n = 0; n < t; n++) this.getMatrixAt(n, ao), op.copy(e.boundingBox).applyMatrix4(ao), this.boundingBox.union(op);
    }
    computeBoundingSphere() {
      const e = this.geometry, t = this.count;
      this.boundingSphere === null && (this.boundingSphere = new Qi()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
      for (let n = 0; n < t; n++) this.getMatrixAt(n, ao), Ta.copy(e.boundingSphere).applyMatrix4(ao), this.boundingSphere.union(Ta);
    }
    copy(e, t) {
      return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
    }
    getColorAt(e, t) {
      t.fromArray(this.instanceColor.array, e * 3);
    }
    getMatrixAt(e, t) {
      t.fromArray(this.instanceMatrix.array, e * 16);
    }
    getMorphAt(e, t) {
      const n = t.morphTargetInfluences, i = this.morphTexture.source.data.data, r = n.length + 1, o = e * r + 1;
      for (let a = 0; a < n.length; a++) n[a] = i[o + a];
    }
    raycast(e, t) {
      const n = this.matrixWorld, i = this.count;
      if (Ma.geometry = this.geometry, Ma.material = this.material, Ma.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Ta.copy(this.boundingSphere), Ta.applyMatrix4(n), e.ray.intersectsSphere(Ta) !== false)) for (let r = 0; r < i; r++) {
        this.getMatrixAt(r, ao), sp.multiplyMatrices(n, ao), Ma.matrixWorld = sp, Ma.raycast(e, Gl);
        for (let o = 0, a = Gl.length; o < a; o++) {
          const l = Gl[o];
          l.instanceId = r, l.object = this, t.push(l);
        }
        Gl.length = 0;
      }
    }
    setColorAt(e, t) {
      this.instanceColor === null && (this.instanceColor = new Xh(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)), t.toArray(this.instanceColor.array, e * 3);
    }
    setMatrixAt(e, t) {
      t.toArray(this.instanceMatrix.array, e * 16);
    }
    setMorphAt(e, t) {
      const n = t.morphTargetInfluences, i = n.length + 1;
      this.morphTexture === null && (this.morphTexture = new ng(new Float32Array(i * this.count), i, this.count, Tf, Ni));
      const r = this.morphTexture.source.data.data;
      let o = 0;
      for (let c = 0; c < n.length; c++) o += n[c];
      const a = this.geometry.morphTargetsRelative ? 1 : 1 - o, l = i * e;
      r[l] = a, r.set(n, l + 1);
    }
    updateMorphTargets() {
    }
    dispose() {
      return this.dispatchEvent({
        type: "dispose"
      }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null), this;
    }
  }
  const Du = new V(), ey = new V(), ty = new mt();
  class xs {
    constructor(e = new V(1, 0, 0), t = 0) {
      this.isPlane = true, this.normal = e, this.constant = t;
    }
    set(e, t) {
      return this.normal.copy(e), this.constant = t, this;
    }
    setComponents(e, t, n, i) {
      return this.normal.set(e, t, n), this.constant = i, this;
    }
    setFromNormalAndCoplanarPoint(e, t) {
      return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
    }
    setFromCoplanarPoints(e, t, n) {
      const i = Du.subVectors(n, t).cross(ey.subVectors(e, t)).normalize();
      return this.setFromNormalAndCoplanarPoint(i, e), this;
    }
    copy(e) {
      return this.normal.copy(e.normal), this.constant = e.constant, this;
    }
    normalize() {
      const e = 1 / this.normal.length();
      return this.normal.multiplyScalar(e), this.constant *= e, this;
    }
    negate() {
      return this.constant *= -1, this.normal.negate(), this;
    }
    distanceToPoint(e) {
      return this.normal.dot(e) + this.constant;
    }
    distanceToSphere(e) {
      return this.distanceToPoint(e.center) - e.radius;
    }
    projectPoint(e, t) {
      return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
    }
    intersectLine(e, t) {
      const n = e.delta(Du), i = this.normal.dot(n);
      if (i === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
      const r = -(e.start.dot(this.normal) + this.constant) / i;
      return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r);
    }
    intersectsLine(e) {
      const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
      return t < 0 && n > 0 || n < 0 && t > 0;
    }
    intersectsBox(e) {
      return e.intersectsPlane(this);
    }
    intersectsSphere(e) {
      return e.intersectsPlane(this);
    }
    coplanarPoint(e) {
      return e.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(e, t) {
      const n = t || ty.getNormalMatrix(e), i = this.coplanarPoint(Du).applyMatrix4(e), r = this.normal.applyMatrix3(n).normalize();
      return this.constant = -i.dot(r), this;
    }
    translate(e) {
      return this.constant -= e.dot(this.normal), this;
    }
    equals(e) {
      return e.normal.equals(this.normal) && e.constant === this.constant;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const ps = new Qi(), Wl = new V();
  class Lf {
    constructor(e = new xs(), t = new xs(), n = new xs(), i = new xs(), r = new xs(), o = new xs()) {
      this.planes = [
        e,
        t,
        n,
        i,
        r,
        o
      ];
    }
    set(e, t, n, i, r, o) {
      const a = this.planes;
      return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(i), a[4].copy(r), a[5].copy(o), this;
    }
    copy(e) {
      const t = this.planes;
      for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
      return this;
    }
    setFromProjectionMatrix(e, t = br) {
      const n = this.planes, i = e.elements, r = i[0], o = i[1], a = i[2], l = i[3], c = i[4], h = i[5], f = i[6], m = i[7], _ = i[8], y = i[9], g = i[10], x = i[11], v = i[12], E = i[13], T = i[14], M = i[15];
      if (n[0].setComponents(l - r, m - c, x - _, M - v).normalize(), n[1].setComponents(l + r, m + c, x + _, M + v).normalize(), n[2].setComponents(l + o, m + h, x + y, M + E).normalize(), n[3].setComponents(l - o, m - h, x - y, M - E).normalize(), n[4].setComponents(l - a, m - f, x - g, M - T).normalize(), t === br) n[5].setComponents(l + a, m + f, x + g, M + T).normalize();
      else if (t === Mc) n[5].setComponents(a, f, g, T).normalize();
      else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
      return this;
    }
    intersectsObject(e) {
      if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), ps.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
      else {
        const t = e.geometry;
        t.boundingSphere === null && t.computeBoundingSphere(), ps.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
      }
      return this.intersectsSphere(ps);
    }
    intersectsSprite(e) {
      return ps.center.set(0, 0, 0), ps.radius = 0.7071067811865476, ps.applyMatrix4(e.matrixWorld), this.intersectsSphere(ps);
    }
    intersectsSphere(e) {
      const t = this.planes, n = e.center, i = -e.radius;
      for (let r = 0; r < 6; r++) if (t[r].distanceToPoint(n) < i) return false;
      return true;
    }
    intersectsBox(e) {
      const t = this.planes;
      for (let n = 0; n < 6; n++) {
        const i = t[n];
        if (Wl.x = i.normal.x > 0 ? e.max.x : e.min.x, Wl.y = i.normal.y > 0 ? e.max.y : e.min.y, Wl.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(Wl) < 0) return false;
      }
      return true;
    }
    containsPoint(e) {
      const t = this.planes;
      for (let n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return false;
      return true;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class ig extends ji {
    constructor(e) {
      super(), this.isLineBasicMaterial = true, this.type = "LineBasicMaterial", this.color = new it(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = true, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
    }
  }
  const Ec = new V(), wc = new V(), ap = new pt(), Ea = new ul(), Xl = new Qi(), Lu = new V(), lp = new V();
  class If extends on {
    constructor(e = new si(), t = new ig()) {
      super(), this.isLine = true, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
    }
    copy(e, t) {
      return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
    }
    computeLineDistances() {
      const e = this.geometry;
      if (e.index === null) {
        const t = e.attributes.position, n = [
          0
        ];
        for (let i = 1, r = t.count; i < r; i++) Ec.fromBufferAttribute(t, i - 1), wc.fromBufferAttribute(t, i), n[i] = n[i - 1], n[i] += Ec.distanceTo(wc);
        e.setAttribute("lineDistance", new Ln(n, 1));
      } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      return this;
    }
    raycast(e, t) {
      const n = this.geometry, i = this.matrixWorld, r = e.params.Line.threshold, o = n.drawRange;
      if (n.boundingSphere === null && n.computeBoundingSphere(), Xl.copy(n.boundingSphere), Xl.applyMatrix4(i), Xl.radius += r, e.ray.intersectsSphere(Xl) === false) return;
      ap.copy(i).invert(), Ea.copy(e.ray).applyMatrix4(ap);
      const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, c = this.isLineSegments ? 2 : 1, h = n.index, m = n.attributes.position;
      if (h !== null) {
        const _ = Math.max(0, o.start), y = Math.min(h.count, o.start + o.count);
        for (let g = _, x = y - 1; g < x; g += c) {
          const v = h.getX(g), E = h.getX(g + 1), T = ql(this, e, Ea, l, v, E, g);
          T && t.push(T);
        }
        if (this.isLineLoop) {
          const g = h.getX(y - 1), x = h.getX(_), v = ql(this, e, Ea, l, g, x, y - 1);
          v && t.push(v);
        }
      } else {
        const _ = Math.max(0, o.start), y = Math.min(m.count, o.start + o.count);
        for (let g = _, x = y - 1; g < x; g += c) {
          const v = ql(this, e, Ea, l, g, g + 1, g);
          v && t.push(v);
        }
        if (this.isLineLoop) {
          const g = ql(this, e, Ea, l, y - 1, _, y - 1);
          g && t.push(g);
        }
      }
    }
    updateMorphTargets() {
      const t = this.geometry.morphAttributes, n = Object.keys(t);
      if (n.length > 0) {
        const i = t[n[0]];
        if (i !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let r = 0, o = i.length; r < o; r++) {
            const a = i[r].name || String(r);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
          }
        }
      }
    }
  }
  function ql(s, e, t, n, i, r, o) {
    const a = s.geometry.attributes.position;
    if (Ec.fromBufferAttribute(a, i), wc.fromBufferAttribute(a, r), t.distanceSqToSegment(Ec, wc, Lu, lp) > n) return;
    Lu.applyMatrix4(s.matrixWorld);
    const c = e.ray.origin.distanceTo(Lu);
    if (!(c < e.near || c > e.far)) return {
      distance: c,
      point: lp.clone().applyMatrix4(s.matrixWorld),
      index: o,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: s
    };
  }
  const cp = new V(), up = new V();
  class ny extends If {
    constructor(e, t) {
      super(e, t), this.isLineSegments = true, this.type = "LineSegments";
    }
    computeLineDistances() {
      const e = this.geometry;
      if (e.index === null) {
        const t = e.attributes.position, n = [];
        for (let i = 0, r = t.count; i < r; i += 2) cp.fromBufferAttribute(t, i), up.fromBufferAttribute(t, i + 1), n[i] = i === 0 ? 0 : n[i - 1], n[i + 1] = n[i] + cp.distanceTo(up);
        e.setAttribute("lineDistance", new Ln(n, 1));
      } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      return this;
    }
  }
  class iy extends If {
    constructor(e, t) {
      super(e, t), this.isLineLoop = true, this.type = "LineLoop";
    }
  }
  class Nf extends ji {
    constructor(e) {
      super(), this.isPointsMaterial = true, this.type = "PointsMaterial", this.color = new it(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.fog = true, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
    }
  }
  const hp = new pt(), qh = new ul(), Yl = new Qi(), jl = new V();
  class rg extends on {
    constructor(e = new si(), t = new Nf()) {
      super(), this.isPoints = true, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
    }
    copy(e, t) {
      return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
    }
    raycast(e, t) {
      const n = this.geometry, i = this.matrixWorld, r = e.params.Points.threshold, o = n.drawRange;
      if (n.boundingSphere === null && n.computeBoundingSphere(), Yl.copy(n.boundingSphere), Yl.applyMatrix4(i), Yl.radius += r, e.ray.intersectsSphere(Yl) === false) return;
      hp.copy(i).invert(), qh.copy(e.ray).applyMatrix4(hp);
      const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, c = n.index, f = n.attributes.position;
      if (c !== null) {
        const m = Math.max(0, o.start), _ = Math.min(c.count, o.start + o.count);
        for (let y = m, g = _; y < g; y++) {
          const x = c.getX(y);
          jl.fromBufferAttribute(f, x), fp(jl, x, l, i, e, t, this);
        }
      } else {
        const m = Math.max(0, o.start), _ = Math.min(f.count, o.start + o.count);
        for (let y = m, g = _; y < g; y++) jl.fromBufferAttribute(f, y), fp(jl, y, l, i, e, t, this);
      }
    }
    updateMorphTargets() {
      const t = this.geometry.morphAttributes, n = Object.keys(t);
      if (n.length > 0) {
        const i = t[n[0]];
        if (i !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let r = 0, o = i.length; r < o; r++) {
            const a = i[r].name || String(r);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
          }
        }
      }
    }
  }
  function fp(s, e, t, n, i, r, o) {
    const a = qh.distanceSqToPoint(s);
    if (a < t) {
      const l = new V();
      qh.closestPointToPoint(s, l), l.applyMatrix4(n);
      const c = i.ray.origin.distanceTo(l);
      if (c < i.near || c > i.far) return;
      r.push({
        distance: c,
        distanceToRay: Math.sqrt(a),
        point: l,
        index: e,
        face: null,
        faceIndex: null,
        barycoord: null,
        object: o
      });
    }
  }
  class ry extends Mn {
    constructor(e, t, n, i, r, o, a, l, c) {
      super(e, t, n, i, r, o, a, l, c), this.isCanvasTexture = true, this.needsUpdate = true;
    }
  }
  class sg extends Mn {
    constructor(e, t, n, i, r, o, a, l, c, h = xo) {
      if (h !== xo && h !== Lo) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
      n === void 0 && h === xo && (n = Us), n === void 0 && h === Lo && (n = Do), super(null, i, r, o, a, l, h, n, c), this.isDepthTexture = true, this.image = {
        width: e,
        height: t
      }, this.magFilter = a !== void 0 ? a : Yn, this.minFilter = l !== void 0 ? l : Yn, this.flipY = false, this.generateMipmaps = false, this.compareFunction = null;
    }
    copy(e) {
      return super.copy(e), this.compareFunction = e.compareFunction, this;
    }
    toJSON(e) {
      const t = super.toJSON(e);
      return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
    }
  }
  class er {
    constructor() {
      this.type = "Curve", this.arcLengthDivisions = 200;
    }
    getPoint() {
      return console.warn("THREE.Curve: .getPoint() not implemented."), null;
    }
    getPointAt(e, t) {
      const n = this.getUtoTmapping(e);
      return this.getPoint(n, t);
    }
    getPoints(e = 5) {
      const t = [];
      for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
      return t;
    }
    getSpacedPoints(e = 5) {
      const t = [];
      for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
      return t;
    }
    getLength() {
      const e = this.getLengths();
      return e[e.length - 1];
    }
    getLengths(e = this.arcLengthDivisions) {
      if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
      this.needsUpdate = false;
      const t = [];
      let n, i = this.getPoint(0), r = 0;
      t.push(0);
      for (let o = 1; o <= e; o++) n = this.getPoint(o / e), r += n.distanceTo(i), t.push(r), i = n;
      return this.cacheArcLengths = t, t;
    }
    updateArcLengths() {
      this.needsUpdate = true, this.getLengths();
    }
    getUtoTmapping(e, t) {
      const n = this.getLengths();
      let i = 0;
      const r = n.length;
      let o;
      t ? o = t : o = e * n[r - 1];
      let a = 0, l = r - 1, c;
      for (; a <= l; ) if (i = Math.floor(a + (l - a) / 2), c = n[i] - o, c < 0) a = i + 1;
      else if (c > 0) l = i - 1;
      else {
        l = i;
        break;
      }
      if (i = l, n[i] === o) return i / (r - 1);
      const h = n[i], m = n[i + 1] - h, _ = (o - h) / m;
      return (i + _) / (r - 1);
    }
    getTangent(e, t) {
      let i = e - 1e-4, r = e + 1e-4;
      i < 0 && (i = 0), r > 1 && (r = 1);
      const o = this.getPoint(i), a = this.getPoint(r), l = t || (o.isVector2 ? new Se() : new V());
      return l.copy(a).sub(o).normalize(), l;
    }
    getTangentAt(e, t) {
      const n = this.getUtoTmapping(e);
      return this.getTangent(n, t);
    }
    computeFrenetFrames(e, t) {
      const n = new V(), i = [], r = [], o = [], a = new V(), l = new pt();
      for (let _ = 0; _ <= e; _++) {
        const y = _ / e;
        i[_] = this.getTangentAt(y, new V());
      }
      r[0] = new V(), o[0] = new V();
      let c = Number.MAX_VALUE;
      const h = Math.abs(i[0].x), f = Math.abs(i[0].y), m = Math.abs(i[0].z);
      h <= c && (c = h, n.set(1, 0, 0)), f <= c && (c = f, n.set(0, 1, 0)), m <= c && n.set(0, 0, 1), a.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], a), o[0].crossVectors(i[0], r[0]);
      for (let _ = 1; _ <= e; _++) {
        if (r[_] = r[_ - 1].clone(), o[_] = o[_ - 1].clone(), a.crossVectors(i[_ - 1], i[_]), a.length() > Number.EPSILON) {
          a.normalize();
          const y = Math.acos(xt(i[_ - 1].dot(i[_]), -1, 1));
          r[_].applyMatrix4(l.makeRotationAxis(a, y));
        }
        o[_].crossVectors(i[_], r[_]);
      }
      if (t === true) {
        let _ = Math.acos(xt(r[0].dot(r[e]), -1, 1));
        _ /= e, i[0].dot(a.crossVectors(r[0], r[e])) > 0 && (_ = -_);
        for (let y = 1; y <= e; y++) r[y].applyMatrix4(l.makeRotationAxis(i[y], _ * y)), o[y].crossVectors(i[y], r[y]);
      }
      return {
        tangents: i,
        normals: r,
        binormals: o
      };
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.arcLengthDivisions = e.arcLengthDivisions, this;
    }
    toJSON() {
      const e = {
        metadata: {
          version: 4.6,
          type: "Curve",
          generator: "Curve.toJSON"
        }
      };
      return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
    }
    fromJSON(e) {
      return this.arcLengthDivisions = e.arcLengthDivisions, this;
    }
  }
  class Uf extends er {
    constructor(e = 0, t = 0, n = 1, i = 1, r = 0, o = Math.PI * 2, a = false, l = 0) {
      super(), this.isEllipseCurve = true, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = o, this.aClockwise = a, this.aRotation = l;
    }
    getPoint(e, t = new Se()) {
      const n = t, i = Math.PI * 2;
      let r = this.aEndAngle - this.aStartAngle;
      const o = Math.abs(r) < Number.EPSILON;
      for (; r < 0; ) r += i;
      for (; r > i; ) r -= i;
      r < Number.EPSILON && (o ? r = 0 : r = i), this.aClockwise === true && !o && (r === i ? r = -i : r = r - i);
      const a = this.aStartAngle + e * r;
      let l = this.aX + this.xRadius * Math.cos(a), c = this.aY + this.yRadius * Math.sin(a);
      if (this.aRotation !== 0) {
        const h = Math.cos(this.aRotation), f = Math.sin(this.aRotation), m = l - this.aX, _ = c - this.aY;
        l = m * h - _ * f + this.aX, c = m * f + _ * h + this.aY;
      }
      return n.set(l, c);
    }
    copy(e) {
      return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
    }
    fromJSON(e) {
      return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
    }
  }
  class sy extends Uf {
    constructor(e, t, n, i, r, o) {
      super(e, t, n, n, i, r, o), this.isArcCurve = true, this.type = "ArcCurve";
    }
  }
  function Of() {
    let s = 0, e = 0, t = 0, n = 0;
    function i(r, o, a, l) {
      s = r, e = a, t = -3 * r + 3 * o - 2 * a - l, n = 2 * r - 2 * o + a + l;
    }
    return {
      initCatmullRom: function(r, o, a, l, c) {
        i(o, a, c * (a - r), c * (l - o));
      },
      initNonuniformCatmullRom: function(r, o, a, l, c, h, f) {
        let m = (o - r) / c - (a - r) / (c + h) + (a - o) / h, _ = (a - o) / h - (l - o) / (h + f) + (l - a) / f;
        m *= h, _ *= h, i(o, a, m, _);
      },
      calc: function(r) {
        const o = r * r, a = o * r;
        return s + e * r + t * o + n * a;
      }
    };
  }
  const $l = new V(), Iu = new Of(), Nu = new Of(), Uu = new Of();
  class oy extends er {
    constructor(e = [], t = false, n = "centripetal", i = 0.5) {
      super(), this.isCatmullRomCurve3 = true, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = i;
    }
    getPoint(e, t = new V()) {
      const n = t, i = this.points, r = i.length, o = (r - (this.closed ? 0 : 1)) * e;
      let a = Math.floor(o), l = o - a;
      this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / r) + 1) * r : l === 0 && a === r - 1 && (a = r - 2, l = 1);
      let c, h;
      this.closed || a > 0 ? c = i[(a - 1) % r] : ($l.subVectors(i[0], i[1]).add(i[0]), c = $l);
      const f = i[a % r], m = i[(a + 1) % r];
      if (this.closed || a + 2 < r ? h = i[(a + 2) % r] : ($l.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), h = $l), this.curveType === "centripetal" || this.curveType === "chordal") {
        const _ = this.curveType === "chordal" ? 0.5 : 0.25;
        let y = Math.pow(c.distanceToSquared(f), _), g = Math.pow(f.distanceToSquared(m), _), x = Math.pow(m.distanceToSquared(h), _);
        g < 1e-4 && (g = 1), y < 1e-4 && (y = g), x < 1e-4 && (x = g), Iu.initNonuniformCatmullRom(c.x, f.x, m.x, h.x, y, g, x), Nu.initNonuniformCatmullRom(c.y, f.y, m.y, h.y, y, g, x), Uu.initNonuniformCatmullRom(c.z, f.z, m.z, h.z, y, g, x);
      } else this.curveType === "catmullrom" && (Iu.initCatmullRom(c.x, f.x, m.x, h.x, this.tension), Nu.initCatmullRom(c.y, f.y, m.y, h.y, this.tension), Uu.initCatmullRom(c.z, f.z, m.z, h.z, this.tension));
      return n.set(Iu.calc(l), Nu.calc(l), Uu.calc(l)), n;
    }
    copy(e) {
      super.copy(e), this.points = [];
      for (let t = 0, n = e.points.length; t < n; t++) {
        const i = e.points[t];
        this.points.push(i.clone());
      }
      return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
    }
    toJSON() {
      const e = super.toJSON();
      e.points = [];
      for (let t = 0, n = this.points.length; t < n; t++) {
        const i = this.points[t];
        e.points.push(i.toArray());
      }
      return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
    }
    fromJSON(e) {
      super.fromJSON(e), this.points = [];
      for (let t = 0, n = e.points.length; t < n; t++) {
        const i = e.points[t];
        this.points.push(new V().fromArray(i));
      }
      return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
    }
  }
  function dp(s, e, t, n, i) {
    const r = (n - e) * 0.5, o = (i - t) * 0.5, a = s * s, l = s * a;
    return (2 * t - 2 * n + r + o) * l + (-3 * t + 3 * n - 2 * r - o) * a + r * s + t;
  }
  function ay(s, e) {
    const t = 1 - s;
    return t * t * e;
  }
  function ly(s, e) {
    return 2 * (1 - s) * s * e;
  }
  function cy(s, e) {
    return s * s * e;
  }
  function Ba(s, e, t, n) {
    return ay(s, e) + ly(s, t) + cy(s, n);
  }
  function uy(s, e) {
    const t = 1 - s;
    return t * t * t * e;
  }
  function hy(s, e) {
    const t = 1 - s;
    return 3 * t * t * s * e;
  }
  function fy(s, e) {
    return 3 * (1 - s) * s * s * e;
  }
  function dy(s, e) {
    return s * s * s * e;
  }
  function za(s, e, t, n, i) {
    return uy(s, e) + hy(s, t) + fy(s, n) + dy(s, i);
  }
  class og extends er {
    constructor(e = new Se(), t = new Se(), n = new Se(), i = new Se()) {
      super(), this.isCubicBezierCurve = true, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i;
    }
    getPoint(e, t = new Se()) {
      const n = t, i = this.v0, r = this.v1, o = this.v2, a = this.v3;
      return n.set(za(e, i.x, r.x, o.x, a.x), za(e, i.y, r.y, o.y, a.y)), n;
    }
    copy(e) {
      return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
    }
    fromJSON(e) {
      return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
    }
  }
  class py extends er {
    constructor(e = new V(), t = new V(), n = new V(), i = new V()) {
      super(), this.isCubicBezierCurve3 = true, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i;
    }
    getPoint(e, t = new V()) {
      const n = t, i = this.v0, r = this.v1, o = this.v2, a = this.v3;
      return n.set(za(e, i.x, r.x, o.x, a.x), za(e, i.y, r.y, o.y, a.y), za(e, i.z, r.z, o.z, a.z)), n;
    }
    copy(e) {
      return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
    }
    fromJSON(e) {
      return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
    }
  }
  class ag extends er {
    constructor(e = new Se(), t = new Se()) {
      super(), this.isLineCurve = true, this.type = "LineCurve", this.v1 = e, this.v2 = t;
    }
    getPoint(e, t = new Se()) {
      const n = t;
      return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
    }
    getPointAt(e, t) {
      return this.getPoint(e, t);
    }
    getTangent(e, t = new Se()) {
      return t.subVectors(this.v2, this.v1).normalize();
    }
    getTangentAt(e, t) {
      return this.getTangent(e, t);
    }
    copy(e) {
      return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
    }
    fromJSON(e) {
      return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
    }
  }
  class my extends er {
    constructor(e = new V(), t = new V()) {
      super(), this.isLineCurve3 = true, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
    }
    getPoint(e, t = new V()) {
      const n = t;
      return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
    }
    getPointAt(e, t) {
      return this.getPoint(e, t);
    }
    getTangent(e, t = new V()) {
      return t.subVectors(this.v2, this.v1).normalize();
    }
    getTangentAt(e, t) {
      return this.getTangent(e, t);
    }
    copy(e) {
      return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
    }
    fromJSON(e) {
      return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
    }
  }
  class lg extends er {
    constructor(e = new Se(), t = new Se(), n = new Se()) {
      super(), this.isQuadraticBezierCurve = true, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n;
    }
    getPoint(e, t = new Se()) {
      const n = t, i = this.v0, r = this.v1, o = this.v2;
      return n.set(Ba(e, i.x, r.x, o.x), Ba(e, i.y, r.y, o.y)), n;
    }
    copy(e) {
      return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
    }
    fromJSON(e) {
      return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
    }
  }
  class gy extends er {
    constructor(e = new V(), t = new V(), n = new V()) {
      super(), this.isQuadraticBezierCurve3 = true, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n;
    }
    getPoint(e, t = new V()) {
      const n = t, i = this.v0, r = this.v1, o = this.v2;
      return n.set(Ba(e, i.x, r.x, o.x), Ba(e, i.y, r.y, o.y), Ba(e, i.z, r.z, o.z)), n;
    }
    copy(e) {
      return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
    }
    fromJSON(e) {
      return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
    }
  }
  class cg extends er {
    constructor(e = []) {
      super(), this.isSplineCurve = true, this.type = "SplineCurve", this.points = e;
    }
    getPoint(e, t = new Se()) {
      const n = t, i = this.points, r = (i.length - 1) * e, o = Math.floor(r), a = r - o, l = i[o === 0 ? o : o - 1], c = i[o], h = i[o > i.length - 2 ? i.length - 1 : o + 1], f = i[o > i.length - 3 ? i.length - 1 : o + 2];
      return n.set(dp(a, l.x, c.x, h.x, f.x), dp(a, l.y, c.y, h.y, f.y)), n;
    }
    copy(e) {
      super.copy(e), this.points = [];
      for (let t = 0, n = e.points.length; t < n; t++) {
        const i = e.points[t];
        this.points.push(i.clone());
      }
      return this;
    }
    toJSON() {
      const e = super.toJSON();
      e.points = [];
      for (let t = 0, n = this.points.length; t < n; t++) {
        const i = this.points[t];
        e.points.push(i.toArray());
      }
      return e;
    }
    fromJSON(e) {
      super.fromJSON(e), this.points = [];
      for (let t = 0, n = e.points.length; t < n; t++) {
        const i = e.points[t];
        this.points.push(new Se().fromArray(i));
      }
      return this;
    }
  }
  var Yh = Object.freeze({
    __proto__: null,
    ArcCurve: sy,
    CatmullRomCurve3: oy,
    CubicBezierCurve: og,
    CubicBezierCurve3: py,
    EllipseCurve: Uf,
    LineCurve: ag,
    LineCurve3: my,
    QuadraticBezierCurve: lg,
    QuadraticBezierCurve3: gy,
    SplineCurve: cg
  });
  class _y extends er {
    constructor() {
      super(), this.type = "CurvePath", this.curves = [], this.autoClose = false;
    }
    add(e) {
      this.curves.push(e);
    }
    closePath() {
      const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
      if (!e.equals(t)) {
        const n = e.isVector2 === true ? "LineCurve" : "LineCurve3";
        this.curves.push(new Yh[n](t, e));
      }
      return this;
    }
    getPoint(e, t) {
      const n = e * this.getLength(), i = this.getCurveLengths();
      let r = 0;
      for (; r < i.length; ) {
        if (i[r] >= n) {
          const o = i[r] - n, a = this.curves[r], l = a.getLength(), c = l === 0 ? 0 : 1 - o / l;
          return a.getPointAt(c, t);
        }
        r++;
      }
      return null;
    }
    getLength() {
      const e = this.getCurveLengths();
      return e[e.length - 1];
    }
    updateArcLengths() {
      this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
    }
    getCurveLengths() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
      const e = [];
      let t = 0;
      for (let n = 0, i = this.curves.length; n < i; n++) t += this.curves[n].getLength(), e.push(t);
      return this.cacheLengths = e, e;
    }
    getSpacedPoints(e = 40) {
      const t = [];
      for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
      return this.autoClose && t.push(t[0]), t;
    }
    getPoints(e = 12) {
      const t = [];
      let n;
      for (let i = 0, r = this.curves; i < r.length; i++) {
        const o = r[i], a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e, l = o.getPoints(a);
        for (let c = 0; c < l.length; c++) {
          const h = l[c];
          n && n.equals(h) || (t.push(h), n = h);
        }
      }
      return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
    }
    copy(e) {
      super.copy(e), this.curves = [];
      for (let t = 0, n = e.curves.length; t < n; t++) {
        const i = e.curves[t];
        this.curves.push(i.clone());
      }
      return this.autoClose = e.autoClose, this;
    }
    toJSON() {
      const e = super.toJSON();
      e.autoClose = this.autoClose, e.curves = [];
      for (let t = 0, n = this.curves.length; t < n; t++) {
        const i = this.curves[t];
        e.curves.push(i.toJSON());
      }
      return e;
    }
    fromJSON(e) {
      super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
      for (let t = 0, n = e.curves.length; t < n; t++) {
        const i = e.curves[t];
        this.curves.push(new Yh[i.type]().fromJSON(i));
      }
      return this;
    }
  }
  class jh extends _y {
    constructor(e) {
      super(), this.type = "Path", this.currentPoint = new Se(), e && this.setFromPoints(e);
    }
    setFromPoints(e) {
      this.moveTo(e[0].x, e[0].y);
      for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
      return this;
    }
    moveTo(e, t) {
      return this.currentPoint.set(e, t), this;
    }
    lineTo(e, t) {
      const n = new ag(this.currentPoint.clone(), new Se(e, t));
      return this.curves.push(n), this.currentPoint.set(e, t), this;
    }
    quadraticCurveTo(e, t, n, i) {
      const r = new lg(this.currentPoint.clone(), new Se(e, t), new Se(n, i));
      return this.curves.push(r), this.currentPoint.set(n, i), this;
    }
    bezierCurveTo(e, t, n, i, r, o) {
      const a = new og(this.currentPoint.clone(), new Se(e, t), new Se(n, i), new Se(r, o));
      return this.curves.push(a), this.currentPoint.set(r, o), this;
    }
    splineThru(e) {
      const t = [
        this.currentPoint.clone()
      ].concat(e), n = new cg(t);
      return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this;
    }
    arc(e, t, n, i, r, o) {
      const a = this.currentPoint.x, l = this.currentPoint.y;
      return this.absarc(e + a, t + l, n, i, r, o), this;
    }
    absarc(e, t, n, i, r, o) {
      return this.absellipse(e, t, n, n, i, r, o), this;
    }
    ellipse(e, t, n, i, r, o, a, l) {
      const c = this.currentPoint.x, h = this.currentPoint.y;
      return this.absellipse(e + c, t + h, n, i, r, o, a, l), this;
    }
    absellipse(e, t, n, i, r, o, a, l) {
      const c = new Uf(e, t, n, i, r, o, a, l);
      if (this.curves.length > 0) {
        const f = c.getPoint(0);
        f.equals(this.currentPoint) || this.lineTo(f.x, f.y);
      }
      this.curves.push(c);
      const h = c.getPoint(1);
      return this.currentPoint.copy(h), this;
    }
    copy(e) {
      return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.currentPoint = this.currentPoint.toArray(), e;
    }
    fromJSON(e) {
      return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
    }
  }
  class hc extends jh {
    constructor(e) {
      super(e), this.uuid = wi(), this.type = "Shape", this.holes = [];
    }
    getPointsHoles(e) {
      const t = [];
      for (let n = 0, i = this.holes.length; n < i; n++) t[n] = this.holes[n].getPoints(e);
      return t;
    }
    extractPoints(e) {
      return {
        shape: this.getPoints(e),
        holes: this.getPointsHoles(e)
      };
    }
    copy(e) {
      super.copy(e), this.holes = [];
      for (let t = 0, n = e.holes.length; t < n; t++) {
        const i = e.holes[t];
        this.holes.push(i.clone());
      }
      return this;
    }
    toJSON() {
      const e = super.toJSON();
      e.uuid = this.uuid, e.holes = [];
      for (let t = 0, n = this.holes.length; t < n; t++) {
        const i = this.holes[t];
        e.holes.push(i.toJSON());
      }
      return e;
    }
    fromJSON(e) {
      super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
      for (let t = 0, n = e.holes.length; t < n; t++) {
        const i = e.holes[t];
        this.holes.push(new jh().fromJSON(i));
      }
      return this;
    }
  }
  const vy = {
    triangulate: function(s, e, t = 2) {
      const n = e && e.length, i = n ? e[0] * t : s.length;
      let r = ug(s, 0, i, t, true);
      const o = [];
      if (!r || r.next === r.prev) return o;
      let a, l, c, h, f, m, _;
      if (n && (r = My(s, e, r, t)), s.length > 80 * t) {
        a = c = s[0], l = h = s[1];
        for (let y = t; y < i; y += t) f = s[y], m = s[y + 1], f < a && (a = f), m < l && (l = m), f > c && (c = f), m > h && (h = m);
        _ = Math.max(c - a, h - l), _ = _ !== 0 ? 32767 / _ : 0;
      }
      return Ja(r, o, t, a, l, _, 0), o;
    }
  };
  function ug(s, e, t, n, i) {
    let r, o;
    if (i === Ny(s, e, t, n) > 0) for (r = e; r < t; r += n) o = pp(r, s[r], s[r + 1], o);
    else for (r = t - n; r >= e; r -= n) o = pp(r, s[r], s[r + 1], o);
    return o && Bc(o, o.next) && (el(o), o = o.next), o;
  }
  function Os(s, e) {
    if (!s) return s;
    e || (e = s);
    let t = s, n;
    do
      if (n = false, !t.steiner && (Bc(t, t.next) || rn(t.prev, t, t.next) === 0)) {
        if (el(t), t = e = t.prev, t === t.next) break;
        n = true;
      } else t = t.next;
    while (n || t !== e);
    return e;
  }
  function Ja(s, e, t, n, i, r, o) {
    if (!s) return;
    !o && r && Cy(s, n, i, r);
    let a = s, l, c;
    for (; s.prev !== s.next; ) {
      if (l = s.prev, c = s.next, r ? xy(s, n, i, r) : yy(s)) {
        e.push(l.i / t | 0), e.push(s.i / t | 0), e.push(c.i / t | 0), el(s), s = c.next, a = c.next;
        continue;
      }
      if (s = c, s === a) {
        o ? o === 1 ? (s = by(Os(s), e, t), Ja(s, e, t, n, i, r, 2)) : o === 2 && Sy(s, e, t, n, i, r) : Ja(Os(s), e, t, n, i, r, 1);
        break;
      }
    }
  }
  function yy(s) {
    const e = s.prev, t = s, n = s.next;
    if (rn(e, t, n) >= 0) return false;
    const i = e.x, r = t.x, o = n.x, a = e.y, l = t.y, c = n.y, h = i < r ? i < o ? i : o : r < o ? r : o, f = a < l ? a < c ? a : c : l < c ? l : c, m = i > r ? i > o ? i : o : r > o ? r : o, _ = a > l ? a > c ? a : c : l > c ? l : c;
    let y = n.next;
    for (; y !== e; ) {
      if (y.x >= h && y.x <= m && y.y >= f && y.y <= _ && mo(i, a, r, l, o, c, y.x, y.y) && rn(y.prev, y, y.next) >= 0) return false;
      y = y.next;
    }
    return true;
  }
  function xy(s, e, t, n) {
    const i = s.prev, r = s, o = s.next;
    if (rn(i, r, o) >= 0) return false;
    const a = i.x, l = r.x, c = o.x, h = i.y, f = r.y, m = o.y, _ = a < l ? a < c ? a : c : l < c ? l : c, y = h < f ? h < m ? h : m : f < m ? f : m, g = a > l ? a > c ? a : c : l > c ? l : c, x = h > f ? h > m ? h : m : f > m ? f : m, v = $h(_, y, e, t, n), E = $h(g, x, e, t, n);
    let T = s.prevZ, M = s.nextZ;
    for (; T && T.z >= v && M && M.z <= E; ) {
      if (T.x >= _ && T.x <= g && T.y >= y && T.y <= x && T !== i && T !== o && mo(a, h, l, f, c, m, T.x, T.y) && rn(T.prev, T, T.next) >= 0 || (T = T.prevZ, M.x >= _ && M.x <= g && M.y >= y && M.y <= x && M !== i && M !== o && mo(a, h, l, f, c, m, M.x, M.y) && rn(M.prev, M, M.next) >= 0)) return false;
      M = M.nextZ;
    }
    for (; T && T.z >= v; ) {
      if (T.x >= _ && T.x <= g && T.y >= y && T.y <= x && T !== i && T !== o && mo(a, h, l, f, c, m, T.x, T.y) && rn(T.prev, T, T.next) >= 0) return false;
      T = T.prevZ;
    }
    for (; M && M.z <= E; ) {
      if (M.x >= _ && M.x <= g && M.y >= y && M.y <= x && M !== i && M !== o && mo(a, h, l, f, c, m, M.x, M.y) && rn(M.prev, M, M.next) >= 0) return false;
      M = M.nextZ;
    }
    return true;
  }
  function by(s, e, t) {
    let n = s;
    do {
      const i = n.prev, r = n.next.next;
      !Bc(i, r) && hg(i, n, n.next, r) && Qa(i, r) && Qa(r, i) && (e.push(i.i / t | 0), e.push(n.i / t | 0), e.push(r.i / t | 0), el(n), el(n.next), n = s = r), n = n.next;
    } while (n !== s);
    return Os(n);
  }
  function Sy(s, e, t, n, i, r) {
    let o = s;
    do {
      let a = o.next.next;
      for (; a !== o.prev; ) {
        if (o.i !== a.i && Dy(o, a)) {
          let l = fg(o, a);
          o = Os(o, o.next), l = Os(l, l.next), Ja(o, e, t, n, i, r, 0), Ja(l, e, t, n, i, r, 0);
          return;
        }
        a = a.next;
      }
      o = o.next;
    } while (o !== s);
  }
  function My(s, e, t, n) {
    const i = [];
    let r, o, a, l, c;
    for (r = 0, o = e.length; r < o; r++) a = e[r] * n, l = r < o - 1 ? e[r + 1] * n : s.length, c = ug(s, a, l, n, false), c === c.next && (c.steiner = true), i.push(Py(c));
    for (i.sort(Ty), r = 0; r < i.length; r++) t = Ey(i[r], t);
    return t;
  }
  function Ty(s, e) {
    return s.x - e.x;
  }
  function Ey(s, e) {
    const t = wy(s, e);
    if (!t) return e;
    const n = fg(t, s);
    return Os(n, n.next), Os(t, t.next);
  }
  function wy(s, e) {
    let t = e, n = -1 / 0, i;
    const r = s.x, o = s.y;
    do {
      if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
        const m = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
        if (m <= r && m > n && (n = m, i = t.x < t.next.x ? t : t.next, m === r)) return i;
      }
      t = t.next;
    } while (t !== e);
    if (!i) return null;
    const a = i, l = i.x, c = i.y;
    let h = 1 / 0, f;
    t = i;
    do
      r >= t.x && t.x >= l && r !== t.x && mo(o < c ? r : n, o, l, c, o < c ? n : r, o, t.x, t.y) && (f = Math.abs(o - t.y) / (r - t.x), Qa(t, s) && (f < h || f === h && (t.x > i.x || t.x === i.x && Ay(i, t))) && (i = t, h = f)), t = t.next;
    while (t !== a);
    return i;
  }
  function Ay(s, e) {
    return rn(s.prev, s, e.prev) < 0 && rn(e.next, s, s.next) < 0;
  }
  function Cy(s, e, t, n) {
    let i = s;
    do
      i.z === 0 && (i.z = $h(i.x, i.y, e, t, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
    while (i !== s);
    i.prevZ.nextZ = null, i.prevZ = null, Ry(i);
  }
  function Ry(s) {
    let e, t, n, i, r, o, a, l, c = 1;
    do {
      for (t = s, s = null, r = null, o = 0; t; ) {
        for (o++, n = t, a = 0, e = 0; e < c && (a++, n = n.nextZ, !!n); e++) ;
        for (l = c; a > 0 || l > 0 && n; ) a !== 0 && (l === 0 || !n || t.z <= n.z) ? (i = t, t = t.nextZ, a--) : (i = n, n = n.nextZ, l--), r ? r.nextZ = i : s = i, i.prevZ = r, r = i;
        t = n;
      }
      r.nextZ = null, c *= 2;
    } while (o > 1);
    return s;
  }
  function $h(s, e, t, n, i) {
    return s = (s - t) * i | 0, e = (e - n) * i | 0, s = (s | s << 8) & 16711935, s = (s | s << 4) & 252645135, s = (s | s << 2) & 858993459, s = (s | s << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, s | e << 1;
  }
  function Py(s) {
    let e = s, t = s;
    do
      (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
    while (e !== s);
    return t;
  }
  function mo(s, e, t, n, i, r, o, a) {
    return (i - o) * (e - a) >= (s - o) * (r - a) && (s - o) * (n - a) >= (t - o) * (e - a) && (t - o) * (r - a) >= (i - o) * (n - a);
  }
  function Dy(s, e) {
    return s.next.i !== e.i && s.prev.i !== e.i && !Ly(s, e) && (Qa(s, e) && Qa(e, s) && Iy(s, e) && (rn(s.prev, s, e.prev) || rn(s, e.prev, e)) || Bc(s, e) && rn(s.prev, s, s.next) > 0 && rn(e.prev, e, e.next) > 0);
  }
  function rn(s, e, t) {
    return (e.y - s.y) * (t.x - e.x) - (e.x - s.x) * (t.y - e.y);
  }
  function Bc(s, e) {
    return s.x === e.x && s.y === e.y;
  }
  function hg(s, e, t, n) {
    const i = Zl(rn(s, e, t)), r = Zl(rn(s, e, n)), o = Zl(rn(t, n, s)), a = Zl(rn(t, n, e));
    return !!(i !== r && o !== a || i === 0 && Kl(s, t, e) || r === 0 && Kl(s, n, e) || o === 0 && Kl(t, s, n) || a === 0 && Kl(t, e, n));
  }
  function Kl(s, e, t) {
    return e.x <= Math.max(s.x, t.x) && e.x >= Math.min(s.x, t.x) && e.y <= Math.max(s.y, t.y) && e.y >= Math.min(s.y, t.y);
  }
  function Zl(s) {
    return s > 0 ? 1 : s < 0 ? -1 : 0;
  }
  function Ly(s, e) {
    let t = s;
    do {
      if (t.i !== s.i && t.next.i !== s.i && t.i !== e.i && t.next.i !== e.i && hg(t, t.next, s, e)) return true;
      t = t.next;
    } while (t !== s);
    return false;
  }
  function Qa(s, e) {
    return rn(s.prev, s, s.next) < 0 ? rn(s, e, s.next) >= 0 && rn(s, s.prev, e) >= 0 : rn(s, e, s.prev) < 0 || rn(s, s.next, e) < 0;
  }
  function Iy(s, e) {
    let t = s, n = false;
    const i = (s.x + e.x) / 2, r = (s.y + e.y) / 2;
    do
      t.y > r != t.next.y > r && t.next.y !== t.y && i < (t.next.x - t.x) * (r - t.y) / (t.next.y - t.y) + t.x && (n = !n), t = t.next;
    while (t !== s);
    return n;
  }
  function fg(s, e) {
    const t = new Kh(s.i, s.x, s.y), n = new Kh(e.i, e.x, e.y), i = s.next, r = e.prev;
    return s.next = e, e.prev = s, t.next = i, i.prev = t, n.next = t, t.prev = n, r.next = n, n.prev = r, n;
  }
  function pp(s, e, t, n) {
    const i = new Kh(s, e, t);
    return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
  }
  function el(s) {
    s.next.prev = s.prev, s.prev.next = s.next, s.prevZ && (s.prevZ.nextZ = s.nextZ), s.nextZ && (s.nextZ.prevZ = s.prevZ);
  }
  function Kh(s, e, t) {
    this.i = s, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
  }
  function Ny(s, e, t, n) {
    let i = 0;
    for (let r = e, o = t - n; r < t; r += n) i += (s[o] - s[r]) * (s[r + 1] + s[o + 1]), o = r;
    return i;
  }
  class So {
    static area(e) {
      const t = e.length;
      let n = 0;
      for (let i = t - 1, r = 0; r < t; i = r++) n += e[i].x * e[r].y - e[r].x * e[i].y;
      return n * 0.5;
    }
    static isClockWise(e) {
      return So.area(e) < 0;
    }
    static triangulateShape(e, t) {
      const n = [], i = [], r = [];
      mp(e), gp(n, e);
      let o = e.length;
      t.forEach(mp);
      for (let l = 0; l < t.length; l++) i.push(o), o += t[l].length, gp(n, t[l]);
      const a = vy.triangulate(n, i);
      for (let l = 0; l < a.length; l += 3) r.push(a.slice(l, l + 3));
      return r;
    }
  }
  function mp(s) {
    const e = s.length;
    e > 2 && s[e - 1].equals(s[0]) && s.pop();
  }
  function gp(s, e) {
    for (let t = 0; t < e.length; t++) s.push(e[t].x), s.push(e[t].y);
  }
  class Ff extends si {
    constructor(e = new hc([
      new Se(0.5, 0.5),
      new Se(-0.5, 0.5),
      new Se(-0.5, -0.5),
      new Se(0.5, -0.5)
    ]), t = {}) {
      super(), this.type = "ExtrudeGeometry", this.parameters = {
        shapes: e,
        options: t
      }, e = Array.isArray(e) ? e : [
        e
      ];
      const n = this, i = [], r = [];
      for (let a = 0, l = e.length; a < l; a++) {
        const c = e[a];
        o(c);
      }
      this.setAttribute("position", new Ln(i, 3)), this.setAttribute("uv", new Ln(r, 2)), this.computeVertexNormals();
      function o(a) {
        const l = [], c = t.curveSegments !== void 0 ? t.curveSegments : 12, h = t.steps !== void 0 ? t.steps : 1, f = t.depth !== void 0 ? t.depth : 1;
        let m = t.bevelEnabled !== void 0 ? t.bevelEnabled : true, _ = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, y = t.bevelSize !== void 0 ? t.bevelSize : _ - 0.1, g = t.bevelOffset !== void 0 ? t.bevelOffset : 0, x = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
        const v = t.extrudePath, E = t.UVGenerator !== void 0 ? t.UVGenerator : Uy;
        let T, M = false, P, R, d, N;
        v && (T = v.getSpacedPoints(h), M = true, m = false, P = v.computeFrenetFrames(h, false), R = new V(), d = new V(), N = new V()), m || (x = 0, _ = 0, y = 0, g = 0);
        const w = a.extractPoints(c);
        let D = w.shape;
        const B = w.holes;
        if (!So.isClockWise(D)) {
          D = D.reverse();
          for (let _e = 0, ge = B.length; _e < ge; _e++) {
            const k = B[_e];
            So.isClockWise(k) && (B[_e] = k.reverse());
          }
        }
        const G = So.triangulateShape(D, B), Q = D;
        for (let _e = 0, ge = B.length; _e < ge; _e++) {
          const k = B[_e];
          D = D.concat(k);
        }
        function ue(_e, ge, k) {
          return ge || console.error("THREE.ExtrudeGeometry: vec does not exist"), _e.clone().addScaledVector(ge, k);
        }
        const te = D.length, he = G.length;
        function ie(_e, ge, k) {
          let Ke, ye, ze;
          const Ee = _e.x - ge.x, st = _e.y - ge.y, Ue = k.x - _e.x, O = k.y - _e.y, I = Ee * Ee + st * st, $ = Ee * O - st * Ue;
          if (Math.abs($) > Number.EPSILON) {
            const fe = Math.sqrt(I), K = Math.sqrt(Ue * Ue + O * O), le = ge.x - st / fe, je = ge.y + Ee / fe, Re = k.x - O / K, Ge = k.y + Ue / K, vt = ((Re - le) * O - (Ge - je) * Ue) / (Ee * O - st * Ue);
            Ke = le + Ee * vt - _e.x, ye = je + st * vt - _e.y;
            const we = Ke * Ke + ye * ye;
            if (we <= 2) return new Se(Ke, ye);
            ze = Math.sqrt(we / 2);
          } else {
            let fe = false;
            Ee > Number.EPSILON ? Ue > Number.EPSILON && (fe = true) : Ee < -Number.EPSILON ? Ue < -Number.EPSILON && (fe = true) : Math.sign(st) === Math.sign(O) && (fe = true), fe ? (Ke = -st, ye = Ee, ze = Math.sqrt(I)) : (Ke = Ee, ye = st, ze = Math.sqrt(I / 2));
          }
          return new Se(Ke / ze, ye / ze);
        }
        const Me = [];
        for (let _e = 0, ge = Q.length, k = ge - 1, Ke = _e + 1; _e < ge; _e++, k++, Ke++) k === ge && (k = 0), Ke === ge && (Ke = 0), Me[_e] = ie(Q[_e], Q[k], Q[Ke]);
        const Ce = [];
        let Le, Je = Me.concat();
        for (let _e = 0, ge = B.length; _e < ge; _e++) {
          const k = B[_e];
          Le = [];
          for (let Ke = 0, ye = k.length, ze = ye - 1, Ee = Ke + 1; Ke < ye; Ke++, ze++, Ee++) ze === ye && (ze = 0), Ee === ye && (Ee = 0), Le[Ke] = ie(k[Ke], k[ze], k[Ee]);
          Ce.push(Le), Je = Je.concat(Le);
        }
        for (let _e = 0; _e < x; _e++) {
          const ge = _e / x, k = _ * Math.cos(ge * Math.PI / 2), Ke = y * Math.sin(ge * Math.PI / 2) + g;
          for (let ye = 0, ze = Q.length; ye < ze; ye++) {
            const Ee = ue(Q[ye], Me[ye], Ke);
            Te(Ee.x, Ee.y, -k);
          }
          for (let ye = 0, ze = B.length; ye < ze; ye++) {
            const Ee = B[ye];
            Le = Ce[ye];
            for (let st = 0, Ue = Ee.length; st < Ue; st++) {
              const O = ue(Ee[st], Le[st], Ke);
              Te(O.x, O.y, -k);
            }
          }
        }
        const dt = y + g;
        for (let _e = 0; _e < te; _e++) {
          const ge = m ? ue(D[_e], Je[_e], dt) : D[_e];
          M ? (d.copy(P.normals[0]).multiplyScalar(ge.x), R.copy(P.binormals[0]).multiplyScalar(ge.y), N.copy(T[0]).add(d).add(R), Te(N.x, N.y, N.z)) : Te(ge.x, ge.y, 0);
        }
        for (let _e = 1; _e <= h; _e++) for (let ge = 0; ge < te; ge++) {
          const k = m ? ue(D[ge], Je[ge], dt) : D[ge];
          M ? (d.copy(P.normals[_e]).multiplyScalar(k.x), R.copy(P.binormals[_e]).multiplyScalar(k.y), N.copy(T[_e]).add(d).add(R), Te(N.x, N.y, N.z)) : Te(k.x, k.y, f / h * _e);
        }
        for (let _e = x - 1; _e >= 0; _e--) {
          const ge = _e / x, k = _ * Math.cos(ge * Math.PI / 2), Ke = y * Math.sin(ge * Math.PI / 2) + g;
          for (let ye = 0, ze = Q.length; ye < ze; ye++) {
            const Ee = ue(Q[ye], Me[ye], Ke);
            Te(Ee.x, Ee.y, f + k);
          }
          for (let ye = 0, ze = B.length; ye < ze; ye++) {
            const Ee = B[ye];
            Le = Ce[ye];
            for (let st = 0, Ue = Ee.length; st < Ue; st++) {
              const O = ue(Ee[st], Le[st], Ke);
              M ? Te(O.x, O.y + T[h - 1].y, T[h - 1].x + k) : Te(O.x, O.y, f + k);
            }
          }
        }
        ce(), ve();
        function ce() {
          const _e = i.length / 3;
          if (m) {
            let ge = 0, k = te * ge;
            for (let Ke = 0; Ke < he; Ke++) {
              const ye = G[Ke];
              Ye(ye[2] + k, ye[1] + k, ye[0] + k);
            }
            ge = h + x * 2, k = te * ge;
            for (let Ke = 0; Ke < he; Ke++) {
              const ye = G[Ke];
              Ye(ye[0] + k, ye[1] + k, ye[2] + k);
            }
          } else {
            for (let ge = 0; ge < he; ge++) {
              const k = G[ge];
              Ye(k[2], k[1], k[0]);
            }
            for (let ge = 0; ge < he; ge++) {
              const k = G[ge];
              Ye(k[0] + te * h, k[1] + te * h, k[2] + te * h);
            }
          }
          n.addGroup(_e, i.length / 3 - _e, 0);
        }
        function ve() {
          const _e = i.length / 3;
          let ge = 0;
          qe(Q, ge), ge += Q.length;
          for (let k = 0, Ke = B.length; k < Ke; k++) {
            const ye = B[k];
            qe(ye, ge), ge += ye.length;
          }
          n.addGroup(_e, i.length / 3 - _e, 1);
        }
        function qe(_e, ge) {
          let k = _e.length;
          for (; --k >= 0; ) {
            const Ke = k;
            let ye = k - 1;
            ye < 0 && (ye = _e.length - 1);
            for (let ze = 0, Ee = h + x * 2; ze < Ee; ze++) {
              const st = te * ze, Ue = te * (ze + 1), O = ge + Ke + st, I = ge + ye + st, $ = ge + ye + Ue, fe = ge + Ke + Ue;
              lt(O, I, $, fe);
            }
          }
        }
        function Te(_e, ge, k) {
          l.push(_e), l.push(ge), l.push(k);
        }
        function Ye(_e, ge, k) {
          Fe(_e), Fe(ge), Fe(k);
          const Ke = i.length / 3, ye = E.generateTopUV(n, i, Ke - 3, Ke - 2, Ke - 1);
          Nt(ye[0]), Nt(ye[1]), Nt(ye[2]);
        }
        function lt(_e, ge, k, Ke) {
          Fe(_e), Fe(ge), Fe(Ke), Fe(ge), Fe(k), Fe(Ke);
          const ye = i.length / 3, ze = E.generateSideWallUV(n, i, ye - 6, ye - 3, ye - 2, ye - 1);
          Nt(ze[0]), Nt(ze[1]), Nt(ze[3]), Nt(ze[1]), Nt(ze[2]), Nt(ze[3]);
        }
        function Fe(_e) {
          i.push(l[_e * 3 + 0]), i.push(l[_e * 3 + 1]), i.push(l[_e * 3 + 2]);
        }
        function Nt(_e) {
          r.push(_e.x), r.push(_e.y);
        }
      }
    }
    copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
    }
    toJSON() {
      const e = super.toJSON(), t = this.parameters.shapes, n = this.parameters.options;
      return Oy(t, n, e);
    }
    static fromJSON(e, t) {
      const n = [];
      for (let r = 0, o = e.shapes.length; r < o; r++) {
        const a = t[e.shapes[r]];
        n.push(a);
      }
      const i = e.options.extrudePath;
      return i !== void 0 && (e.options.extrudePath = new Yh[i.type]().fromJSON(i)), new Ff(n, e.options);
    }
  }
  const Uy = {
    generateTopUV: function(s, e, t, n, i) {
      const r = e[t * 3], o = e[t * 3 + 1], a = e[n * 3], l = e[n * 3 + 1], c = e[i * 3], h = e[i * 3 + 1];
      return [
        new Se(r, o),
        new Se(a, l),
        new Se(c, h)
      ];
    },
    generateSideWallUV: function(s, e, t, n, i, r) {
      const o = e[t * 3], a = e[t * 3 + 1], l = e[t * 3 + 2], c = e[n * 3], h = e[n * 3 + 1], f = e[n * 3 + 2], m = e[i * 3], _ = e[i * 3 + 1], y = e[i * 3 + 2], g = e[r * 3], x = e[r * 3 + 1], v = e[r * 3 + 2];
      return Math.abs(a - h) < Math.abs(o - c) ? [
        new Se(o, 1 - l),
        new Se(c, 1 - f),
        new Se(m, 1 - y),
        new Se(g, 1 - v)
      ] : [
        new Se(a, 1 - l),
        new Se(h, 1 - f),
        new Se(_, 1 - y),
        new Se(x, 1 - v)
      ];
    }
  };
  function Oy(s, e, t) {
    if (t.shapes = [], Array.isArray(s)) for (let n = 0, i = s.length; n < i; n++) {
      const r = s[n];
      t.shapes.push(r.uuid);
    }
    else t.shapes.push(s.uuid);
    return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
  }
  class hl extends si {
    constructor(e = 1, t = 1, n = 1, i = 1) {
      super(), this.type = "PlaneGeometry", this.parameters = {
        width: e,
        height: t,
        widthSegments: n,
        heightSegments: i
      };
      const r = e / 2, o = t / 2, a = Math.floor(n), l = Math.floor(i), c = a + 1, h = l + 1, f = e / a, m = t / l, _ = [], y = [], g = [], x = [];
      for (let v = 0; v < h; v++) {
        const E = v * m - o;
        for (let T = 0; T < c; T++) {
          const M = T * f - r;
          y.push(M, -E, 0), g.push(0, 0, 1), x.push(T / a), x.push(1 - v / l);
        }
      }
      for (let v = 0; v < l; v++) for (let E = 0; E < a; E++) {
        const T = E + c * v, M = E + c * (v + 1), P = E + 1 + c * (v + 1), R = E + 1 + c * v;
        _.push(T, M, R), _.push(M, P, R);
      }
      this.setIndex(_), this.setAttribute("position", new Ln(y, 3)), this.setAttribute("normal", new Ln(g, 3)), this.setAttribute("uv", new Ln(x, 2));
    }
    copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
    }
    static fromJSON(e) {
      return new hl(e.width, e.height, e.widthSegments, e.heightSegments);
    }
  }
  class kf extends si {
    constructor(e = 1, t = 32, n = 16, i = 0, r = Math.PI * 2, o = 0, a = Math.PI) {
      super(), this.type = "SphereGeometry", this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: n,
        phiStart: i,
        phiLength: r,
        thetaStart: o,
        thetaLength: a
      }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
      const l = Math.min(o + a, Math.PI);
      let c = 0;
      const h = [], f = new V(), m = new V(), _ = [], y = [], g = [], x = [];
      for (let v = 0; v <= n; v++) {
        const E = [], T = v / n;
        let M = 0;
        v === 0 && o === 0 ? M = 0.5 / t : v === n && l === Math.PI && (M = -0.5 / t);
        for (let P = 0; P <= t; P++) {
          const R = P / t;
          f.x = -e * Math.cos(i + R * r) * Math.sin(o + T * a), f.y = e * Math.cos(o + T * a), f.z = e * Math.sin(i + R * r) * Math.sin(o + T * a), y.push(f.x, f.y, f.z), m.copy(f).normalize(), g.push(m.x, m.y, m.z), x.push(R + M, 1 - T), E.push(c++);
        }
        h.push(E);
      }
      for (let v = 0; v < n; v++) for (let E = 0; E < t; E++) {
        const T = h[v][E + 1], M = h[v][E], P = h[v + 1][E], R = h[v + 1][E + 1];
        (v !== 0 || o > 0) && _.push(T, M, R), (v !== n - 1 || l < Math.PI) && _.push(M, P, R);
      }
      this.setIndex(_), this.setAttribute("position", new Ln(y, 3)), this.setAttribute("normal", new Ln(g, 3)), this.setAttribute("uv", new Ln(x, 2));
    }
    copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
    }
    static fromJSON(e) {
      return new kf(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
    }
  }
  class Yo extends ji {
    constructor(e) {
      super(), this.isMeshStandardMaterial = true, this.type = "MeshStandardMaterial", this.defines = {
        STANDARD: ""
      }, this.color = new it(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new it(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Wm, this.normalScale = new Se(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Zi(), this.envMapIntensity = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.defines = {
        STANDARD: ""
      }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
    }
  }
  class tr extends Yo {
    constructor(e) {
      super(), this.isMeshPhysicalMaterial = true, this.defines = {
        STANDARD: "",
        PHYSICAL: ""
      }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Se(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
        get: function() {
          return xt(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
        },
        set: function(t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        }
      }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [
        100,
        400
      ], this.iridescenceThicknessMap = null, this.sheenColor = new it(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new it(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new it(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
    }
    get anisotropy() {
      return this._anisotropy;
    }
    set anisotropy(e) {
      this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
    }
    get clearcoat() {
      return this._clearcoat;
    }
    set clearcoat(e) {
      this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
    }
    get iridescence() {
      return this._iridescence;
    }
    set iridescence(e) {
      this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
    }
    get dispersion() {
      return this._dispersion;
    }
    set dispersion(e) {
      this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e;
    }
    get sheen() {
      return this._sheen;
    }
    set sheen(e) {
      this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
    }
    get transmission() {
      return this._transmission;
    }
    set transmission(e) {
      this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
    }
    copy(e) {
      return super.copy(e), this.defines = {
        STANDARD: "",
        PHYSICAL: ""
      }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [
        ...e.iridescenceThicknessRange
      ], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
    }
  }
  class Fy extends ji {
    constructor(e) {
      super(), this.isMeshDepthMaterial = true, this.type = "MeshDepthMaterial", this.depthPacking = Y0, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
    }
  }
  class ky extends ji {
    constructor(e) {
      super(), this.isMeshDistanceMaterial = true, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
    }
  }
  function Jl(s, e, t) {
    return !s || !t && s.constructor === e ? s : typeof e.BYTES_PER_ELEMENT == "number" ? new e(s) : Array.prototype.slice.call(s);
  }
  function By(s) {
    return ArrayBuffer.isView(s) && !(s instanceof DataView);
  }
  function zy(s) {
    function e(i, r) {
      return s[i] - s[r];
    }
    const t = s.length, n = new Array(t);
    for (let i = 0; i !== t; ++i) n[i] = i;
    return n.sort(e), n;
  }
  function _p(s, e, t) {
    const n = s.length, i = new s.constructor(n);
    for (let r = 0, o = 0; o !== n; ++r) {
      const a = t[r] * e;
      for (let l = 0; l !== e; ++l) i[o++] = s[a + l];
    }
    return i;
  }
  function dg(s, e, t, n) {
    let i = 1, r = s[0];
    for (; r !== void 0 && r[n] === void 0; ) r = s[i++];
    if (r === void 0) return;
    let o = r[n];
    if (o !== void 0) if (Array.isArray(o)) do
      o = r[n], o !== void 0 && (e.push(r.time), t.push.apply(t, o)), r = s[i++];
    while (r !== void 0);
    else if (o.toArray !== void 0) do
      o = r[n], o !== void 0 && (e.push(r.time), o.toArray(t, t.length)), r = s[i++];
    while (r !== void 0);
    else do
      o = r[n], o !== void 0 && (e.push(r.time), t.push(o)), r = s[i++];
    while (r !== void 0);
  }
  class fl {
    constructor(e, t, n, i) {
      this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
    }
    evaluate(e) {
      const t = this.parameterPositions;
      let n = this._cachedIndex, i = t[n], r = t[n - 1];
      n: {
        e: {
          let o;
          t: {
            i: if (!(e < i)) {
              for (let a = n + 2; ; ) {
                if (i === void 0) {
                  if (e < r) break i;
                  return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
                }
                if (n === a) break;
                if (r = i, i = t[++n], e < i) break e;
              }
              o = t.length;
              break t;
            }
            if (!(e >= r)) {
              const a = t[1];
              e < a && (n = 2, r = a);
              for (let l = n - 2; ; ) {
                if (r === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                if (n === l) break;
                if (i = r, r = t[--n - 1], e >= r) break e;
              }
              o = n, n = 0;
              break t;
            }
            break n;
          }
          for (; n < o; ) {
            const a = n + o >>> 1;
            e < t[a] ? o = a : n = a + 1;
          }
          if (i = t[n], r = t[n - 1], r === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
          if (i === void 0) return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
        }
        this._cachedIndex = n, this.intervalChanged_(n, r, i);
      }
      return this.interpolate_(n, r, e, i);
    }
    getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(e) {
      const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i;
      for (let o = 0; o !== i; ++o) t[o] = n[r + o];
      return t;
    }
    interpolate_() {
      throw new Error("call to abstract method");
    }
    intervalChanged_() {
    }
  }
  class Hy extends fl {
    constructor(e, t, n, i) {
      super(e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
        endingStart: Pd,
        endingEnd: Pd
      };
    }
    intervalChanged_(e, t, n) {
      const i = this.parameterPositions;
      let r = e - 2, o = e + 1, a = i[r], l = i[o];
      if (a === void 0) switch (this.getSettings_().endingStart) {
        case Dd:
          r = e, a = 2 * t - n;
          break;
        case Ld:
          r = i.length - 2, a = t + i[r] - i[r + 1];
          break;
        default:
          r = e, a = n;
      }
      if (l === void 0) switch (this.getSettings_().endingEnd) {
        case Dd:
          o = e, l = 2 * n - t;
          break;
        case Ld:
          o = 1, l = n + i[1] - i[0];
          break;
        default:
          o = e - 1, l = t;
      }
      const c = (n - t) * 0.5, h = this.valueSize;
      this._weightPrev = c / (t - a), this._weightNext = c / (l - n), this._offsetPrev = r * h, this._offsetNext = o * h;
    }
    interpolate_(e, t, n, i) {
      const r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = e * a, c = l - a, h = this._offsetPrev, f = this._offsetNext, m = this._weightPrev, _ = this._weightNext, y = (n - t) / (i - t), g = y * y, x = g * y, v = -m * x + 2 * m * g - m * y, E = (1 + m) * x + (-1.5 - 2 * m) * g + (-0.5 + m) * y + 1, T = (-1 - _) * x + (1.5 + _) * g + 0.5 * y, M = _ * x - _ * g;
      for (let P = 0; P !== a; ++P) r[P] = v * o[h + P] + E * o[c + P] + T * o[l + P] + M * o[f + P];
      return r;
    }
  }
  class Vy extends fl {
    constructor(e, t, n, i) {
      super(e, t, n, i);
    }
    interpolate_(e, t, n, i) {
      const r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = e * a, c = l - a, h = (n - t) / (i - t), f = 1 - h;
      for (let m = 0; m !== a; ++m) r[m] = o[c + m] * f + o[l + m] * h;
      return r;
    }
  }
  class Gy extends fl {
    constructor(e, t, n, i) {
      super(e, t, n, i);
    }
    interpolate_(e) {
      return this.copySampleValue_(e - 1);
    }
  }
  class nr {
    constructor(e, t, n, i) {
      if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
      this.name = e, this.times = Jl(t, this.TimeBufferType), this.values = Jl(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation);
    }
    static toJSON(e) {
      const t = e.constructor;
      let n;
      if (t.toJSON !== this.toJSON) n = t.toJSON(e);
      else {
        n = {
          name: e.name,
          times: Jl(e.times, Array),
          values: Jl(e.values, Array)
        };
        const i = e.getInterpolation();
        i !== e.DefaultInterpolation && (n.interpolation = i);
      }
      return n.type = e.ValueTypeName, n;
    }
    InterpolantFactoryMethodDiscrete(e) {
      return new Gy(this.times, this.values, this.getValueSize(), e);
    }
    InterpolantFactoryMethodLinear(e) {
      return new Vy(this.times, this.values, this.getValueSize(), e);
    }
    InterpolantFactoryMethodSmooth(e) {
      return new Hy(this.times, this.values, this.getValueSize(), e);
    }
    setInterpolation(e) {
      let t;
      switch (e) {
        case $a:
          t = this.InterpolantFactoryMethodDiscrete;
          break;
        case Ka:
          t = this.InterpolantFactoryMethodLinear;
          break;
        case lu:
          t = this.InterpolantFactoryMethodSmooth;
          break;
      }
      if (t === void 0) {
        const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
        if (this.createInterpolant === void 0) if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(n);
        return console.warn("THREE.KeyframeTrack:", n), this;
      }
      return this.createInterpolant = t, this;
    }
    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return $a;
        case this.InterpolantFactoryMethodLinear:
          return Ka;
        case this.InterpolantFactoryMethodSmooth:
          return lu;
      }
    }
    getValueSize() {
      return this.values.length / this.times.length;
    }
    shift(e) {
      if (e !== 0) {
        const t = this.times;
        for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
      }
      return this;
    }
    scale(e) {
      if (e !== 1) {
        const t = this.times;
        for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
      }
      return this;
    }
    trim(e, t) {
      const n = this.times, i = n.length;
      let r = 0, o = i - 1;
      for (; r !== i && n[r] < e; ) ++r;
      for (; o !== -1 && n[o] > t; ) --o;
      if (++o, r !== 0 || o !== i) {
        r >= o && (o = Math.max(o, 1), r = o - 1);
        const a = this.getValueSize();
        this.times = n.slice(r, o), this.values = this.values.slice(r * a, o * a);
      }
      return this;
    }
    validate() {
      let e = true;
      const t = this.getValueSize();
      t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = false);
      const n = this.times, i = this.values, r = n.length;
      r === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = false);
      let o = null;
      for (let a = 0; a !== r; a++) {
        const l = n[a];
        if (typeof l == "number" && isNaN(l)) {
          console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), e = false;
          break;
        }
        if (o !== null && o > l) {
          console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o), e = false;
          break;
        }
        o = l;
      }
      if (i !== void 0 && By(i)) for (let a = 0, l = i.length; a !== l; ++a) {
        const c = i[a];
        if (isNaN(c)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c), e = false;
          break;
        }
      }
      return e;
    }
    optimize() {
      const e = this.times.slice(), t = this.values.slice(), n = this.getValueSize(), i = this.getInterpolation() === lu, r = e.length - 1;
      let o = 1;
      for (let a = 1; a < r; ++a) {
        let l = false;
        const c = e[a], h = e[a + 1];
        if (c !== h && (a !== 1 || c !== e[0])) if (i) l = true;
        else {
          const f = a * n, m = f - n, _ = f + n;
          for (let y = 0; y !== n; ++y) {
            const g = t[f + y];
            if (g !== t[m + y] || g !== t[_ + y]) {
              l = true;
              break;
            }
          }
        }
        if (l) {
          if (a !== o) {
            e[o] = e[a];
            const f = a * n, m = o * n;
            for (let _ = 0; _ !== n; ++_) t[m + _] = t[f + _];
          }
          ++o;
        }
      }
      if (r > 0) {
        e[o] = e[r];
        for (let a = r * n, l = o * n, c = 0; c !== n; ++c) t[l + c] = t[a + c];
        ++o;
      }
      return o !== e.length ? (this.times = e.slice(0, o), this.values = t.slice(0, o * n)) : (this.times = e, this.values = t), this;
    }
    clone() {
      const e = this.times.slice(), t = this.values.slice(), n = this.constructor, i = new n(this.name, e, t);
      return i.createInterpolant = this.createInterpolant, i;
    }
  }
  nr.prototype.TimeBufferType = Float32Array;
  nr.prototype.ValueBufferType = Float32Array;
  nr.prototype.DefaultInterpolation = Ka;
  class jo extends nr {
    constructor(e, t, n) {
      super(e, t, n);
    }
  }
  jo.prototype.ValueTypeName = "bool";
  jo.prototype.ValueBufferType = Array;
  jo.prototype.DefaultInterpolation = $a;
  jo.prototype.InterpolantFactoryMethodLinear = void 0;
  jo.prototype.InterpolantFactoryMethodSmooth = void 0;
  class pg extends nr {
  }
  pg.prototype.ValueTypeName = "color";
  class Uo extends nr {
  }
  Uo.prototype.ValueTypeName = "number";
  class Wy extends fl {
    constructor(e, t, n, i) {
      super(e, t, n, i);
    }
    interpolate_(e, t, n, i) {
      const r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = (n - t) / (i - t);
      let c = e * a;
      for (let h = c + a; c !== h; c += 4) rs.slerpFlat(r, 0, o, c - a, o, c, l);
      return r;
    }
  }
  class Oo extends nr {
    InterpolantFactoryMethodLinear(e) {
      return new Wy(this.times, this.values, this.getValueSize(), e);
    }
  }
  Oo.prototype.ValueTypeName = "quaternion";
  Oo.prototype.InterpolantFactoryMethodSmooth = void 0;
  class $o extends nr {
    constructor(e, t, n) {
      super(e, t, n);
    }
  }
  $o.prototype.ValueTypeName = "string";
  $o.prototype.ValueBufferType = Array;
  $o.prototype.DefaultInterpolation = $a;
  $o.prototype.InterpolantFactoryMethodLinear = void 0;
  $o.prototype.InterpolantFactoryMethodSmooth = void 0;
  class Fo extends nr {
  }
  Fo.prototype.ValueTypeName = "vector";
  class Xy {
    constructor(e = "", t = -1, n = [], i = X0) {
      this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = wi(), this.duration < 0 && this.resetDuration();
    }
    static parse(e) {
      const t = [], n = e.tracks, i = 1 / (e.fps || 1);
      for (let o = 0, a = n.length; o !== a; ++o) t.push(Yy(n[o]).scale(i));
      const r = new this(e.name, e.duration, t, e.blendMode);
      return r.uuid = e.uuid, r;
    }
    static toJSON(e) {
      const t = [], n = e.tracks, i = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode
      };
      for (let r = 0, o = n.length; r !== o; ++r) t.push(nr.toJSON(n[r]));
      return i;
    }
    static CreateFromMorphTargetSequence(e, t, n, i) {
      const r = t.length, o = [];
      for (let a = 0; a < r; a++) {
        let l = [], c = [];
        l.push((a + r - 1) % r, a, (a + 1) % r), c.push(0, 1, 0);
        const h = zy(l);
        l = _p(l, 1, h), c = _p(c, 1, h), !i && l[0] === 0 && (l.push(r), c.push(c[0])), o.push(new Uo(".morphTargetInfluences[" + t[a].name + "]", l, c).scale(1 / n));
      }
      return new this(e, -1, o);
    }
    static findByName(e, t) {
      let n = e;
      if (!Array.isArray(e)) {
        const i = e;
        n = i.geometry && i.geometry.animations || i.animations;
      }
      for (let i = 0; i < n.length; i++) if (n[i].name === t) return n[i];
      return null;
    }
    static CreateClipsFromMorphTargetSequences(e, t, n) {
      const i = {}, r = /^([\w-]*?)([\d]+)$/;
      for (let a = 0, l = e.length; a < l; a++) {
        const c = e[a], h = c.name.match(r);
        if (h && h.length > 1) {
          const f = h[1];
          let m = i[f];
          m || (i[f] = m = []), m.push(c);
        }
      }
      const o = [];
      for (const a in i) o.push(this.CreateFromMorphTargetSequence(a, i[a], t, n));
      return o;
    }
    static parseAnimation(e, t) {
      if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
      const n = function(f, m, _, y, g) {
        if (_.length !== 0) {
          const x = [], v = [];
          dg(_, x, v, y), x.length !== 0 && g.push(new f(m, x, v));
        }
      }, i = [], r = e.name || "default", o = e.fps || 30, a = e.blendMode;
      let l = e.length || -1;
      const c = e.hierarchy || [];
      for (let f = 0; f < c.length; f++) {
        const m = c[f].keys;
        if (!(!m || m.length === 0)) if (m[0].morphTargets) {
          const _ = {};
          let y;
          for (y = 0; y < m.length; y++) if (m[y].morphTargets) for (let g = 0; g < m[y].morphTargets.length; g++) _[m[y].morphTargets[g]] = -1;
          for (const g in _) {
            const x = [], v = [];
            for (let E = 0; E !== m[y].morphTargets.length; ++E) {
              const T = m[y];
              x.push(T.time), v.push(T.morphTarget === g ? 1 : 0);
            }
            i.push(new Uo(".morphTargetInfluence[" + g + "]", x, v));
          }
          l = _.length * o;
        } else {
          const _ = ".bones[" + t[f].name + "]";
          n(Fo, _ + ".position", m, "pos", i), n(Oo, _ + ".quaternion", m, "rot", i), n(Fo, _ + ".scale", m, "scl", i);
        }
      }
      return i.length === 0 ? null : new this(r, l, i, a);
    }
    resetDuration() {
      const e = this.tracks;
      let t = 0;
      for (let n = 0, i = e.length; n !== i; ++n) {
        const r = this.tracks[n];
        t = Math.max(t, r.times[r.times.length - 1]);
      }
      return this.duration = t, this;
    }
    trim() {
      for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
      return this;
    }
    validate() {
      let e = true;
      for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
      return e;
    }
    optimize() {
      for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
      return this;
    }
    clone() {
      const e = [];
      for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
      return new this.constructor(this.name, this.duration, e, this.blendMode);
    }
    toJSON() {
      return this.constructor.toJSON(this);
    }
  }
  function qy(s) {
    switch (s.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return Uo;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return Fo;
      case "color":
        return pg;
      case "quaternion":
        return Oo;
      case "bool":
      case "boolean":
        return jo;
      case "string":
        return $o;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + s);
  }
  function Yy(s) {
    if (s.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = qy(s.type);
    if (s.times === void 0) {
      const t = [], n = [];
      dg(s.keys, t, n, "value"), s.times = t, s.values = n;
    }
    return e.parse !== void 0 ? e.parse(s) : new e(s.name, s.times, s.values, s.interpolation);
  }
  const $r = {
    enabled: false,
    files: {},
    add: function(s, e) {
      this.enabled !== false && (this.files[s] = e);
    },
    get: function(s) {
      if (this.enabled !== false) return this.files[s];
    },
    remove: function(s) {
      delete this.files[s];
    },
    clear: function() {
      this.files = {};
    }
  };
  class jy {
    constructor(e, t, n) {
      const i = this;
      let r = false, o = 0, a = 0, l;
      const c = [];
      this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(h) {
        a++, r === false && i.onStart !== void 0 && i.onStart(h, o, a), r = true;
      }, this.itemEnd = function(h) {
        o++, i.onProgress !== void 0 && i.onProgress(h, o, a), o === a && (r = false, i.onLoad !== void 0 && i.onLoad());
      }, this.itemError = function(h) {
        i.onError !== void 0 && i.onError(h);
      }, this.resolveURL = function(h) {
        return l ? l(h) : h;
      }, this.setURLModifier = function(h) {
        return l = h, this;
      }, this.addHandler = function(h, f) {
        return c.push(h, f), this;
      }, this.removeHandler = function(h) {
        const f = c.indexOf(h);
        return f !== -1 && c.splice(f, 2), this;
      }, this.getHandler = function(h) {
        for (let f = 0, m = c.length; f < m; f += 2) {
          const _ = c[f], y = c[f + 1];
          if (_.global && (_.lastIndex = 0), _.test(h)) return y;
        }
        return null;
      };
    }
  }
  const $y = new jy();
  class Bs {
    constructor(e) {
      this.manager = e !== void 0 ? e : $y, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
    }
    load() {
    }
    loadAsync(e, t) {
      const n = this;
      return new Promise(function(i, r) {
        n.load(e, i, t, r);
      });
    }
    parse() {
    }
    setCrossOrigin(e) {
      return this.crossOrigin = e, this;
    }
    setWithCredentials(e) {
      return this.withCredentials = e, this;
    }
    setPath(e) {
      return this.path = e, this;
    }
    setResourcePath(e) {
      return this.resourcePath = e, this;
    }
    setRequestHeader(e) {
      return this.requestHeader = e, this;
    }
  }
  Bs.DEFAULT_MATERIAL_NAME = "__DEFAULT";
  const pr = {};
  class Ky extends Error {
    constructor(e, t) {
      super(e), this.response = t;
    }
  }
  class Bf extends Bs {
    constructor(e) {
      super(e);
    }
    load(e, t, n, i) {
      e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
      const r = $r.get(e);
      if (r !== void 0) return this.manager.itemStart(e), setTimeout(() => {
        t && t(r), this.manager.itemEnd(e);
      }, 0), r;
      if (pr[e] !== void 0) {
        pr[e].push({
          onLoad: t,
          onProgress: n,
          onError: i
        });
        return;
      }
      pr[e] = [], pr[e].push({
        onLoad: t,
        onProgress: n,
        onError: i
      });
      const o = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin"
      }), a = this.mimeType, l = this.responseType;
      fetch(o).then((c) => {
        if (c.status === 200 || c.status === 0) {
          if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0) return c;
          const h = pr[e], f = c.body.getReader(), m = c.headers.get("X-File-Size") || c.headers.get("Content-Length"), _ = m ? parseInt(m) : 0, y = _ !== 0;
          let g = 0;
          const x = new ReadableStream({
            start(v) {
              E();
              function E() {
                f.read().then(({ done: T, value: M }) => {
                  if (T) v.close();
                  else {
                    g += M.byteLength;
                    const P = new ProgressEvent("progress", {
                      lengthComputable: y,
                      loaded: g,
                      total: _
                    });
                    for (let R = 0, d = h.length; R < d; R++) {
                      const N = h[R];
                      N.onProgress && N.onProgress(P);
                    }
                    v.enqueue(M), E();
                  }
                }, (T) => {
                  v.error(T);
                });
              }
            }
          });
          return new Response(x);
        } else throw new Ky(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c);
      }).then((c) => {
        switch (l) {
          case "arraybuffer":
            return c.arrayBuffer();
          case "blob":
            return c.blob();
          case "document":
            return c.text().then((h) => new DOMParser().parseFromString(h, a));
          case "json":
            return c.json();
          default:
            if (a === void 0) return c.text();
            {
              const f = /charset="?([^;"\s]*)"?/i.exec(a), m = f && f[1] ? f[1].toLowerCase() : void 0, _ = new TextDecoder(m);
              return c.arrayBuffer().then((y) => _.decode(y));
            }
        }
      }).then((c) => {
        $r.add(e, c);
        const h = pr[e];
        delete pr[e];
        for (let f = 0, m = h.length; f < m; f++) {
          const _ = h[f];
          _.onLoad && _.onLoad(c);
        }
      }).catch((c) => {
        const h = pr[e];
        if (h === void 0) throw this.manager.itemError(e), c;
        delete pr[e];
        for (let f = 0, m = h.length; f < m; f++) {
          const _ = h[f];
          _.onError && _.onError(c);
        }
        this.manager.itemError(e);
      }).finally(() => {
        this.manager.itemEnd(e);
      }), this.manager.itemStart(e);
    }
    setResponseType(e) {
      return this.responseType = e, this;
    }
    setMimeType(e) {
      return this.mimeType = e, this;
    }
  }
  class Zy extends Bs {
    constructor(e) {
      super(e);
    }
    load(e, t, n, i) {
      this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
      const r = this, o = $r.get(e);
      if (o !== void 0) return r.manager.itemStart(e), setTimeout(function() {
        t && t(o), r.manager.itemEnd(e);
      }, 0), o;
      const a = Za("img");
      function l() {
        h(), $r.add(e, this), t && t(this), r.manager.itemEnd(e);
      }
      function c(f) {
        h(), i && i(f), r.manager.itemError(e), r.manager.itemEnd(e);
      }
      function h() {
        a.removeEventListener("load", l, false), a.removeEventListener("error", c, false);
      }
      return a.addEventListener("load", l, false), a.addEventListener("error", c, false), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(e), a.src = e, a;
    }
  }
  class Jy extends Bs {
    constructor(e) {
      super(e);
    }
    load(e, t, n, i) {
      const r = new Mn(), o = new Zy(this.manager);
      return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(a) {
        r.image = a, r.needsUpdate = true, t !== void 0 && t(r);
      }, n, i), r;
    }
  }
  class zc extends on {
    constructor(e, t = 1) {
      super(), this.isLight = true, this.type = "Light", this.color = new it(e), this.intensity = t;
    }
    dispose() {
    }
    copy(e, t) {
      return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
    }
    toJSON(e) {
      const t = super.toJSON(e);
      return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (t.object.target = this.target.uuid), t;
    }
  }
  const Ou = new pt(), vp = new V(), yp = new V();
  class zf {
    constructor(e) {
      this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Se(512, 512), this.map = null, this.mapPass = null, this.matrix = new pt(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new Lf(), this._frameExtents = new Se(1, 1), this._viewportCount = 1, this._viewports = [
        new zt(0, 0, 1, 1)
      ];
    }
    getViewportCount() {
      return this._viewportCount;
    }
    getFrustum() {
      return this._frustum;
    }
    updateMatrices(e) {
      const t = this.camera, n = this.matrix;
      vp.setFromMatrixPosition(e.matrixWorld), t.position.copy(vp), yp.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(yp), t.updateMatrixWorld(), Ou.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Ou), n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), n.multiply(Ou);
    }
    getViewport(e) {
      return this._viewports[e];
    }
    getFrameExtents() {
      return this._frameExtents;
    }
    dispose() {
      this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
    }
    copy(e) {
      return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      const e = {};
      return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(false).object, delete e.camera.matrix, e;
    }
  }
  class Qy extends zf {
    constructor() {
      super(new Xn(50, 1, 0.5, 500)), this.isSpotLightShadow = true, this.focus = 1;
    }
    updateMatrices(e) {
      const t = this.camera, n = Io * 2 * e.angle * this.focus, i = this.mapSize.width / this.mapSize.height, r = e.distance || t.far;
      (n !== t.fov || i !== t.aspect || r !== t.far) && (t.fov = n, t.aspect = i, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e);
    }
    copy(e) {
      return super.copy(e), this.focus = e.focus, this;
    }
  }
  class ex extends zc {
    constructor(e, t, n = 0, i = Math.PI / 3, r = 0, o = 2) {
      super(e, t), this.isSpotLight = true, this.type = "SpotLight", this.position.copy(on.DEFAULT_UP), this.updateMatrix(), this.target = new on(), this.distance = n, this.angle = i, this.penumbra = r, this.decay = o, this.map = null, this.shadow = new Qy();
    }
    get power() {
      return this.intensity * Math.PI;
    }
    set power(e) {
      this.intensity = e / Math.PI;
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e, t) {
      return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
    }
  }
  const xp = new pt(), wa = new V(), Fu = new V();
  class tx extends zf {
    constructor() {
      super(new Xn(90, 1, 0.5, 500)), this.isPointLightShadow = true, this._frameExtents = new Se(4, 2), this._viewportCount = 6, this._viewports = [
        new zt(2, 1, 1, 1),
        new zt(0, 1, 1, 1),
        new zt(3, 1, 1, 1),
        new zt(1, 1, 1, 1),
        new zt(3, 0, 1, 1),
        new zt(1, 0, 1, 1)
      ], this._cubeDirections = [
        new V(1, 0, 0),
        new V(-1, 0, 0),
        new V(0, 0, 1),
        new V(0, 0, -1),
        new V(0, 1, 0),
        new V(0, -1, 0)
      ], this._cubeUps = [
        new V(0, 1, 0),
        new V(0, 1, 0),
        new V(0, 1, 0),
        new V(0, 1, 0),
        new V(0, 0, 1),
        new V(0, 0, -1)
      ];
    }
    updateMatrices(e, t = 0) {
      const n = this.camera, i = this.matrix, r = e.distance || n.far;
      r !== n.far && (n.far = r, n.updateProjectionMatrix()), wa.setFromMatrixPosition(e.matrixWorld), n.position.copy(wa), Fu.copy(n.position), Fu.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(Fu), n.updateMatrixWorld(), i.makeTranslation(-wa.x, -wa.y, -wa.z), xp.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(xp);
    }
  }
  class Hf extends zc {
    constructor(e, t, n = 0, i = 2) {
      super(e, t), this.isPointLight = true, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new tx();
    }
    get power() {
      return this.intensity * 4 * Math.PI;
    }
    set power(e) {
      this.intensity = e / (4 * Math.PI);
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e, t) {
      return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
    }
  }
  class Hc extends Qm {
    constructor(e = -1, t = 1, n = 1, i = -1, r = 0.1, o = 2e3) {
      super(), this.isOrthographicCamera = true, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = r, this.far = o, this.updateProjectionMatrix();
    }
    copy(e, t) {
      return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
    }
    setViewOffset(e, t, n, i, r, o) {
      this.view === null && (this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }), this.view.enabled = true, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix();
    }
    clearViewOffset() {
      this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2;
      let r = n - e, o = n + e, a = i + t, l = i - t;
      if (this.view !== null && this.view.enabled) {
        const c = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        r += c * this.view.offsetX, o = r + c * this.view.width, a -= h * this.view.offsetY, l = a - h * this.view.height;
      }
      this.projectionMatrix.makeOrthographic(r, o, a, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(e) {
      const t = super.toJSON(e);
      return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
    }
  }
  class nx extends zf {
    constructor() {
      super(new Hc(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = true;
    }
  }
  class mg extends zc {
    constructor(e, t) {
      super(e, t), this.isDirectionalLight = true, this.type = "DirectionalLight", this.position.copy(on.DEFAULT_UP), this.updateMatrix(), this.target = new on(), this.shadow = new nx();
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e) {
      return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
    }
  }
  class gg extends zc {
    constructor(e, t) {
      super(e, t), this.isAmbientLight = true, this.type = "AmbientLight";
    }
  }
  class Ha {
    static decodeText(e) {
      if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."), typeof TextDecoder < "u") return new TextDecoder().decode(e);
      let t = "";
      for (let n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
      try {
        return decodeURIComponent(escape(t));
      } catch {
        return t;
      }
    }
    static extractUrlBase(e) {
      const t = e.lastIndexOf("/");
      return t === -1 ? "./" : e.slice(0, t + 1);
    }
    static resolveURL(e, t) {
      return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
    }
  }
  class ix extends Bs {
    constructor(e) {
      super(e), this.isImageBitmapLoader = true, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
        premultiplyAlpha: "none"
      };
    }
    setOptions(e) {
      return this.options = e, this;
    }
    load(e, t, n, i) {
      e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
      const r = this, o = $r.get(e);
      if (o !== void 0) {
        if (r.manager.itemStart(e), o.then) {
          o.then((c) => {
            t && t(c), r.manager.itemEnd(e);
          }).catch((c) => {
            i && i(c);
          });
          return;
        }
        return setTimeout(function() {
          t && t(o), r.manager.itemEnd(e);
        }, 0), o;
      }
      const a = {};
      a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader;
      const l = fetch(e, a).then(function(c) {
        return c.blob();
      }).then(function(c) {
        return createImageBitmap(c, Object.assign(r.options, {
          colorSpaceConversion: "none"
        }));
      }).then(function(c) {
        return $r.add(e, c), t && t(c), r.manager.itemEnd(e), c;
      }).catch(function(c) {
        i && i(c), $r.remove(e), r.manager.itemError(e), r.manager.itemEnd(e);
      });
      $r.add(e, l), r.manager.itemStart(e);
    }
  }
  class rx extends Xn {
    constructor(e = []) {
      super(), this.isArrayCamera = true, this.cameras = e, this.index = 0;
    }
  }
  class sx {
    constructor(e = true) {
      this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = false;
    }
    start() {
      this.startTime = bp(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = true;
    }
    stop() {
      this.getElapsedTime(), this.running = false, this.autoStart = false;
    }
    getElapsedTime() {
      return this.getDelta(), this.elapsedTime;
    }
    getDelta() {
      let e = 0;
      if (this.autoStart && !this.running) return this.start(), 0;
      if (this.running) {
        const t = bp();
        e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
      }
      return e;
    }
  }
  function bp() {
    return performance.now();
  }
  const Vf = "\\[\\]\\.:\\/", ox = new RegExp("[" + Vf + "]", "g"), Gf = "[^" + Vf + "]", ax = "[^" + Vf.replace("\\.", "") + "]", lx = /((?:WC+[\/:])*)/.source.replace("WC", Gf), cx = /(WCOD+)?/.source.replace("WCOD", ax), ux = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Gf), hx = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Gf), fx = new RegExp("^" + lx + cx + ux + hx + "$"), dx = [
    "material",
    "materials",
    "bones",
    "map"
  ];
  class px {
    constructor(e, t, n) {
      const i = n || Yt.parseTrackName(t);
      this._targetGroup = e, this._bindings = e.subscribe_(t, i);
    }
    getValue(e, t) {
      this.bind();
      const n = this._targetGroup.nCachedObjects_, i = this._bindings[n];
      i !== void 0 && i.getValue(e, t);
    }
    setValue(e, t) {
      const n = this._bindings;
      for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(e, t);
    }
    bind() {
      const e = this._bindings;
      for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind();
    }
    unbind() {
      const e = this._bindings;
      for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind();
    }
  }
  class Yt {
    constructor(e, t, n) {
      this.path = t, this.parsedPath = n || Yt.parseTrackName(t), this.node = Yt.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
    static create(e, t, n) {
      return e && e.isAnimationObjectGroup ? new Yt.Composite(e, t, n) : new Yt(e, t, n);
    }
    static sanitizeNodeName(e) {
      return e.replace(/\s/g, "_").replace(ox, "");
    }
    static parseTrackName(e) {
      const t = fx.exec(e);
      if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
      const n = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6]
      }, i = n.nodeName && n.nodeName.lastIndexOf(".");
      if (i !== void 0 && i !== -1) {
        const r = n.nodeName.substring(i + 1);
        dx.indexOf(r) !== -1 && (n.nodeName = n.nodeName.substring(0, i), n.objectName = r);
      }
      if (n.propertyName === null || n.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
      return n;
    }
    static findNode(e, t) {
      if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e;
      if (e.skeleton) {
        const n = e.skeleton.getBoneByName(t);
        if (n !== void 0) return n;
      }
      if (e.children) {
        const n = function(r) {
          for (let o = 0; o < r.length; o++) {
            const a = r[o];
            if (a.name === t || a.uuid === t) return a;
            const l = n(a.children);
            if (l) return l;
          }
          return null;
        }, i = n(e.children);
        if (i) return i;
      }
      return null;
    }
    _getValue_unavailable() {
    }
    _setValue_unavailable() {
    }
    _getValue_direct(e, t) {
      e[t] = this.targetObject[this.propertyName];
    }
    _getValue_array(e, t) {
      const n = this.resolvedProperty;
      for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i];
    }
    _getValue_arrayElement(e, t) {
      e[t] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(e, t) {
      this.resolvedProperty.toArray(e, t);
    }
    _setValue_direct(e, t) {
      this.targetObject[this.propertyName] = e[t];
    }
    _setValue_direct_setNeedsUpdate(e, t) {
      this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = true;
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
      this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_array(e, t) {
      const n = this.resolvedProperty;
      for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
    }
    _setValue_array_setNeedsUpdate(e, t) {
      const n = this.resolvedProperty;
      for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
      this.targetObject.needsUpdate = true;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
      const n = this.resolvedProperty;
      for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_arrayElement(e, t) {
      this.resolvedProperty[this.propertyIndex] = e[t];
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
      this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = true;
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
      this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_fromArray(e, t) {
      this.resolvedProperty.fromArray(e, t);
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
      this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = true;
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
      this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _getValue_unbound(e, t) {
      this.bind(), this.getValue(e, t);
    }
    _setValue_unbound(e, t) {
      this.bind(), this.setValue(e, t);
    }
    bind() {
      let e = this.node;
      const t = this.parsedPath, n = t.objectName, i = t.propertyName;
      let r = t.propertyIndex;
      if (e || (e = Yt.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
        console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
        return;
      }
      if (n) {
        let c = t.objectIndex;
        switch (n) {
          case "materials":
            if (!e.material) {
              console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              return;
            }
            if (!e.material.materials) {
              console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
              return;
            }
            e = e.material.materials;
            break;
          case "bones":
            if (!e.skeleton) {
              console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
              return;
            }
            e = e.skeleton.bones;
            for (let h = 0; h < e.length; h++) if (e[h].name === c) {
              c = h;
              break;
            }
            break;
          case "map":
            if ("map" in e) {
              e = e.map;
              break;
            }
            if (!e.material) {
              console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              return;
            }
            if (!e.material.map) {
              console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
              return;
            }
            e = e.material.map;
            break;
          default:
            if (e[n] === void 0) {
              console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
              return;
            }
            e = e[n];
        }
        if (c !== void 0) {
          if (e[c] === void 0) {
            console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
            return;
          }
          e = e[c];
        }
      }
      const o = e[i];
      if (o === void 0) {
        const c = t.nodeName;
        console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + i + " but it wasn't found.", e);
        return;
      }
      let a = this.Versioning.None;
      this.targetObject = e, e.isMaterial === true ? a = this.Versioning.NeedsUpdate : e.isObject3D === true && (a = this.Versioning.MatrixWorldNeedsUpdate);
      let l = this.BindingType.Direct;
      if (r !== void 0) {
        if (i === "morphTargetInfluences") {
          if (!e.geometry) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
            return;
          }
          if (!e.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          e.morphTargetDictionary[r] !== void 0 && (r = e.morphTargetDictionary[r]);
        }
        l = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r;
      } else o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = i;
      this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a];
    }
    unbind() {
      this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
  }
  Yt.Composite = px;
  Yt.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  };
  Yt.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  };
  Yt.prototype.GetterByBindingType = [
    Yt.prototype._getValue_direct,
    Yt.prototype._getValue_array,
    Yt.prototype._getValue_arrayElement,
    Yt.prototype._getValue_toArray
  ];
  Yt.prototype.SetterByBindingTypeAndVersioning = [
    [
      Yt.prototype._setValue_direct,
      Yt.prototype._setValue_direct_setNeedsUpdate,
      Yt.prototype._setValue_direct_setMatrixWorldNeedsUpdate
    ],
    [
      Yt.prototype._setValue_array,
      Yt.prototype._setValue_array_setNeedsUpdate,
      Yt.prototype._setValue_array_setMatrixWorldNeedsUpdate
    ],
    [
      Yt.prototype._setValue_arrayElement,
      Yt.prototype._setValue_arrayElement_setNeedsUpdate,
      Yt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
    ],
    [
      Yt.prototype._setValue_fromArray,
      Yt.prototype._setValue_fromArray_setNeedsUpdate,
      Yt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
    ]
  ];
  const Sp = new pt();
  class zs {
    constructor(e, t, n = 0, i = 1 / 0) {
      this.ray = new ul(e, t), this.near = n, this.far = i, this.camera = null, this.layers = new Rf(), this.params = {
        Mesh: {},
        Line: {
          threshold: 1
        },
        LOD: {},
        Points: {
          threshold: 1
        },
        Sprite: {}
      };
    }
    set(e, t) {
      this.ray.set(e, t);
    }
    setFromCamera(e, t) {
      t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
    }
    setFromXRController(e) {
      return Sp.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(Sp), this;
    }
    intersectObject(e, t = true, n = []) {
      return Zh(e, this, n, t), n.sort(Mp), n;
    }
    intersectObjects(e, t = true, n = []) {
      for (let i = 0, r = e.length; i < r; i++) Zh(e[i], this, n, t);
      return n.sort(Mp), n;
    }
  }
  function Mp(s, e) {
    return s.distance - e.distance;
  }
  function Zh(s, e, t, n) {
    let i = true;
    if (s.layers.test(e.layers) && s.raycast(e, t) === false && (i = false), i === true && n === true) {
      const r = s.children;
      for (let o = 0, a = r.length; o < a; o++) Zh(r[o], e, t, true);
    }
  }
  class mx {
    constructor() {
      this.type = "ShapePath", this.color = new it(), this.subPaths = [], this.currentPath = null;
    }
    moveTo(e, t) {
      return this.currentPath = new jh(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
    }
    lineTo(e, t) {
      return this.currentPath.lineTo(e, t), this;
    }
    quadraticCurveTo(e, t, n, i) {
      return this.currentPath.quadraticCurveTo(e, t, n, i), this;
    }
    bezierCurveTo(e, t, n, i, r, o) {
      return this.currentPath.bezierCurveTo(e, t, n, i, r, o), this;
    }
    splineThru(e) {
      return this.currentPath.splineThru(e), this;
    }
    toShapes(e) {
      function t(v) {
        const E = [];
        for (let T = 0, M = v.length; T < M; T++) {
          const P = v[T], R = new hc();
          R.curves = P.curves, E.push(R);
        }
        return E;
      }
      function n(v, E) {
        const T = E.length;
        let M = false;
        for (let P = T - 1, R = 0; R < T; P = R++) {
          let d = E[P], N = E[R], w = N.x - d.x, D = N.y - d.y;
          if (Math.abs(D) > Number.EPSILON) {
            if (D < 0 && (d = E[R], w = -w, N = E[P], D = -D), v.y < d.y || v.y > N.y) continue;
            if (v.y === d.y) {
              if (v.x === d.x) return true;
            } else {
              const B = D * (v.x - d.x) - w * (v.y - d.y);
              if (B === 0) return true;
              if (B < 0) continue;
              M = !M;
            }
          } else {
            if (v.y !== d.y) continue;
            if (N.x <= v.x && v.x <= d.x || d.x <= v.x && v.x <= N.x) return true;
          }
        }
        return M;
      }
      const i = So.isClockWise, r = this.subPaths;
      if (r.length === 0) return [];
      let o, a, l;
      const c = [];
      if (r.length === 1) return a = r[0], l = new hc(), l.curves = a.curves, c.push(l), c;
      let h = !i(r[0].getPoints());
      h = e ? !h : h;
      const f = [], m = [];
      let _ = [], y = 0, g;
      m[y] = void 0, _[y] = [];
      for (let v = 0, E = r.length; v < E; v++) a = r[v], g = a.getPoints(), o = i(g), o = e ? !o : o, o ? (!h && m[y] && y++, m[y] = {
        s: new hc(),
        p: g
      }, m[y].s.curves = a.curves, h && y++, _[y] = []) : _[y].push({
        h: a,
        p: g[0]
      });
      if (!m[0]) return t(r);
      if (m.length > 1) {
        let v = false, E = 0;
        for (let T = 0, M = m.length; T < M; T++) f[T] = [];
        for (let T = 0, M = m.length; T < M; T++) {
          const P = _[T];
          for (let R = 0; R < P.length; R++) {
            const d = P[R];
            let N = true;
            for (let w = 0; w < m.length; w++) n(d.p, m[w].p) && (T !== w && E++, N ? (N = false, f[w].push(d)) : v = true);
            N && f[T].push(d);
          }
        }
        E > 0 && v === false && (_ = f);
      }
      let x;
      for (let v = 0, E = m.length; v < E; v++) {
        l = m[v].s, c.push(l), x = _[v];
        for (let T = 0, M = x.length; T < M; T++) l.holes.push(x[T].h);
      }
      return c;
    }
  }
  function Tp(s, e, t, n) {
    const i = gx(n);
    switch (t) {
      case Fm:
        return s * e;
      case Bm:
        return s * e;
      case zm:
        return s * e * 2;
      case Tf:
        return s * e / i.components * i.byteLength;
      case Ef:
        return s * e / i.components * i.byteLength;
      case Hm:
        return s * e * 2 / i.components * i.byteLength;
      case wf:
        return s * e * 2 / i.components * i.byteLength;
      case km:
        return s * e * 3 / i.components * i.byteLength;
      case Ti:
        return s * e * 4 / i.components * i.byteLength;
      case Af:
        return s * e * 4 / i.components * i.byteLength;
      case oc:
      case ac:
        return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
      case lc:
      case cc:
        return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
      case vh:
      case xh:
        return Math.max(s, 16) * Math.max(e, 8) / 4;
      case _h:
      case yh:
        return Math.max(s, 8) * Math.max(e, 8) / 2;
      case bh:
      case Sh:
        return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
      case Mh:
        return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
      case Th:
        return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
      case Eh:
        return Math.floor((s + 4) / 5) * Math.floor((e + 3) / 4) * 16;
      case wh:
        return Math.floor((s + 4) / 5) * Math.floor((e + 4) / 5) * 16;
      case Ah:
        return Math.floor((s + 5) / 6) * Math.floor((e + 4) / 5) * 16;
      case Ch:
        return Math.floor((s + 5) / 6) * Math.floor((e + 5) / 6) * 16;
      case Rh:
        return Math.floor((s + 7) / 8) * Math.floor((e + 4) / 5) * 16;
      case Ph:
        return Math.floor((s + 7) / 8) * Math.floor((e + 5) / 6) * 16;
      case Dh:
        return Math.floor((s + 7) / 8) * Math.floor((e + 7) / 8) * 16;
      case Lh:
        return Math.floor((s + 9) / 10) * Math.floor((e + 4) / 5) * 16;
      case Ih:
        return Math.floor((s + 9) / 10) * Math.floor((e + 5) / 6) * 16;
      case Nh:
        return Math.floor((s + 9) / 10) * Math.floor((e + 7) / 8) * 16;
      case Uh:
        return Math.floor((s + 9) / 10) * Math.floor((e + 9) / 10) * 16;
      case Oh:
        return Math.floor((s + 11) / 12) * Math.floor((e + 9) / 10) * 16;
      case Fh:
        return Math.floor((s + 11) / 12) * Math.floor((e + 11) / 12) * 16;
      case uc:
      case kh:
      case Bh:
        return Math.ceil(s / 4) * Math.ceil(e / 4) * 16;
      case Vm:
      case zh:
        return Math.ceil(s / 4) * Math.ceil(e / 4) * 8;
      case Hh:
      case Vh:
        return Math.ceil(s / 4) * Math.ceil(e / 4) * 16;
    }
    throw new Error(`Unable to determine texture byte length for ${t} format.`);
  }
  function gx(s) {
    switch (s) {
      case wr:
      case Nm:
        return {
          byteLength: 1,
          components: 1
        };
      case ja:
      case Um:
      case Mr:
        return {
          byteLength: 2,
          components: 1
        };
      case Sf:
      case Mf:
        return {
          byteLength: 2,
          components: 4
        };
      case Us:
      case bf:
      case Ni:
        return {
          byteLength: 4,
          components: 1
        };
      case Om:
        return {
          byteLength: 4,
          components: 3
        };
    }
    throw new Error(`Unknown texture type ${s}.`);
  }
  typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
    detail: {
      revision: xf
    }
  }));
  typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = xf);
  function _g() {
    let s = null, e = false, t = null, n = null;
    function i(r, o) {
      t(r, o), n = s.requestAnimationFrame(i);
    }
    return {
      start: function() {
        e !== true && t !== null && (n = s.requestAnimationFrame(i), e = true);
      },
      stop: function() {
        s.cancelAnimationFrame(n), e = false;
      },
      setAnimationLoop: function(r) {
        t = r;
      },
      setContext: function(r) {
        s = r;
      }
    };
  }
  function _x(s) {
    const e = /* @__PURE__ */ new WeakMap();
    function t(a, l) {
      const c = a.array, h = a.usage, f = c.byteLength, m = s.createBuffer();
      s.bindBuffer(l, m), s.bufferData(l, c, h), a.onUploadCallback();
      let _;
      if (c instanceof Float32Array) _ = s.FLOAT;
      else if (c instanceof Uint16Array) a.isFloat16BufferAttribute ? _ = s.HALF_FLOAT : _ = s.UNSIGNED_SHORT;
      else if (c instanceof Int16Array) _ = s.SHORT;
      else if (c instanceof Uint32Array) _ = s.UNSIGNED_INT;
      else if (c instanceof Int32Array) _ = s.INT;
      else if (c instanceof Int8Array) _ = s.BYTE;
      else if (c instanceof Uint8Array) _ = s.UNSIGNED_BYTE;
      else if (c instanceof Uint8ClampedArray) _ = s.UNSIGNED_BYTE;
      else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
      return {
        buffer: m,
        type: _,
        bytesPerElement: c.BYTES_PER_ELEMENT,
        version: a.version,
        size: f
      };
    }
    function n(a, l, c) {
      const h = l.array, f = l.updateRanges;
      if (s.bindBuffer(c, a), f.length === 0) s.bufferSubData(c, 0, h);
      else {
        f.sort((_, y) => _.start - y.start);
        let m = 0;
        for (let _ = 1; _ < f.length; _++) {
          const y = f[m], g = f[_];
          g.start <= y.start + y.count + 1 ? y.count = Math.max(y.count, g.start + g.count - y.start) : (++m, f[m] = g);
        }
        f.length = m + 1;
        for (let _ = 0, y = f.length; _ < y; _++) {
          const g = f[_];
          s.bufferSubData(c, g.start * h.BYTES_PER_ELEMENT, h, g.start, g.count);
        }
        l.clearUpdateRanges();
      }
      l.onUploadCallback();
    }
    function i(a) {
      return a.isInterleavedBufferAttribute && (a = a.data), e.get(a);
    }
    function r(a) {
      a.isInterleavedBufferAttribute && (a = a.data);
      const l = e.get(a);
      l && (s.deleteBuffer(l.buffer), e.delete(a));
    }
    function o(a, l) {
      if (a.isInterleavedBufferAttribute && (a = a.data), a.isGLBufferAttribute) {
        const h = e.get(a);
        (!h || h.version < a.version) && e.set(a, {
          buffer: a.buffer,
          type: a.type,
          bytesPerElement: a.elementSize,
          version: a.version
        });
        return;
      }
      const c = e.get(a);
      if (c === void 0) e.set(a, t(a, l));
      else if (c.version < a.version) {
        if (c.size !== a.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
        n(c.buffer, a, l), c.version = a.version;
      }
    }
    return {
      get: i,
      remove: r,
      update: o
    };
  }
  var vx = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, yx = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, xx = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, bx = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Sx = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, Mx = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, Tx = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, Ex = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, wx = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, Ax = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, Cx = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, Rx = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, Px = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, Dx = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, Lx = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, Ix = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, Nx = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, Ux = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, Ox = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, Fx = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, kx = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, Bx = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, zx = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, Hx = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, Vx = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, Gx = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, Wx = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, Xx = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, qx = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, Yx = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, jx = "gl_FragColor = linearToOutputTexel( gl_FragColor );", $x = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, Kx = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, Zx = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, Jx = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, Qx = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, eb = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, tb = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, nb = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, ib = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, rb = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, sb = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, ob = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, ab = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, lb = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, cb = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, ub = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, hb = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, fb = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, db = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, pb = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, mb = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, gb = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, _b = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, vb = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, yb = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, xb = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, bb = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, Sb = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, Mb = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, Tb = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, Eb = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, wb = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, Ab = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Cb = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, Rb = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, Pb = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, Db = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, Lb = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, Ib = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, Nb = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, Ub = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, Ob = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, Fb = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, kb = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, Bb = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, zb = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, Hb = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, Vb = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, Gb = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, Wb = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, Xb = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, qb = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, Yb = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, jb = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, $b = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, Kb = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, Zb = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, Jb = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, Qb = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, eS = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, tS = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, nS = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, iS = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, rS = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, sS = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, oS = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, aS = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, lS = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, cS = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, uS = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, hS = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, fS = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, dS = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, pS = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, mS = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, gS = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
  const _S = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, vS = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, yS = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, xS = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, bS = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, SS = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, MS = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, TS = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, ES = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, wS = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, AS = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, CS = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, RS = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, PS = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, DS = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, LS = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, IS = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, NS = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, US = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, OS = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, FS = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, kS = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, BS = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, zS = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, HS = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, VS = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, GS = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, WS = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, XS = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, qS = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, YS = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, jS = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, $S = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, KS = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, _t = {
    alphahash_fragment: vx,
    alphahash_pars_fragment: yx,
    alphamap_fragment: xx,
    alphamap_pars_fragment: bx,
    alphatest_fragment: Sx,
    alphatest_pars_fragment: Mx,
    aomap_fragment: Tx,
    aomap_pars_fragment: Ex,
    batching_pars_vertex: wx,
    batching_vertex: Ax,
    begin_vertex: Cx,
    beginnormal_vertex: Rx,
    bsdfs: Px,
    iridescence_fragment: Dx,
    bumpmap_pars_fragment: Lx,
    clipping_planes_fragment: Ix,
    clipping_planes_pars_fragment: Nx,
    clipping_planes_pars_vertex: Ux,
    clipping_planes_vertex: Ox,
    color_fragment: Fx,
    color_pars_fragment: kx,
    color_pars_vertex: Bx,
    color_vertex: zx,
    common: Hx,
    cube_uv_reflection_fragment: Vx,
    defaultnormal_vertex: Gx,
    displacementmap_pars_vertex: Wx,
    displacementmap_vertex: Xx,
    emissivemap_fragment: qx,
    emissivemap_pars_fragment: Yx,
    colorspace_fragment: jx,
    colorspace_pars_fragment: $x,
    envmap_fragment: Kx,
    envmap_common_pars_fragment: Zx,
    envmap_pars_fragment: Jx,
    envmap_pars_vertex: Qx,
    envmap_physical_pars_fragment: ub,
    envmap_vertex: eb,
    fog_vertex: tb,
    fog_pars_vertex: nb,
    fog_fragment: ib,
    fog_pars_fragment: rb,
    gradientmap_pars_fragment: sb,
    lightmap_pars_fragment: ob,
    lights_lambert_fragment: ab,
    lights_lambert_pars_fragment: lb,
    lights_pars_begin: cb,
    lights_toon_fragment: hb,
    lights_toon_pars_fragment: fb,
    lights_phong_fragment: db,
    lights_phong_pars_fragment: pb,
    lights_physical_fragment: mb,
    lights_physical_pars_fragment: gb,
    lights_fragment_begin: _b,
    lights_fragment_maps: vb,
    lights_fragment_end: yb,
    logdepthbuf_fragment: xb,
    logdepthbuf_pars_fragment: bb,
    logdepthbuf_pars_vertex: Sb,
    logdepthbuf_vertex: Mb,
    map_fragment: Tb,
    map_pars_fragment: Eb,
    map_particle_fragment: wb,
    map_particle_pars_fragment: Ab,
    metalnessmap_fragment: Cb,
    metalnessmap_pars_fragment: Rb,
    morphinstance_vertex: Pb,
    morphcolor_vertex: Db,
    morphnormal_vertex: Lb,
    morphtarget_pars_vertex: Ib,
    morphtarget_vertex: Nb,
    normal_fragment_begin: Ub,
    normal_fragment_maps: Ob,
    normal_pars_fragment: Fb,
    normal_pars_vertex: kb,
    normal_vertex: Bb,
    normalmap_pars_fragment: zb,
    clearcoat_normal_fragment_begin: Hb,
    clearcoat_normal_fragment_maps: Vb,
    clearcoat_pars_fragment: Gb,
    iridescence_pars_fragment: Wb,
    opaque_fragment: Xb,
    packing: qb,
    premultiplied_alpha_fragment: Yb,
    project_vertex: jb,
    dithering_fragment: $b,
    dithering_pars_fragment: Kb,
    roughnessmap_fragment: Zb,
    roughnessmap_pars_fragment: Jb,
    shadowmap_pars_fragment: Qb,
    shadowmap_pars_vertex: eS,
    shadowmap_vertex: tS,
    shadowmask_pars_fragment: nS,
    skinbase_vertex: iS,
    skinning_pars_vertex: rS,
    skinning_vertex: sS,
    skinnormal_vertex: oS,
    specularmap_fragment: aS,
    specularmap_pars_fragment: lS,
    tonemapping_fragment: cS,
    tonemapping_pars_fragment: uS,
    transmission_fragment: hS,
    transmission_pars_fragment: fS,
    uv_pars_fragment: dS,
    uv_pars_vertex: pS,
    uv_vertex: mS,
    worldpos_vertex: gS,
    background_vert: _S,
    background_frag: vS,
    backgroundCube_vert: yS,
    backgroundCube_frag: xS,
    cube_vert: bS,
    cube_frag: SS,
    depth_vert: MS,
    depth_frag: TS,
    distanceRGBA_vert: ES,
    distanceRGBA_frag: wS,
    equirect_vert: AS,
    equirect_frag: CS,
    linedashed_vert: RS,
    linedashed_frag: PS,
    meshbasic_vert: DS,
    meshbasic_frag: LS,
    meshlambert_vert: IS,
    meshlambert_frag: NS,
    meshmatcap_vert: US,
    meshmatcap_frag: OS,
    meshnormal_vert: FS,
    meshnormal_frag: kS,
    meshphong_vert: BS,
    meshphong_frag: zS,
    meshphysical_vert: HS,
    meshphysical_frag: VS,
    meshtoon_vert: GS,
    meshtoon_frag: WS,
    points_vert: XS,
    points_frag: qS,
    shadow_vert: YS,
    shadow_frag: jS,
    sprite_vert: $S,
    sprite_frag: KS
  }, De = {
    common: {
      diffuse: {
        value: new it(16777215)
      },
      opacity: {
        value: 1
      },
      map: {
        value: null
      },
      mapTransform: {
        value: new mt()
      },
      alphaMap: {
        value: null
      },
      alphaMapTransform: {
        value: new mt()
      },
      alphaTest: {
        value: 0
      }
    },
    specularmap: {
      specularMap: {
        value: null
      },
      specularMapTransform: {
        value: new mt()
      }
    },
    envmap: {
      envMap: {
        value: null
      },
      envMapRotation: {
        value: new mt()
      },
      flipEnvMap: {
        value: -1
      },
      reflectivity: {
        value: 1
      },
      ior: {
        value: 1.5
      },
      refractionRatio: {
        value: 0.98
      }
    },
    aomap: {
      aoMap: {
        value: null
      },
      aoMapIntensity: {
        value: 1
      },
      aoMapTransform: {
        value: new mt()
      }
    },
    lightmap: {
      lightMap: {
        value: null
      },
      lightMapIntensity: {
        value: 1
      },
      lightMapTransform: {
        value: new mt()
      }
    },
    bumpmap: {
      bumpMap: {
        value: null
      },
      bumpMapTransform: {
        value: new mt()
      },
      bumpScale: {
        value: 1
      }
    },
    normalmap: {
      normalMap: {
        value: null
      },
      normalMapTransform: {
        value: new mt()
      },
      normalScale: {
        value: new Se(1, 1)
      }
    },
    displacementmap: {
      displacementMap: {
        value: null
      },
      displacementMapTransform: {
        value: new mt()
      },
      displacementScale: {
        value: 1
      },
      displacementBias: {
        value: 0
      }
    },
    emissivemap: {
      emissiveMap: {
        value: null
      },
      emissiveMapTransform: {
        value: new mt()
      }
    },
    metalnessmap: {
      metalnessMap: {
        value: null
      },
      metalnessMapTransform: {
        value: new mt()
      }
    },
    roughnessmap: {
      roughnessMap: {
        value: null
      },
      roughnessMapTransform: {
        value: new mt()
      }
    },
    gradientmap: {
      gradientMap: {
        value: null
      }
    },
    fog: {
      fogDensity: {
        value: 25e-5
      },
      fogNear: {
        value: 1
      },
      fogFar: {
        value: 2e3
      },
      fogColor: {
        value: new it(16777215)
      }
    },
    lights: {
      ambientLightColor: {
        value: []
      },
      lightProbe: {
        value: []
      },
      directionalLights: {
        value: [],
        properties: {
          direction: {},
          color: {}
        }
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        }
      },
      directionalShadowMap: {
        value: []
      },
      directionalShadowMatrix: {
        value: []
      },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {}
        }
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        }
      },
      spotLightMap: {
        value: []
      },
      spotShadowMap: {
        value: []
      },
      spotLightMatrix: {
        value: []
      },
      pointLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          decay: {},
          distance: {}
        }
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {}
        }
      },
      pointShadowMap: {
        value: []
      },
      pointShadowMatrix: {
        value: []
      },
      hemisphereLights: {
        value: [],
        properties: {
          direction: {},
          skyColor: {},
          groundColor: {}
        }
      },
      rectAreaLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          width: {},
          height: {}
        }
      },
      ltc_1: {
        value: null
      },
      ltc_2: {
        value: null
      }
    },
    points: {
      diffuse: {
        value: new it(16777215)
      },
      opacity: {
        value: 1
      },
      size: {
        value: 1
      },
      scale: {
        value: 1
      },
      map: {
        value: null
      },
      alphaMap: {
        value: null
      },
      alphaMapTransform: {
        value: new mt()
      },
      alphaTest: {
        value: 0
      },
      uvTransform: {
        value: new mt()
      }
    },
    sprite: {
      diffuse: {
        value: new it(16777215)
      },
      opacity: {
        value: 1
      },
      center: {
        value: new Se(0.5, 0.5)
      },
      rotation: {
        value: 0
      },
      map: {
        value: null
      },
      mapTransform: {
        value: new mt()
      },
      alphaMap: {
        value: null
      },
      alphaMapTransform: {
        value: new mt()
      },
      alphaTest: {
        value: 0
      }
    }
  }, Gi = {
    basic: {
      uniforms: Wn([
        De.common,
        De.specularmap,
        De.envmap,
        De.aomap,
        De.lightmap,
        De.fog
      ]),
      vertexShader: _t.meshbasic_vert,
      fragmentShader: _t.meshbasic_frag
    },
    lambert: {
      uniforms: Wn([
        De.common,
        De.specularmap,
        De.envmap,
        De.aomap,
        De.lightmap,
        De.emissivemap,
        De.bumpmap,
        De.normalmap,
        De.displacementmap,
        De.fog,
        De.lights,
        {
          emissive: {
            value: new it(0)
          }
        }
      ]),
      vertexShader: _t.meshlambert_vert,
      fragmentShader: _t.meshlambert_frag
    },
    phong: {
      uniforms: Wn([
        De.common,
        De.specularmap,
        De.envmap,
        De.aomap,
        De.lightmap,
        De.emissivemap,
        De.bumpmap,
        De.normalmap,
        De.displacementmap,
        De.fog,
        De.lights,
        {
          emissive: {
            value: new it(0)
          },
          specular: {
            value: new it(1118481)
          },
          shininess: {
            value: 30
          }
        }
      ]),
      vertexShader: _t.meshphong_vert,
      fragmentShader: _t.meshphong_frag
    },
    standard: {
      uniforms: Wn([
        De.common,
        De.envmap,
        De.aomap,
        De.lightmap,
        De.emissivemap,
        De.bumpmap,
        De.normalmap,
        De.displacementmap,
        De.roughnessmap,
        De.metalnessmap,
        De.fog,
        De.lights,
        {
          emissive: {
            value: new it(0)
          },
          roughness: {
            value: 1
          },
          metalness: {
            value: 0
          },
          envMapIntensity: {
            value: 1
          }
        }
      ]),
      vertexShader: _t.meshphysical_vert,
      fragmentShader: _t.meshphysical_frag
    },
    toon: {
      uniforms: Wn([
        De.common,
        De.aomap,
        De.lightmap,
        De.emissivemap,
        De.bumpmap,
        De.normalmap,
        De.displacementmap,
        De.gradientmap,
        De.fog,
        De.lights,
        {
          emissive: {
            value: new it(0)
          }
        }
      ]),
      vertexShader: _t.meshtoon_vert,
      fragmentShader: _t.meshtoon_frag
    },
    matcap: {
      uniforms: Wn([
        De.common,
        De.bumpmap,
        De.normalmap,
        De.displacementmap,
        De.fog,
        {
          matcap: {
            value: null
          }
        }
      ]),
      vertexShader: _t.meshmatcap_vert,
      fragmentShader: _t.meshmatcap_frag
    },
    points: {
      uniforms: Wn([
        De.points,
        De.fog
      ]),
      vertexShader: _t.points_vert,
      fragmentShader: _t.points_frag
    },
    dashed: {
      uniforms: Wn([
        De.common,
        De.fog,
        {
          scale: {
            value: 1
          },
          dashSize: {
            value: 1
          },
          totalSize: {
            value: 2
          }
        }
      ]),
      vertexShader: _t.linedashed_vert,
      fragmentShader: _t.linedashed_frag
    },
    depth: {
      uniforms: Wn([
        De.common,
        De.displacementmap
      ]),
      vertexShader: _t.depth_vert,
      fragmentShader: _t.depth_frag
    },
    normal: {
      uniforms: Wn([
        De.common,
        De.bumpmap,
        De.normalmap,
        De.displacementmap,
        {
          opacity: {
            value: 1
          }
        }
      ]),
      vertexShader: _t.meshnormal_vert,
      fragmentShader: _t.meshnormal_frag
    },
    sprite: {
      uniforms: Wn([
        De.sprite,
        De.fog
      ]),
      vertexShader: _t.sprite_vert,
      fragmentShader: _t.sprite_frag
    },
    background: {
      uniforms: {
        uvTransform: {
          value: new mt()
        },
        t2D: {
          value: null
        },
        backgroundIntensity: {
          value: 1
        }
      },
      vertexShader: _t.background_vert,
      fragmentShader: _t.background_frag
    },
    backgroundCube: {
      uniforms: {
        envMap: {
          value: null
        },
        flipEnvMap: {
          value: -1
        },
        backgroundBlurriness: {
          value: 0
        },
        backgroundIntensity: {
          value: 1
        },
        backgroundRotation: {
          value: new mt()
        }
      },
      vertexShader: _t.backgroundCube_vert,
      fragmentShader: _t.backgroundCube_frag
    },
    cube: {
      uniforms: {
        tCube: {
          value: null
        },
        tFlip: {
          value: -1
        },
        opacity: {
          value: 1
        }
      },
      vertexShader: _t.cube_vert,
      fragmentShader: _t.cube_frag
    },
    equirect: {
      uniforms: {
        tEquirect: {
          value: null
        }
      },
      vertexShader: _t.equirect_vert,
      fragmentShader: _t.equirect_frag
    },
    distanceRGBA: {
      uniforms: Wn([
        De.common,
        De.displacementmap,
        {
          referencePosition: {
            value: new V()
          },
          nearDistance: {
            value: 1
          },
          farDistance: {
            value: 1e3
          }
        }
      ]),
      vertexShader: _t.distanceRGBA_vert,
      fragmentShader: _t.distanceRGBA_frag
    },
    shadow: {
      uniforms: Wn([
        De.lights,
        De.fog,
        {
          color: {
            value: new it(0)
          },
          opacity: {
            value: 1
          }
        }
      ]),
      vertexShader: _t.shadow_vert,
      fragmentShader: _t.shadow_frag
    }
  };
  Gi.physical = {
    uniforms: Wn([
      Gi.standard.uniforms,
      {
        clearcoat: {
          value: 0
        },
        clearcoatMap: {
          value: null
        },
        clearcoatMapTransform: {
          value: new mt()
        },
        clearcoatNormalMap: {
          value: null
        },
        clearcoatNormalMapTransform: {
          value: new mt()
        },
        clearcoatNormalScale: {
          value: new Se(1, 1)
        },
        clearcoatRoughness: {
          value: 0
        },
        clearcoatRoughnessMap: {
          value: null
        },
        clearcoatRoughnessMapTransform: {
          value: new mt()
        },
        dispersion: {
          value: 0
        },
        iridescence: {
          value: 0
        },
        iridescenceMap: {
          value: null
        },
        iridescenceMapTransform: {
          value: new mt()
        },
        iridescenceIOR: {
          value: 1.3
        },
        iridescenceThicknessMinimum: {
          value: 100
        },
        iridescenceThicknessMaximum: {
          value: 400
        },
        iridescenceThicknessMap: {
          value: null
        },
        iridescenceThicknessMapTransform: {
          value: new mt()
        },
        sheen: {
          value: 0
        },
        sheenColor: {
          value: new it(0)
        },
        sheenColorMap: {
          value: null
        },
        sheenColorMapTransform: {
          value: new mt()
        },
        sheenRoughness: {
          value: 1
        },
        sheenRoughnessMap: {
          value: null
        },
        sheenRoughnessMapTransform: {
          value: new mt()
        },
        transmission: {
          value: 0
        },
        transmissionMap: {
          value: null
        },
        transmissionMapTransform: {
          value: new mt()
        },
        transmissionSamplerSize: {
          value: new Se()
        },
        transmissionSamplerMap: {
          value: null
        },
        thickness: {
          value: 0
        },
        thicknessMap: {
          value: null
        },
        thicknessMapTransform: {
          value: new mt()
        },
        attenuationDistance: {
          value: 0
        },
        attenuationColor: {
          value: new it(0)
        },
        specularColor: {
          value: new it(1, 1, 1)
        },
        specularColorMap: {
          value: null
        },
        specularColorMapTransform: {
          value: new mt()
        },
        specularIntensity: {
          value: 1
        },
        specularIntensityMap: {
          value: null
        },
        specularIntensityMapTransform: {
          value: new mt()
        },
        anisotropyVector: {
          value: new Se()
        },
        anisotropyMap: {
          value: null
        },
        anisotropyMapTransform: {
          value: new mt()
        }
      }
    ]),
    vertexShader: _t.meshphysical_vert,
    fragmentShader: _t.meshphysical_frag
  };
  const Ql = {
    r: 0,
    b: 0,
    g: 0
  }, ms = new Zi(), ZS = new pt();
  function JS(s, e, t, n, i, r, o) {
    const a = new it(0);
    let l = r === true ? 0 : 1, c, h, f = null, m = 0, _ = null;
    function y(T) {
      let M = T.isScene === true ? T.background : null;
      return M && M.isTexture && (M = (T.backgroundBlurriness > 0 ? t : e).get(M)), M;
    }
    function g(T) {
      let M = false;
      const P = y(T);
      P === null ? v(a, l) : P && P.isColor && (v(P, 1), M = true);
      const R = s.xr.getEnvironmentBlendMode();
      R === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, o) : R === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, o), (s.autoClear || M) && (n.buffers.depth.setTest(true), n.buffers.depth.setMask(true), n.buffers.color.setMask(true), s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil));
    }
    function x(T, M) {
      const P = y(M);
      P && (P.isCubeTexture || P.mapping === kc) ? (h === void 0 && (h = new hn(new ks(1, 1, 1), new kn({
        name: "BackgroundCubeMaterial",
        uniforms: No(Gi.backgroundCube.uniforms),
        vertexShader: Gi.backgroundCube.vertexShader,
        fragmentShader: Gi.backgroundCube.fragmentShader,
        side: Qn,
        depthTest: false,
        depthWrite: false,
        fog: false
      })), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(R, d, N) {
        this.matrixWorld.copyPosition(N.matrixWorld);
      }, Object.defineProperty(h.material, "envMap", {
        get: function() {
          return this.uniforms.envMap.value;
        }
      }), i.update(h)), ms.copy(M.backgroundRotation), ms.x *= -1, ms.y *= -1, ms.z *= -1, P.isCubeTexture && P.isRenderTargetTexture === false && (ms.y *= -1, ms.z *= -1), h.material.uniforms.envMap.value = P, h.material.uniforms.flipEnvMap.value = P.isCubeTexture && P.isRenderTargetTexture === false ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = M.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = M.backgroundIntensity, h.material.uniforms.backgroundRotation.value.setFromMatrix4(ZS.makeRotationFromEuler(ms)), h.material.toneMapped = It.getTransfer(P.colorSpace) !== $t, (f !== P || m !== P.version || _ !== s.toneMapping) && (h.material.needsUpdate = true, f = P, m = P.version, _ = s.toneMapping), h.layers.enableAll(), T.unshift(h, h.geometry, h.material, 0, 0, null)) : P && P.isTexture && (c === void 0 && (c = new hn(new hl(2, 2), new kn({
        name: "BackgroundMaterial",
        uniforms: No(Gi.background.uniforms),
        vertexShader: Gi.background.vertexShader,
        fragmentShader: Gi.background.fragmentShader,
        side: Er,
        depthTest: false,
        depthWrite: false,
        fog: false
      })), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
        get: function() {
          return this.uniforms.t2D.value;
        }
      }), i.update(c)), c.material.uniforms.t2D.value = P, c.material.uniforms.backgroundIntensity.value = M.backgroundIntensity, c.material.toneMapped = It.getTransfer(P.colorSpace) !== $t, P.matrixAutoUpdate === true && P.updateMatrix(), c.material.uniforms.uvTransform.value.copy(P.matrix), (f !== P || m !== P.version || _ !== s.toneMapping) && (c.material.needsUpdate = true, f = P, m = P.version, _ = s.toneMapping), c.layers.enableAll(), T.unshift(c, c.geometry, c.material, 0, 0, null));
    }
    function v(T, M) {
      T.getRGB(Ql, Jm(s)), n.buffers.color.setClear(Ql.r, Ql.g, Ql.b, M, o);
    }
    function E() {
      h !== void 0 && (h.geometry.dispose(), h.material.dispose(), h = void 0), c !== void 0 && (c.geometry.dispose(), c.material.dispose(), c = void 0);
    }
    return {
      getClearColor: function() {
        return a;
      },
      setClearColor: function(T, M = 1) {
        a.set(T), l = M, v(a, l);
      },
      getClearAlpha: function() {
        return l;
      },
      setClearAlpha: function(T) {
        l = T, v(a, l);
      },
      render: g,
      addToRenderList: x,
      dispose: E
    };
  }
  function QS(s, e) {
    const t = s.getParameter(s.MAX_VERTEX_ATTRIBS), n = {}, i = m(null);
    let r = i, o = false;
    function a(D, B, Z, G, Q) {
      let ue = false;
      const te = f(G, Z, B);
      r !== te && (r = te, c(r.object)), ue = _(D, G, Z, Q), ue && y(D, G, Z, Q), Q !== null && e.update(Q, s.ELEMENT_ARRAY_BUFFER), (ue || o) && (o = false, M(D, B, Z, G), Q !== null && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, e.get(Q).buffer));
    }
    function l() {
      return s.createVertexArray();
    }
    function c(D) {
      return s.bindVertexArray(D);
    }
    function h(D) {
      return s.deleteVertexArray(D);
    }
    function f(D, B, Z) {
      const G = Z.wireframe === true;
      let Q = n[D.id];
      Q === void 0 && (Q = {}, n[D.id] = Q);
      let ue = Q[B.id];
      ue === void 0 && (ue = {}, Q[B.id] = ue);
      let te = ue[G];
      return te === void 0 && (te = m(l()), ue[G] = te), te;
    }
    function m(D) {
      const B = [], Z = [], G = [];
      for (let Q = 0; Q < t; Q++) B[Q] = 0, Z[Q] = 0, G[Q] = 0;
      return {
        geometry: null,
        program: null,
        wireframe: false,
        newAttributes: B,
        enabledAttributes: Z,
        attributeDivisors: G,
        object: D,
        attributes: {},
        index: null
      };
    }
    function _(D, B, Z, G) {
      const Q = r.attributes, ue = B.attributes;
      let te = 0;
      const he = Z.getAttributes();
      for (const ie in he) if (he[ie].location >= 0) {
        const Ce = Q[ie];
        let Le = ue[ie];
        if (Le === void 0 && (ie === "instanceMatrix" && D.instanceMatrix && (Le = D.instanceMatrix), ie === "instanceColor" && D.instanceColor && (Le = D.instanceColor)), Ce === void 0 || Ce.attribute !== Le || Le && Ce.data !== Le.data) return true;
        te++;
      }
      return r.attributesNum !== te || r.index !== G;
    }
    function y(D, B, Z, G) {
      const Q = {}, ue = B.attributes;
      let te = 0;
      const he = Z.getAttributes();
      for (const ie in he) if (he[ie].location >= 0) {
        let Ce = ue[ie];
        Ce === void 0 && (ie === "instanceMatrix" && D.instanceMatrix && (Ce = D.instanceMatrix), ie === "instanceColor" && D.instanceColor && (Ce = D.instanceColor));
        const Le = {};
        Le.attribute = Ce, Ce && Ce.data && (Le.data = Ce.data), Q[ie] = Le, te++;
      }
      r.attributes = Q, r.attributesNum = te, r.index = G;
    }
    function g() {
      const D = r.newAttributes;
      for (let B = 0, Z = D.length; B < Z; B++) D[B] = 0;
    }
    function x(D) {
      v(D, 0);
    }
    function v(D, B) {
      const Z = r.newAttributes, G = r.enabledAttributes, Q = r.attributeDivisors;
      Z[D] = 1, G[D] === 0 && (s.enableVertexAttribArray(D), G[D] = 1), Q[D] !== B && (s.vertexAttribDivisor(D, B), Q[D] = B);
    }
    function E() {
      const D = r.newAttributes, B = r.enabledAttributes;
      for (let Z = 0, G = B.length; Z < G; Z++) B[Z] !== D[Z] && (s.disableVertexAttribArray(Z), B[Z] = 0);
    }
    function T(D, B, Z, G, Q, ue, te) {
      te === true ? s.vertexAttribIPointer(D, B, Z, Q, ue) : s.vertexAttribPointer(D, B, Z, G, Q, ue);
    }
    function M(D, B, Z, G) {
      g();
      const Q = G.attributes, ue = Z.getAttributes(), te = B.defaultAttributeValues;
      for (const he in ue) {
        const ie = ue[he];
        if (ie.location >= 0) {
          let Me = Q[he];
          if (Me === void 0 && (he === "instanceMatrix" && D.instanceMatrix && (Me = D.instanceMatrix), he === "instanceColor" && D.instanceColor && (Me = D.instanceColor)), Me !== void 0) {
            const Ce = Me.normalized, Le = Me.itemSize, Je = e.get(Me);
            if (Je === void 0) continue;
            const dt = Je.buffer, ce = Je.type, ve = Je.bytesPerElement, qe = ce === s.INT || ce === s.UNSIGNED_INT || Me.gpuType === bf;
            if (Me.isInterleavedBufferAttribute) {
              const Te = Me.data, Ye = Te.stride, lt = Me.offset;
              if (Te.isInstancedInterleavedBuffer) {
                for (let Fe = 0; Fe < ie.locationSize; Fe++) v(ie.location + Fe, Te.meshPerAttribute);
                D.isInstancedMesh !== true && G._maxInstanceCount === void 0 && (G._maxInstanceCount = Te.meshPerAttribute * Te.count);
              } else for (let Fe = 0; Fe < ie.locationSize; Fe++) x(ie.location + Fe);
              s.bindBuffer(s.ARRAY_BUFFER, dt);
              for (let Fe = 0; Fe < ie.locationSize; Fe++) T(ie.location + Fe, Le / ie.locationSize, ce, Ce, Ye * ve, (lt + Le / ie.locationSize * Fe) * ve, qe);
            } else {
              if (Me.isInstancedBufferAttribute) {
                for (let Te = 0; Te < ie.locationSize; Te++) v(ie.location + Te, Me.meshPerAttribute);
                D.isInstancedMesh !== true && G._maxInstanceCount === void 0 && (G._maxInstanceCount = Me.meshPerAttribute * Me.count);
              } else for (let Te = 0; Te < ie.locationSize; Te++) x(ie.location + Te);
              s.bindBuffer(s.ARRAY_BUFFER, dt);
              for (let Te = 0; Te < ie.locationSize; Te++) T(ie.location + Te, Le / ie.locationSize, ce, Ce, Le * ve, Le / ie.locationSize * Te * ve, qe);
            }
          } else if (te !== void 0) {
            const Ce = te[he];
            if (Ce !== void 0) switch (Ce.length) {
              case 2:
                s.vertexAttrib2fv(ie.location, Ce);
                break;
              case 3:
                s.vertexAttrib3fv(ie.location, Ce);
                break;
              case 4:
                s.vertexAttrib4fv(ie.location, Ce);
                break;
              default:
                s.vertexAttrib1fv(ie.location, Ce);
            }
          }
        }
      }
      E();
    }
    function P() {
      N();
      for (const D in n) {
        const B = n[D];
        for (const Z in B) {
          const G = B[Z];
          for (const Q in G) h(G[Q].object), delete G[Q];
          delete B[Z];
        }
        delete n[D];
      }
    }
    function R(D) {
      if (n[D.id] === void 0) return;
      const B = n[D.id];
      for (const Z in B) {
        const G = B[Z];
        for (const Q in G) h(G[Q].object), delete G[Q];
        delete B[Z];
      }
      delete n[D.id];
    }
    function d(D) {
      for (const B in n) {
        const Z = n[B];
        if (Z[D.id] === void 0) continue;
        const G = Z[D.id];
        for (const Q in G) h(G[Q].object), delete G[Q];
        delete Z[D.id];
      }
    }
    function N() {
      w(), o = true, r !== i && (r = i, c(r.object));
    }
    function w() {
      i.geometry = null, i.program = null, i.wireframe = false;
    }
    return {
      setup: a,
      reset: N,
      resetDefaultState: w,
      dispose: P,
      releaseStatesOfGeometry: R,
      releaseStatesOfProgram: d,
      initAttributes: g,
      enableAttribute: x,
      disableUnusedAttributes: E
    };
  }
  function eM(s, e, t) {
    let n;
    function i(c) {
      n = c;
    }
    function r(c, h) {
      s.drawArrays(n, c, h), t.update(h, n, 1);
    }
    function o(c, h, f) {
      f !== 0 && (s.drawArraysInstanced(n, c, h, f), t.update(h, n, f));
    }
    function a(c, h, f) {
      if (f === 0) return;
      e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, c, 0, h, 0, f);
      let _ = 0;
      for (let y = 0; y < f; y++) _ += h[y];
      t.update(_, n, 1);
    }
    function l(c, h, f, m) {
      if (f === 0) return;
      const _ = e.get("WEBGL_multi_draw");
      if (_ === null) for (let y = 0; y < c.length; y++) o(c[y], h[y], m[y]);
      else {
        _.multiDrawArraysInstancedWEBGL(n, c, 0, h, 0, m, 0, f);
        let y = 0;
        for (let g = 0; g < f; g++) y += h[g] * m[g];
        t.update(y, n, 1);
      }
    }
    this.setMode = i, this.render = r, this.renderInstances = o, this.renderMultiDraw = a, this.renderMultiDrawInstances = l;
  }
  function tM(s, e, t, n) {
    let i;
    function r() {
      if (i !== void 0) return i;
      if (e.has("EXT_texture_filter_anisotropic") === true) {
        const d = e.get("EXT_texture_filter_anisotropic");
        i = s.getParameter(d.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else i = 0;
      return i;
    }
    function o(d) {
      return !(d !== Ti && n.convert(d) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_FORMAT));
    }
    function a(d) {
      const N = d === Mr && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
      return !(d !== wr && n.convert(d) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_TYPE) && d !== Ni && !N);
    }
    function l(d) {
      if (d === "highp") {
        if (s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.HIGH_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision > 0) return "highp";
        d = "mediump";
      }
      return d === "mediump" && s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.MEDIUM_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
    }
    let c = t.precision !== void 0 ? t.precision : "highp";
    const h = l(c);
    h !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", h, "instead."), c = h);
    const f = t.logarithmicDepthBuffer === true, m = t.reverseDepthBuffer === true && e.has("EXT_clip_control"), _ = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS), y = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS), g = s.getParameter(s.MAX_TEXTURE_SIZE), x = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE), v = s.getParameter(s.MAX_VERTEX_ATTRIBS), E = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS), T = s.getParameter(s.MAX_VARYING_VECTORS), M = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS), P = y > 0, R = s.getParameter(s.MAX_SAMPLES);
    return {
      isWebGL2: true,
      getMaxAnisotropy: r,
      getMaxPrecision: l,
      textureFormatReadable: o,
      textureTypeReadable: a,
      precision: c,
      logarithmicDepthBuffer: f,
      reverseDepthBuffer: m,
      maxTextures: _,
      maxVertexTextures: y,
      maxTextureSize: g,
      maxCubemapSize: x,
      maxAttributes: v,
      maxVertexUniforms: E,
      maxVaryings: T,
      maxFragmentUniforms: M,
      vertexTextures: P,
      maxSamples: R
    };
  }
  function nM(s) {
    const e = this;
    let t = null, n = 0, i = false, r = false;
    const o = new xs(), a = new mt(), l = {
      value: null,
      needsUpdate: false
    };
    this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(f, m) {
      const _ = f.length !== 0 || m || n !== 0 || i;
      return i = m, n = f.length, _;
    }, this.beginShadows = function() {
      r = true, h(null);
    }, this.endShadows = function() {
      r = false;
    }, this.setGlobalState = function(f, m) {
      t = h(f, m, 0);
    }, this.setState = function(f, m, _) {
      const y = f.clippingPlanes, g = f.clipIntersection, x = f.clipShadows, v = s.get(f);
      if (!i || y === null || y.length === 0 || r && !x) r ? h(null) : c();
      else {
        const E = r ? 0 : n, T = E * 4;
        let M = v.clippingState || null;
        l.value = M, M = h(y, m, T, _);
        for (let P = 0; P !== T; ++P) M[P] = t[P];
        v.clippingState = M, this.numIntersection = g ? this.numPlanes : 0, this.numPlanes += E;
      }
    };
    function c() {
      l.value !== t && (l.value = t, l.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
    }
    function h(f, m, _, y) {
      const g = f !== null ? f.length : 0;
      let x = null;
      if (g !== 0) {
        if (x = l.value, y !== true || x === null) {
          const v = _ + g * 4, E = m.matrixWorldInverse;
          a.getNormalMatrix(E), (x === null || x.length < v) && (x = new Float32Array(v));
          for (let T = 0, M = _; T !== g; ++T, M += 4) o.copy(f[T]).applyMatrix4(E, a), o.normal.toArray(x, M), x[M + 3] = o.constant;
        }
        l.value = x, l.needsUpdate = true;
      }
      return e.numPlanes = g, e.numIntersection = 0, x;
    }
  }
  function iM(s) {
    let e = /* @__PURE__ */ new WeakMap();
    function t(o, a) {
      return a === mh ? o.mapping = Co : a === gh && (o.mapping = Ro), o;
    }
    function n(o) {
      if (o && o.isTexture) {
        const a = o.mapping;
        if (a === mh || a === gh) if (e.has(o)) {
          const l = e.get(o).texture;
          return t(l, o.mapping);
        } else {
          const l = o.image;
          if (l && l.height > 0) {
            const c = new Xv(l.height);
            return c.fromEquirectangularTexture(s, o), e.set(o, c), o.addEventListener("dispose", i), t(c.texture, o.mapping);
          } else return null;
        }
      }
      return o;
    }
    function i(o) {
      const a = o.target;
      a.removeEventListener("dispose", i);
      const l = e.get(a);
      l !== void 0 && (e.delete(a), l.dispose());
    }
    function r() {
      e = /* @__PURE__ */ new WeakMap();
    }
    return {
      get: n,
      dispose: r
    };
  }
  const go = 4, Ep = [
    0.125,
    0.215,
    0.35,
    0.446,
    0.526,
    0.582
  ], Ts = 20, ku = new Hc(), wp = new it();
  let Bu = null, zu = 0, Hu = 0, Vu = false;
  const bs = (1 + Math.sqrt(5)) / 2, lo = 1 / bs, Ap = [
    new V(-bs, lo, 0),
    new V(bs, lo, 0),
    new V(-lo, 0, bs),
    new V(lo, 0, bs),
    new V(0, bs, -lo),
    new V(0, bs, lo),
    new V(-1, 1, -1),
    new V(1, 1, -1),
    new V(-1, 1, 1),
    new V(1, 1, 1)
  ];
  class Cp {
    constructor(e) {
      this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
    }
    fromScene(e, t = 0, n = 0.1, i = 100) {
      Bu = this._renderer.getRenderTarget(), zu = this._renderer.getActiveCubeFace(), Hu = this._renderer.getActiveMipmapLevel(), Vu = this._renderer.xr.enabled, this._renderer.xr.enabled = false, this._setSize(256);
      const r = this._allocateTargets();
      return r.depthBuffer = true, this._sceneToCubeUV(e, n, i, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r;
    }
    fromEquirectangular(e, t = null) {
      return this._fromTexture(e, t);
    }
    fromCubemap(e, t = null) {
      return this._fromTexture(e, t);
    }
    compileCubemapShader() {
      this._cubemapMaterial === null && (this._cubemapMaterial = Dp(), this._compileMaterial(this._cubemapMaterial));
    }
    compileEquirectangularShader() {
      this._equirectMaterial === null && (this._equirectMaterial = Pp(), this._compileMaterial(this._equirectMaterial));
    }
    dispose() {
      this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
    }
    _setSize(e) {
      this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
    }
    _dispose() {
      this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
      for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose();
    }
    _cleanup(e) {
      this._renderer.setRenderTarget(Bu, zu, Hu), this._renderer.xr.enabled = Vu, e.scissorTest = false, ec(e, 0, 0, e.width, e.height);
    }
    _fromTexture(e, t) {
      e.mapping === Co || e.mapping === Ro ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Bu = this._renderer.getRenderTarget(), zu = this._renderer.getActiveCubeFace(), Hu = this._renderer.getActiveMipmapLevel(), Vu = this._renderer.xr.enabled, this._renderer.xr.enabled = false;
      const n = t || this._allocateTargets();
      return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
    }
    _allocateTargets() {
      const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, n = {
        magFilter: fi,
        minFilter: fi,
        generateMipmaps: false,
        type: Mr,
        format: Ti,
        colorSpace: $n,
        depthBuffer: false
      }, i = Rp(e, t, n);
      if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
        this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Rp(e, t, n);
        const { _lodMax: r } = this;
        ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = rM(r)), this._blurMaterial = sM(r, e, t);
      }
      return i;
    }
    _compileMaterial(e) {
      const t = new hn(this._lodPlanes[0], e);
      this._renderer.compile(t, ku);
    }
    _sceneToCubeUV(e, t, n, i) {
      const a = new Xn(90, 1, t, n), l = [
        1,
        -1,
        1,
        1,
        1,
        1
      ], c = [
        1,
        1,
        1,
        -1,
        -1,
        -1
      ], h = this._renderer, f = h.autoClear, m = h.toneMapping;
      h.getClearColor(wp), h.toneMapping = Qr, h.autoClear = false;
      const _ = new qi({
        name: "PMREM.Background",
        side: Qn,
        depthWrite: false,
        depthTest: false
      }), y = new hn(new ks(), _);
      let g = false;
      const x = e.background;
      x ? x.isColor && (_.color.copy(x), e.background = null, g = true) : (_.color.copy(wp), g = true);
      for (let v = 0; v < 6; v++) {
        const E = v % 3;
        E === 0 ? (a.up.set(0, l[v], 0), a.lookAt(c[v], 0, 0)) : E === 1 ? (a.up.set(0, 0, l[v]), a.lookAt(0, c[v], 0)) : (a.up.set(0, l[v], 0), a.lookAt(0, 0, c[v]));
        const T = this._cubeSize;
        ec(i, E * T, v > 2 ? T : 0, T, T), h.setRenderTarget(i), g && h.render(y, a), h.render(e, a);
      }
      y.geometry.dispose(), y.material.dispose(), h.toneMapping = m, h.autoClear = f, e.background = x;
    }
    _textureToCubeUV(e, t) {
      const n = this._renderer, i = e.mapping === Co || e.mapping === Ro;
      i ? (this._cubemapMaterial === null && (this._cubemapMaterial = Dp()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === false ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Pp());
      const r = i ? this._cubemapMaterial : this._equirectMaterial, o = new hn(this._lodPlanes[0], r), a = r.uniforms;
      a.envMap.value = e;
      const l = this._cubeSize;
      ec(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(o, ku);
    }
    _applyPMREM(e) {
      const t = this._renderer, n = t.autoClear;
      t.autoClear = false;
      const i = this._lodPlanes.length;
      for (let r = 1; r < i; r++) {
        const o = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), a = Ap[(i - r - 1) % Ap.length];
        this._blur(e, r - 1, r, o, a);
      }
      t.autoClear = n;
    }
    _blur(e, t, n, i, r) {
      const o = this._pingPongRenderTarget;
      this._halfBlur(e, o, t, n, i, "latitudinal", r), this._halfBlur(o, e, n, n, i, "longitudinal", r);
    }
    _halfBlur(e, t, n, i, r, o, a) {
      const l = this._renderer, c = this._blurMaterial;
      o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
      const h = 3, f = new hn(this._lodPlanes[i], c), m = c.uniforms, _ = this._sizeLods[n] - 1, y = isFinite(r) ? Math.PI / (2 * _) : 2 * Math.PI / (2 * Ts - 1), g = r / y, x = isFinite(r) ? 1 + Math.floor(h * g) : Ts;
      x > Ts && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${x} samples when the maximum is set to ${Ts}`);
      const v = [];
      let E = 0;
      for (let d = 0; d < Ts; ++d) {
        const N = d / g, w = Math.exp(-N * N / 2);
        v.push(w), d === 0 ? E += w : d < x && (E += 2 * w);
      }
      for (let d = 0; d < v.length; d++) v[d] = v[d] / E;
      m.envMap.value = e.texture, m.samples.value = x, m.weights.value = v, m.latitudinal.value = o === "latitudinal", a && (m.poleAxis.value = a);
      const { _lodMax: T } = this;
      m.dTheta.value = y, m.mipInt.value = T - n;
      const M = this._sizeLods[i], P = 3 * M * (i > T - go ? i - T + go : 0), R = 4 * (this._cubeSize - M);
      ec(t, P, R, 3 * M, 2 * M), l.setRenderTarget(t), l.render(f, ku);
    }
  }
  function rM(s) {
    const e = [], t = [], n = [];
    let i = s;
    const r = s - go + 1 + Ep.length;
    for (let o = 0; o < r; o++) {
      const a = Math.pow(2, i);
      t.push(a);
      let l = 1 / a;
      o > s - go ? l = Ep[o - s + go - 1] : o === 0 && (l = 0), n.push(l);
      const c = 1 / (a - 2), h = -c, f = 1 + c, m = [
        h,
        h,
        f,
        h,
        f,
        f,
        h,
        h,
        f,
        f,
        h,
        f
      ], _ = 6, y = 6, g = 3, x = 2, v = 1, E = new Float32Array(g * y * _), T = new Float32Array(x * y * _), M = new Float32Array(v * y * _);
      for (let R = 0; R < _; R++) {
        const d = R % 3 * 2 / 3 - 1, N = R > 2 ? 0 : -1, w = [
          d,
          N,
          0,
          d + 2 / 3,
          N,
          0,
          d + 2 / 3,
          N + 1,
          0,
          d,
          N,
          0,
          d + 2 / 3,
          N + 1,
          0,
          d,
          N + 1,
          0
        ];
        E.set(w, g * y * R), T.set(m, x * y * R);
        const D = [
          R,
          R,
          R,
          R,
          R,
          R
        ];
        M.set(D, v * y * R);
      }
      const P = new si();
      P.setAttribute("position", new jn(E, g)), P.setAttribute("uv", new jn(T, x)), P.setAttribute("faceIndex", new jn(M, v)), e.push(P), i > go && i--;
    }
    return {
      lodPlanes: e,
      sizeLods: t,
      sigmas: n
    };
  }
  function Rp(s, e, t) {
    const n = new Ui(s, e, t);
    return n.texture.mapping = kc, n.texture.name = "PMREM.cubeUv", n.scissorTest = true, n;
  }
  function ec(s, e, t, n, i) {
    s.viewport.set(e, t, n, i), s.scissor.set(e, t, n, i);
  }
  function sM(s, e, t) {
    const n = new Float32Array(Ts), i = new V(0, 1, 0);
    return new kn({
      name: "SphericalGaussianBlur",
      defines: {
        n: Ts,
        CUBEUV_TEXEL_WIDTH: 1 / e,
        CUBEUV_TEXEL_HEIGHT: 1 / t,
        CUBEUV_MAX_MIP: `${s}.0`
      },
      uniforms: {
        envMap: {
          value: null
        },
        samples: {
          value: 1
        },
        weights: {
          value: n
        },
        latitudinal: {
          value: false
        },
        dTheta: {
          value: 0
        },
        mipInt: {
          value: 0
        },
        poleAxis: {
          value: i
        }
      },
      vertexShader: Wf(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
      blending: Sr,
      depthTest: false,
      depthWrite: false
    });
  }
  function Pp() {
    return new kn({
      name: "EquirectangularToCubeUV",
      uniforms: {
        envMap: {
          value: null
        }
      },
      vertexShader: Wf(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
      blending: Sr,
      depthTest: false,
      depthWrite: false
    });
  }
  function Dp() {
    return new kn({
      name: "CubemapToCubeUV",
      uniforms: {
        envMap: {
          value: null
        },
        flipEnvMap: {
          value: -1
        }
      },
      vertexShader: Wf(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
      blending: Sr,
      depthTest: false,
      depthWrite: false
    });
  }
  function Wf() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
  }
  function oM(s) {
    let e = /* @__PURE__ */ new WeakMap(), t = null;
    function n(a) {
      if (a && a.isTexture) {
        const l = a.mapping, c = l === mh || l === gh, h = l === Co || l === Ro;
        if (c || h) {
          let f = e.get(a);
          const m = f !== void 0 ? f.texture.pmremVersion : 0;
          if (a.isRenderTargetTexture && a.pmremVersion !== m) return t === null && (t = new Cp(s)), f = c ? t.fromEquirectangular(a, f) : t.fromCubemap(a, f), f.texture.pmremVersion = a.pmremVersion, e.set(a, f), f.texture;
          if (f !== void 0) return f.texture;
          {
            const _ = a.image;
            return c && _ && _.height > 0 || h && _ && i(_) ? (t === null && (t = new Cp(s)), f = c ? t.fromEquirectangular(a) : t.fromCubemap(a), f.texture.pmremVersion = a.pmremVersion, e.set(a, f), a.addEventListener("dispose", r), f.texture) : null;
          }
        }
      }
      return a;
    }
    function i(a) {
      let l = 0;
      const c = 6;
      for (let h = 0; h < c; h++) a[h] !== void 0 && l++;
      return l === c;
    }
    function r(a) {
      const l = a.target;
      l.removeEventListener("dispose", r);
      const c = e.get(l);
      c !== void 0 && (e.delete(l), c.dispose());
    }
    function o() {
      e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
    }
    return {
      get: n,
      dispose: o
    };
  }
  function aM(s) {
    const e = {};
    function t(n) {
      if (e[n] !== void 0) return e[n];
      let i;
      switch (n) {
        case "WEBGL_depth_texture":
          i = s.getExtension("WEBGL_depth_texture") || s.getExtension("MOZ_WEBGL_depth_texture") || s.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          i = s.getExtension("EXT_texture_filter_anisotropic") || s.getExtension("MOZ_EXT_texture_filter_anisotropic") || s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          i = s.getExtension("WEBGL_compressed_texture_s3tc") || s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          i = s.getExtension("WEBGL_compressed_texture_pvrtc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          i = s.getExtension(n);
      }
      return e[n] = i, i;
    }
    return {
      has: function(n) {
        return t(n) !== null;
      },
      init: function() {
        t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture"), t("WEBGL_render_shared_exponent");
      },
      get: function(n) {
        const i = t(n);
        return i === null && ho("THREE.WebGLRenderer: " + n + " extension not supported."), i;
      }
    };
  }
  function lM(s, e, t, n) {
    const i = {}, r = /* @__PURE__ */ new WeakMap();
    function o(f) {
      const m = f.target;
      m.index !== null && e.remove(m.index);
      for (const y in m.attributes) e.remove(m.attributes[y]);
      m.removeEventListener("dispose", o), delete i[m.id];
      const _ = r.get(m);
      _ && (e.remove(_), r.delete(m)), n.releaseStatesOfGeometry(m), m.isInstancedBufferGeometry === true && delete m._maxInstanceCount, t.memory.geometries--;
    }
    function a(f, m) {
      return i[m.id] === true || (m.addEventListener("dispose", o), i[m.id] = true, t.memory.geometries++), m;
    }
    function l(f) {
      const m = f.attributes;
      for (const _ in m) e.update(m[_], s.ARRAY_BUFFER);
    }
    function c(f) {
      const m = [], _ = f.index, y = f.attributes.position;
      let g = 0;
      if (_ !== null) {
        const E = _.array;
        g = _.version;
        for (let T = 0, M = E.length; T < M; T += 3) {
          const P = E[T + 0], R = E[T + 1], d = E[T + 2];
          m.push(P, R, R, d, d, P);
        }
      } else if (y !== void 0) {
        const E = y.array;
        g = y.version;
        for (let T = 0, M = E.length / 3 - 1; T < M; T += 3) {
          const P = T + 0, R = T + 1, d = T + 2;
          m.push(P, R, R, d, d, P);
        }
      } else return;
      const x = new (qm(m) ? Zm : Km)(m, 1);
      x.version = g;
      const v = r.get(f);
      v && e.remove(v), r.set(f, x);
    }
    function h(f) {
      const m = r.get(f);
      if (m) {
        const _ = f.index;
        _ !== null && m.version < _.version && c(f);
      } else c(f);
      return r.get(f);
    }
    return {
      get: a,
      update: l,
      getWireframeAttribute: h
    };
  }
  function cM(s, e, t) {
    let n;
    function i(m) {
      n = m;
    }
    let r, o;
    function a(m) {
      r = m.type, o = m.bytesPerElement;
    }
    function l(m, _) {
      s.drawElements(n, _, r, m * o), t.update(_, n, 1);
    }
    function c(m, _, y) {
      y !== 0 && (s.drawElementsInstanced(n, _, r, m * o, y), t.update(_, n, y));
    }
    function h(m, _, y) {
      if (y === 0) return;
      e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, _, 0, r, m, 0, y);
      let x = 0;
      for (let v = 0; v < y; v++) x += _[v];
      t.update(x, n, 1);
    }
    function f(m, _, y, g) {
      if (y === 0) return;
      const x = e.get("WEBGL_multi_draw");
      if (x === null) for (let v = 0; v < m.length; v++) c(m[v] / o, _[v], g[v]);
      else {
        x.multiDrawElementsInstancedWEBGL(n, _, 0, r, m, 0, g, 0, y);
        let v = 0;
        for (let E = 0; E < y; E++) v += _[E] * g[E];
        t.update(v, n, 1);
      }
    }
    this.setMode = i, this.setIndex = a, this.render = l, this.renderInstances = c, this.renderMultiDraw = h, this.renderMultiDrawInstances = f;
  }
  function uM(s) {
    const e = {
      geometries: 0,
      textures: 0
    }, t = {
      frame: 0,
      calls: 0,
      triangles: 0,
      points: 0,
      lines: 0
    };
    function n(r, o, a) {
      switch (t.calls++, o) {
        case s.TRIANGLES:
          t.triangles += a * (r / 3);
          break;
        case s.LINES:
          t.lines += a * (r / 2);
          break;
        case s.LINE_STRIP:
          t.lines += a * (r - 1);
          break;
        case s.LINE_LOOP:
          t.lines += a * r;
          break;
        case s.POINTS:
          t.points += a * r;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", o);
          break;
      }
    }
    function i() {
      t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
    }
    return {
      memory: e,
      render: t,
      programs: null,
      autoReset: true,
      reset: i,
      update: n
    };
  }
  function hM(s, e, t) {
    const n = /* @__PURE__ */ new WeakMap(), i = new zt();
    function r(o, a, l) {
      const c = o.morphTargetInfluences, h = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color, f = h !== void 0 ? h.length : 0;
      let m = n.get(a);
      if (m === void 0 || m.count !== f) {
        let w = function() {
          d.dispose(), n.delete(a), a.removeEventListener("dispose", w);
        };
        m !== void 0 && m.texture.dispose();
        const _ = a.morphAttributes.position !== void 0, y = a.morphAttributes.normal !== void 0, g = a.morphAttributes.color !== void 0, x = a.morphAttributes.position || [], v = a.morphAttributes.normal || [], E = a.morphAttributes.color || [];
        let T = 0;
        _ === true && (T = 1), y === true && (T = 2), g === true && (T = 3);
        let M = a.attributes.position.count * T, P = 1;
        M > e.maxTextureSize && (P = Math.ceil(M / e.maxTextureSize), M = e.maxTextureSize);
        const R = new Float32Array(M * P * 4 * f), d = new jm(R, M, P, f);
        d.type = Ni, d.needsUpdate = true;
        const N = T * 4;
        for (let D = 0; D < f; D++) {
          const B = x[D], Z = v[D], G = E[D], Q = M * P * 4 * D;
          for (let ue = 0; ue < B.count; ue++) {
            const te = ue * N;
            _ === true && (i.fromBufferAttribute(B, ue), R[Q + te + 0] = i.x, R[Q + te + 1] = i.y, R[Q + te + 2] = i.z, R[Q + te + 3] = 0), y === true && (i.fromBufferAttribute(Z, ue), R[Q + te + 4] = i.x, R[Q + te + 5] = i.y, R[Q + te + 6] = i.z, R[Q + te + 7] = 0), g === true && (i.fromBufferAttribute(G, ue), R[Q + te + 8] = i.x, R[Q + te + 9] = i.y, R[Q + te + 10] = i.z, R[Q + te + 11] = G.itemSize === 4 ? i.w : 1);
          }
        }
        m = {
          count: f,
          texture: d,
          size: new Se(M, P)
        }, n.set(a, m), a.addEventListener("dispose", w);
      }
      if (o.isInstancedMesh === true && o.morphTexture !== null) l.getUniforms().setValue(s, "morphTexture", o.morphTexture, t);
      else {
        let _ = 0;
        for (let g = 0; g < c.length; g++) _ += c[g];
        const y = a.morphTargetsRelative ? 1 : 1 - _;
        l.getUniforms().setValue(s, "morphTargetBaseInfluence", y), l.getUniforms().setValue(s, "morphTargetInfluences", c);
      }
      l.getUniforms().setValue(s, "morphTargetsTexture", m.texture, t), l.getUniforms().setValue(s, "morphTargetsTextureSize", m.size);
    }
    return {
      update: r
    };
  }
  function fM(s, e, t, n) {
    let i = /* @__PURE__ */ new WeakMap();
    function r(l) {
      const c = n.render.frame, h = l.geometry, f = e.get(l, h);
      if (i.get(f) !== c && (e.update(f), i.set(f, c)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === false && l.addEventListener("dispose", a), i.get(l) !== c && (t.update(l.instanceMatrix, s.ARRAY_BUFFER), l.instanceColor !== null && t.update(l.instanceColor, s.ARRAY_BUFFER), i.set(l, c))), l.isSkinnedMesh) {
        const m = l.skeleton;
        i.get(m) !== c && (m.update(), i.set(m, c));
      }
      return f;
    }
    function o() {
      i = /* @__PURE__ */ new WeakMap();
    }
    function a(l) {
      const c = l.target;
      c.removeEventListener("dispose", a), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor);
    }
    return {
      update: r,
      dispose: o
    };
  }
  const vg = new Mn(), Lp = new sg(1, 1), yg = new jm(), xg = new Rv(), bg = new eg(), Ip = [], Np = [], Up = new Float32Array(16), Op = new Float32Array(9), Fp = new Float32Array(4);
  function Ko(s, e, t) {
    const n = s[0];
    if (n <= 0 || n > 0) return s;
    const i = e * t;
    let r = Ip[i];
    if (r === void 0 && (r = new Float32Array(i), Ip[i] = r), e !== 0) {
      n.toArray(r, 0);
      for (let o = 1, a = 0; o !== e; ++o) a += t, s[o].toArray(r, a);
    }
    return r;
  }
  function Tn(s, e) {
    if (s.length !== e.length) return false;
    for (let t = 0, n = s.length; t < n; t++) if (s[t] !== e[t]) return false;
    return true;
  }
  function En(s, e) {
    for (let t = 0, n = e.length; t < n; t++) s[t] = e[t];
  }
  function Vc(s, e) {
    let t = Np[e];
    t === void 0 && (t = new Int32Array(e), Np[e] = t);
    for (let n = 0; n !== e; ++n) t[n] = s.allocateTextureUnit();
    return t;
  }
  function dM(s, e) {
    const t = this.cache;
    t[0] !== e && (s.uniform1f(this.addr, e), t[0] = e);
  }
  function pM(s, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (s.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
    else {
      if (Tn(t, e)) return;
      s.uniform2fv(this.addr, e), En(t, e);
    }
  }
  function mM(s, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
    else if (e.r !== void 0) (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (s.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
    else {
      if (Tn(t, e)) return;
      s.uniform3fv(this.addr, e), En(t, e);
    }
  }
  function gM(s, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
    else {
      if (Tn(t, e)) return;
      s.uniform4fv(this.addr, e), En(t, e);
    }
  }
  function _M(s, e) {
    const t = this.cache, n = e.elements;
    if (n === void 0) {
      if (Tn(t, e)) return;
      s.uniformMatrix2fv(this.addr, false, e), En(t, e);
    } else {
      if (Tn(t, n)) return;
      Fp.set(n), s.uniformMatrix2fv(this.addr, false, Fp), En(t, n);
    }
  }
  function vM(s, e) {
    const t = this.cache, n = e.elements;
    if (n === void 0) {
      if (Tn(t, e)) return;
      s.uniformMatrix3fv(this.addr, false, e), En(t, e);
    } else {
      if (Tn(t, n)) return;
      Op.set(n), s.uniformMatrix3fv(this.addr, false, Op), En(t, n);
    }
  }
  function yM(s, e) {
    const t = this.cache, n = e.elements;
    if (n === void 0) {
      if (Tn(t, e)) return;
      s.uniformMatrix4fv(this.addr, false, e), En(t, e);
    } else {
      if (Tn(t, n)) return;
      Up.set(n), s.uniformMatrix4fv(this.addr, false, Up), En(t, n);
    }
  }
  function xM(s, e) {
    const t = this.cache;
    t[0] !== e && (s.uniform1i(this.addr, e), t[0] = e);
  }
  function bM(s, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (s.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
    else {
      if (Tn(t, e)) return;
      s.uniform2iv(this.addr, e), En(t, e);
    }
  }
  function SM(s, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
    else {
      if (Tn(t, e)) return;
      s.uniform3iv(this.addr, e), En(t, e);
    }
  }
  function MM(s, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
    else {
      if (Tn(t, e)) return;
      s.uniform4iv(this.addr, e), En(t, e);
    }
  }
  function TM(s, e) {
    const t = this.cache;
    t[0] !== e && (s.uniform1ui(this.addr, e), t[0] = e);
  }
  function EM(s, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (s.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
    else {
      if (Tn(t, e)) return;
      s.uniform2uiv(this.addr, e), En(t, e);
    }
  }
  function wM(s, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
    else {
      if (Tn(t, e)) return;
      s.uniform3uiv(this.addr, e), En(t, e);
    }
  }
  function AM(s, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
    else {
      if (Tn(t, e)) return;
      s.uniform4uiv(this.addr, e), En(t, e);
    }
  }
  function CM(s, e, t) {
    const n = this.cache, i = t.allocateTextureUnit();
    n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i);
    let r;
    this.type === s.SAMPLER_2D_SHADOW ? (Lp.compareFunction = Xm, r = Lp) : r = vg, t.setTexture2D(e || r, i);
  }
  function RM(s, e, t) {
    const n = this.cache, i = t.allocateTextureUnit();
    n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i), t.setTexture3D(e || xg, i);
  }
  function PM(s, e, t) {
    const n = this.cache, i = t.allocateTextureUnit();
    n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i), t.setTextureCube(e || bg, i);
  }
  function DM(s, e, t) {
    const n = this.cache, i = t.allocateTextureUnit();
    n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i), t.setTexture2DArray(e || yg, i);
  }
  function LM(s) {
    switch (s) {
      case 5126:
        return dM;
      case 35664:
        return pM;
      case 35665:
        return mM;
      case 35666:
        return gM;
      case 35674:
        return _M;
      case 35675:
        return vM;
      case 35676:
        return yM;
      case 5124:
      case 35670:
        return xM;
      case 35667:
      case 35671:
        return bM;
      case 35668:
      case 35672:
        return SM;
      case 35669:
      case 35673:
        return MM;
      case 5125:
        return TM;
      case 36294:
        return EM;
      case 36295:
        return wM;
      case 36296:
        return AM;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return CM;
      case 35679:
      case 36299:
      case 36307:
        return RM;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return PM;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return DM;
    }
  }
  function IM(s, e) {
    s.uniform1fv(this.addr, e);
  }
  function NM(s, e) {
    const t = Ko(e, this.size, 2);
    s.uniform2fv(this.addr, t);
  }
  function UM(s, e) {
    const t = Ko(e, this.size, 3);
    s.uniform3fv(this.addr, t);
  }
  function OM(s, e) {
    const t = Ko(e, this.size, 4);
    s.uniform4fv(this.addr, t);
  }
  function FM(s, e) {
    const t = Ko(e, this.size, 4);
    s.uniformMatrix2fv(this.addr, false, t);
  }
  function kM(s, e) {
    const t = Ko(e, this.size, 9);
    s.uniformMatrix3fv(this.addr, false, t);
  }
  function BM(s, e) {
    const t = Ko(e, this.size, 16);
    s.uniformMatrix4fv(this.addr, false, t);
  }
  function zM(s, e) {
    s.uniform1iv(this.addr, e);
  }
  function HM(s, e) {
    s.uniform2iv(this.addr, e);
  }
  function VM(s, e) {
    s.uniform3iv(this.addr, e);
  }
  function GM(s, e) {
    s.uniform4iv(this.addr, e);
  }
  function WM(s, e) {
    s.uniform1uiv(this.addr, e);
  }
  function XM(s, e) {
    s.uniform2uiv(this.addr, e);
  }
  function qM(s, e) {
    s.uniform3uiv(this.addr, e);
  }
  function YM(s, e) {
    s.uniform4uiv(this.addr, e);
  }
  function jM(s, e, t) {
    const n = this.cache, i = e.length, r = Vc(t, i);
    Tn(n, r) || (s.uniform1iv(this.addr, r), En(n, r));
    for (let o = 0; o !== i; ++o) t.setTexture2D(e[o] || vg, r[o]);
  }
  function $M(s, e, t) {
    const n = this.cache, i = e.length, r = Vc(t, i);
    Tn(n, r) || (s.uniform1iv(this.addr, r), En(n, r));
    for (let o = 0; o !== i; ++o) t.setTexture3D(e[o] || xg, r[o]);
  }
  function KM(s, e, t) {
    const n = this.cache, i = e.length, r = Vc(t, i);
    Tn(n, r) || (s.uniform1iv(this.addr, r), En(n, r));
    for (let o = 0; o !== i; ++o) t.setTextureCube(e[o] || bg, r[o]);
  }
  function ZM(s, e, t) {
    const n = this.cache, i = e.length, r = Vc(t, i);
    Tn(n, r) || (s.uniform1iv(this.addr, r), En(n, r));
    for (let o = 0; o !== i; ++o) t.setTexture2DArray(e[o] || yg, r[o]);
  }
  function JM(s) {
    switch (s) {
      case 5126:
        return IM;
      case 35664:
        return NM;
      case 35665:
        return UM;
      case 35666:
        return OM;
      case 35674:
        return FM;
      case 35675:
        return kM;
      case 35676:
        return BM;
      case 5124:
      case 35670:
        return zM;
      case 35667:
      case 35671:
        return HM;
      case 35668:
      case 35672:
        return VM;
      case 35669:
      case 35673:
        return GM;
      case 5125:
        return WM;
      case 36294:
        return XM;
      case 36295:
        return qM;
      case 36296:
        return YM;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return jM;
      case 35679:
      case 36299:
      case 36307:
        return $M;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return KM;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return ZM;
    }
  }
  class QM {
    constructor(e, t, n) {
      this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = LM(t.type);
    }
  }
  class eT {
    constructor(e, t, n) {
      this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = JM(t.type);
    }
  }
  class tT {
    constructor(e) {
      this.id = e, this.seq = [], this.map = {};
    }
    setValue(e, t, n) {
      const i = this.seq;
      for (let r = 0, o = i.length; r !== o; ++r) {
        const a = i[r];
        a.setValue(e, t[a.id], n);
      }
    }
  }
  const Gu = /(\w+)(\])?(\[|\.)?/g;
  function kp(s, e) {
    s.seq.push(e), s.map[e.id] = e;
  }
  function nT(s, e, t) {
    const n = s.name, i = n.length;
    for (Gu.lastIndex = 0; ; ) {
      const r = Gu.exec(n), o = Gu.lastIndex;
      let a = r[1];
      const l = r[2] === "]", c = r[3];
      if (l && (a = a | 0), c === void 0 || c === "[" && o + 2 === i) {
        kp(t, c === void 0 ? new QM(a, s, e) : new eT(a, s, e));
        break;
      } else {
        let f = t.map[a];
        f === void 0 && (f = new tT(a), kp(t, f)), t = f;
      }
    }
  }
  class fc {
    constructor(e, t) {
      this.seq = [], this.map = {};
      const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
      for (let i = 0; i < n; ++i) {
        const r = e.getActiveUniform(t, i), o = e.getUniformLocation(t, r.name);
        nT(r, o, this);
      }
    }
    setValue(e, t, n, i) {
      const r = this.map[t];
      r !== void 0 && r.setValue(e, n, i);
    }
    setOptional(e, t, n) {
      const i = t[n];
      i !== void 0 && this.setValue(e, n, i);
    }
    static upload(e, t, n, i) {
      for (let r = 0, o = t.length; r !== o; ++r) {
        const a = t[r], l = n[a.id];
        l.needsUpdate !== false && a.setValue(e, l.value, i);
      }
    }
    static seqWithValue(e, t) {
      const n = [];
      for (let i = 0, r = e.length; i !== r; ++i) {
        const o = e[i];
        o.id in t && n.push(o);
      }
      return n;
    }
  }
  function Bp(s, e, t) {
    const n = s.createShader(e);
    return s.shaderSource(n, t), s.compileShader(n), n;
  }
  const iT = 37297;
  let rT = 0;
  function sT(s, e) {
    const t = s.split(`
`), n = [], i = Math.max(e - 6, 0), r = Math.min(e + 6, t.length);
    for (let o = i; o < r; o++) {
      const a = o + 1;
      n.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`);
    }
    return n.join(`
`);
  }
  const zp = new mt();
  function oT(s) {
    It._getMatrix(zp, It.workingColorSpace, s);
    const e = `mat3( ${zp.elements.map((t) => t.toFixed(4))} )`;
    switch (It.getTransfer(s)) {
      case Sc:
        return [
          e,
          "LinearTransferOETF"
        ];
      case $t:
        return [
          e,
          "sRGBTransferOETF"
        ];
      default:
        return console.warn("THREE.WebGLProgram: Unsupported color space: ", s), [
          e,
          "LinearTransferOETF"
        ];
    }
  }
  function Hp(s, e, t) {
    const n = s.getShaderParameter(e, s.COMPILE_STATUS), i = s.getShaderInfoLog(e).trim();
    if (n && i === "") return "";
    const r = /ERROR: 0:(\d+)/.exec(i);
    if (r) {
      const o = parseInt(r[1]);
      return t.toUpperCase() + `

` + i + `

` + sT(s.getShaderSource(e), o);
    } else return i;
  }
  function aT(s, e) {
    const t = oT(e);
    return [
      `vec4 ${s}( vec4 value ) {`,
      `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,
      "}"
    ].join(`
`);
  }
  function lT(s, e) {
    let t;
    switch (e) {
      case F0:
        t = "Linear";
        break;
      case k0:
        t = "Reinhard";
        break;
      case B0:
        t = "Cineon";
        break;
      case z0:
        t = "ACESFilmic";
        break;
      case V0:
        t = "AgX";
        break;
      case G0:
        t = "Neutral";
        break;
      case H0:
        t = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
    }
    return "vec3 " + s + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
  }
  const tc = new V();
  function cT() {
    It.getLuminanceCoefficients(tc);
    const s = tc.x.toFixed(4), e = tc.y.toFixed(4), t = tc.z.toFixed(4);
    return [
      "float luminance( const in vec3 rgb ) {",
      `	const vec3 weights = vec3( ${s}, ${e}, ${t} );`,
      "	return dot( weights, rgb );",
      "}"
    ].join(`
`);
  }
  function uT(s) {
    return [
      s.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
      s.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
    ].filter(Na).join(`
`);
  }
  function hT(s) {
    const e = [];
    for (const t in s) {
      const n = s[t];
      n !== false && e.push("#define " + t + " " + n);
    }
    return e.join(`
`);
  }
  function fT(s, e) {
    const t = {}, n = s.getProgramParameter(e, s.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < n; i++) {
      const r = s.getActiveAttrib(e, i), o = r.name;
      let a = 1;
      r.type === s.FLOAT_MAT2 && (a = 2), r.type === s.FLOAT_MAT3 && (a = 3), r.type === s.FLOAT_MAT4 && (a = 4), t[o] = {
        type: r.type,
        location: s.getAttribLocation(e, o),
        locationSize: a
      };
    }
    return t;
  }
  function Na(s) {
    return s !== "";
  }
  function Vp(s, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return s.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
  }
  function Gp(s, e) {
    return s.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
  }
  const dT = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function Jh(s) {
    return s.replace(dT, mT);
  }
  const pT = /* @__PURE__ */ new Map();
  function mT(s, e) {
    let t = _t[e];
    if (t === void 0) {
      const n = pT.get(e);
      if (n !== void 0) t = _t[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
      else throw new Error("Can not resolve #include <" + e + ">");
    }
    return Jh(t);
  }
  const gT = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function Wp(s) {
    return s.replace(gT, _T);
  }
  function _T(s, e, t, n) {
    let i = "";
    for (let r = parseInt(e); r < parseInt(t); r++) i += n.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
    return i;
  }
  function Xp(s) {
    let e = `precision ${s.precision} float;
	precision ${s.precision} int;
	precision ${s.precision} sampler2D;
	precision ${s.precision} samplerCube;
	precision ${s.precision} sampler3D;
	precision ${s.precision} sampler2DArray;
	precision ${s.precision} sampler2DShadow;
	precision ${s.precision} samplerCubeShadow;
	precision ${s.precision} sampler2DArrayShadow;
	precision ${s.precision} isampler2D;
	precision ${s.precision} isampler3D;
	precision ${s.precision} isamplerCube;
	precision ${s.precision} isampler2DArray;
	precision ${s.precision} usampler2D;
	precision ${s.precision} usampler3D;
	precision ${s.precision} usamplerCube;
	precision ${s.precision} usampler2DArray;
	`;
    return s.precision === "highp" ? e += `
#define HIGH_PRECISION` : s.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : s.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
  }
  function vT(s) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return s.shadowMapType === Pm ? e = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === g0 ? e = "SHADOWMAP_TYPE_PCF_SOFT" : s.shadowMapType === mr && (e = "SHADOWMAP_TYPE_VSM"), e;
  }
  function yT(s) {
    let e = "ENVMAP_TYPE_CUBE";
    if (s.envMap) switch (s.envMapMode) {
      case Co:
      case Ro:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case kc:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
    return e;
  }
  function xT(s) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (s.envMap) switch (s.envMapMode) {
      case Ro:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
    return e;
  }
  function bT(s) {
    let e = "ENVMAP_BLENDING_NONE";
    if (s.envMap) switch (s.combine) {
      case Dm:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case U0:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case O0:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
    return e;
  }
  function ST(s) {
    const e = s.envMapCubeUVHeight;
    if (e === null) return null;
    const t = Math.log2(e) - 2, n = 1 / e;
    return {
      texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
      texelHeight: n,
      maxMip: t
    };
  }
  function MT(s, e, t, n) {
    const i = s.getContext(), r = t.defines;
    let o = t.vertexShader, a = t.fragmentShader;
    const l = vT(t), c = yT(t), h = xT(t), f = bT(t), m = ST(t), _ = uT(t), y = hT(r), g = i.createProgram();
    let x, v, E = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (x = [
      "#define SHADER_TYPE " + t.shaderType,
      "#define SHADER_NAME " + t.shaderName,
      y
    ].filter(Na).join(`
`), x.length > 0 && (x += `
`), v = [
      "#define SHADER_TYPE " + t.shaderType,
      "#define SHADER_NAME " + t.shaderName,
      y
    ].filter(Na).join(`
`), v.length > 0 && (v += `
`)) : (x = [
      Xp(t),
      "#define SHADER_TYPE " + t.shaderType,
      "#define SHADER_NAME " + t.shaderName,
      y,
      t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
      t.batching ? "#define USE_BATCHING" : "",
      t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
      t.instancing ? "#define USE_INSTANCING" : "",
      t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
      t.useFog && t.fog ? "#define USE_FOG" : "",
      t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
      t.map ? "#define USE_MAP" : "",
      t.envMap ? "#define USE_ENVMAP" : "",
      t.envMap ? "#define " + h : "",
      t.lightMap ? "#define USE_LIGHTMAP" : "",
      t.aoMap ? "#define USE_AOMAP" : "",
      t.bumpMap ? "#define USE_BUMPMAP" : "",
      t.normalMap ? "#define USE_NORMALMAP" : "",
      t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
      t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
      t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
      t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      t.anisotropy ? "#define USE_ANISOTROPY" : "",
      t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      t.specularMap ? "#define USE_SPECULARMAP" : "",
      t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
      t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      t.metalnessMap ? "#define USE_METALNESSMAP" : "",
      t.alphaMap ? "#define USE_ALPHAMAP" : "",
      t.alphaHash ? "#define USE_ALPHAHASH" : "",
      t.transmission ? "#define USE_TRANSMISSION" : "",
      t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      t.mapUv ? "#define MAP_UV " + t.mapUv : "",
      t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
      t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
      t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
      t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
      t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
      t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
      t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
      t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
      t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
      t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
      t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
      t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
      t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
      t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
      t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
      t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
      t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
      t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
      t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
      t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
      t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
      t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
      t.vertexTangents && t.flatShading === false ? "#define USE_TANGENT" : "",
      t.vertexColors ? "#define USE_COLOR" : "",
      t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      t.vertexUv1s ? "#define USE_UV1" : "",
      t.vertexUv2s ? "#define USE_UV2" : "",
      t.vertexUv3s ? "#define USE_UV3" : "",
      t.pointsUvs ? "#define USE_POINTS_UV" : "",
      t.flatShading ? "#define FLAT_SHADED" : "",
      t.skinning ? "#define USE_SKINNING" : "",
      t.morphTargets ? "#define USE_MORPHTARGETS" : "",
      t.morphNormals && t.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      t.morphColors ? "#define USE_MORPHCOLORS" : "",
      t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
      t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
      t.doubleSided ? "#define DOUBLE_SIDED" : "",
      t.flipSided ? "#define FLIP_SIDED" : "",
      t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      t.shadowMapEnabled ? "#define " + l : "",
      t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
      t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "#ifdef USE_INSTANCING_MORPH",
      "	uniform sampler2D morphTexture;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_UV1",
      "	attribute vec2 uv1;",
      "#endif",
      "#ifdef USE_UV2",
      "	attribute vec2 uv2;",
      "#endif",
      "#ifdef USE_UV3",
      "	attribute vec2 uv3;",
      "#endif",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      `
`
    ].filter(Na).join(`
`), v = [
      Xp(t),
      "#define SHADER_TYPE " + t.shaderType,
      "#define SHADER_NAME " + t.shaderName,
      y,
      t.useFog && t.fog ? "#define USE_FOG" : "",
      t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
      t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
      t.map ? "#define USE_MAP" : "",
      t.matcap ? "#define USE_MATCAP" : "",
      t.envMap ? "#define USE_ENVMAP" : "",
      t.envMap ? "#define " + c : "",
      t.envMap ? "#define " + h : "",
      t.envMap ? "#define " + f : "",
      m ? "#define CUBEUV_TEXEL_WIDTH " + m.texelWidth : "",
      m ? "#define CUBEUV_TEXEL_HEIGHT " + m.texelHeight : "",
      m ? "#define CUBEUV_MAX_MIP " + m.maxMip + ".0" : "",
      t.lightMap ? "#define USE_LIGHTMAP" : "",
      t.aoMap ? "#define USE_AOMAP" : "",
      t.bumpMap ? "#define USE_BUMPMAP" : "",
      t.normalMap ? "#define USE_NORMALMAP" : "",
      t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
      t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
      t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      t.anisotropy ? "#define USE_ANISOTROPY" : "",
      t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      t.clearcoat ? "#define USE_CLEARCOAT" : "",
      t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      t.dispersion ? "#define USE_DISPERSION" : "",
      t.iridescence ? "#define USE_IRIDESCENCE" : "",
      t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      t.specularMap ? "#define USE_SPECULARMAP" : "",
      t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
      t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      t.metalnessMap ? "#define USE_METALNESSMAP" : "",
      t.alphaMap ? "#define USE_ALPHAMAP" : "",
      t.alphaTest ? "#define USE_ALPHATEST" : "",
      t.alphaHash ? "#define USE_ALPHAHASH" : "",
      t.sheen ? "#define USE_SHEEN" : "",
      t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      t.transmission ? "#define USE_TRANSMISSION" : "",
      t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      t.vertexTangents && t.flatShading === false ? "#define USE_TANGENT" : "",
      t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "",
      t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      t.vertexUv1s ? "#define USE_UV1" : "",
      t.vertexUv2s ? "#define USE_UV2" : "",
      t.vertexUv3s ? "#define USE_UV3" : "",
      t.pointsUvs ? "#define USE_POINTS_UV" : "",
      t.gradientMap ? "#define USE_GRADIENTMAP" : "",
      t.flatShading ? "#define FLAT_SHADED" : "",
      t.doubleSided ? "#define DOUBLE_SIDED" : "",
      t.flipSided ? "#define FLIP_SIDED" : "",
      t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      t.shadowMapEnabled ? "#define " + l : "",
      t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
      t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
      t.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
      t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      t.toneMapping !== Qr ? "#define TONE_MAPPING" : "",
      t.toneMapping !== Qr ? _t.tonemapping_pars_fragment : "",
      t.toneMapping !== Qr ? lT("toneMapping", t.toneMapping) : "",
      t.dithering ? "#define DITHERING" : "",
      t.opaque ? "#define OPAQUE" : "",
      _t.colorspace_pars_fragment,
      aT("linearToOutputTexel", t.outputColorSpace),
      cT(),
      t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
      `
`
    ].filter(Na).join(`
`)), o = Jh(o), o = Vp(o, t), o = Gp(o, t), a = Jh(a), a = Vp(a, t), a = Gp(a, t), o = Wp(o), a = Wp(a), t.isRawShaderMaterial !== true && (E = `#version 300 es
`, x = [
      _,
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join(`
`) + `
` + x, v = [
      "#define varying in",
      t.glslVersion === Nd ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
      t.glslVersion === Nd ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join(`
`) + `
` + v);
    const T = E + x + o, M = E + v + a, P = Bp(i, i.VERTEX_SHADER, T), R = Bp(i, i.FRAGMENT_SHADER, M);
    i.attachShader(g, P), i.attachShader(g, R), t.index0AttributeName !== void 0 ? i.bindAttribLocation(g, 0, t.index0AttributeName) : t.morphTargets === true && i.bindAttribLocation(g, 0, "position"), i.linkProgram(g);
    function d(B) {
      if (s.debug.checkShaderErrors) {
        const Z = i.getProgramInfoLog(g).trim(), G = i.getShaderInfoLog(P).trim(), Q = i.getShaderInfoLog(R).trim();
        let ue = true, te = true;
        if (i.getProgramParameter(g, i.LINK_STATUS) === false) if (ue = false, typeof s.debug.onShaderError == "function") s.debug.onShaderError(i, g, P, R);
        else {
          const he = Hp(i, P, "vertex"), ie = Hp(i, R, "fragment");
          console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(g, i.VALIDATE_STATUS) + `

Material Name: ` + B.name + `
Material Type: ` + B.type + `

Program Info Log: ` + Z + `
` + he + `
` + ie);
        }
        else Z !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", Z) : (G === "" || Q === "") && (te = false);
        te && (B.diagnostics = {
          runnable: ue,
          programLog: Z,
          vertexShader: {
            log: G,
            prefix: x
          },
          fragmentShader: {
            log: Q,
            prefix: v
          }
        });
      }
      i.deleteShader(P), i.deleteShader(R), N = new fc(i, g), w = fT(i, g);
    }
    let N;
    this.getUniforms = function() {
      return N === void 0 && d(this), N;
    };
    let w;
    this.getAttributes = function() {
      return w === void 0 && d(this), w;
    };
    let D = t.rendererExtensionParallelShaderCompile === false;
    return this.isReady = function() {
      return D === false && (D = i.getProgramParameter(g, iT)), D;
    }, this.destroy = function() {
      n.releaseStatesOfProgram(this), i.deleteProgram(g), this.program = void 0;
    }, this.type = t.shaderType, this.name = t.shaderName, this.id = rT++, this.cacheKey = e, this.usedTimes = 1, this.program = g, this.vertexShader = P, this.fragmentShader = R, this;
  }
  let TT = 0;
  class ET {
    constructor() {
      this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
    }
    update(e) {
      const t = e.vertexShader, n = e.fragmentShader, i = this._getShaderStage(t), r = this._getShaderStage(n), o = this._getShaderCacheForMaterial(e);
      return o.has(i) === false && (o.add(i), i.usedTimes++), o.has(r) === false && (o.add(r), r.usedTimes++), this;
    }
    remove(e) {
      const t = this.materialCache.get(e);
      for (const n of t) n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
      return this.materialCache.delete(e), this;
    }
    getVertexShaderID(e) {
      return this._getShaderStage(e.vertexShader).id;
    }
    getFragmentShaderID(e) {
      return this._getShaderStage(e.fragmentShader).id;
    }
    dispose() {
      this.shaderCache.clear(), this.materialCache.clear();
    }
    _getShaderCacheForMaterial(e) {
      const t = this.materialCache;
      let n = t.get(e);
      return n === void 0 && (n = /* @__PURE__ */ new Set(), t.set(e, n)), n;
    }
    _getShaderStage(e) {
      const t = this.shaderCache;
      let n = t.get(e);
      return n === void 0 && (n = new wT(e), t.set(e, n)), n;
    }
  }
  class wT {
    constructor(e) {
      this.id = TT++, this.code = e, this.usedTimes = 0;
    }
  }
  function AT(s, e, t, n, i, r, o) {
    const a = new Rf(), l = new ET(), c = /* @__PURE__ */ new Set(), h = [], f = i.logarithmicDepthBuffer, m = i.vertexTextures;
    let _ = i.precision;
    const y = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite"
    };
    function g(w) {
      return c.add(w), w === 0 ? "uv" : `uv${w}`;
    }
    function x(w, D, B, Z, G) {
      const Q = Z.fog, ue = G.geometry, te = w.isMeshStandardMaterial ? Z.environment : null, he = (w.isMeshStandardMaterial ? t : e).get(w.envMap || te), ie = he && he.mapping === kc ? he.image.height : null, Me = y[w.type];
      w.precision !== null && (_ = i.getMaxPrecision(w.precision), _ !== w.precision && console.warn("THREE.WebGLProgram.getParameters:", w.precision, "not supported, using", _, "instead."));
      const Ce = ue.morphAttributes.position || ue.morphAttributes.normal || ue.morphAttributes.color, Le = Ce !== void 0 ? Ce.length : 0;
      let Je = 0;
      ue.morphAttributes.position !== void 0 && (Je = 1), ue.morphAttributes.normal !== void 0 && (Je = 2), ue.morphAttributes.color !== void 0 && (Je = 3);
      let dt, ce, ve, qe;
      if (Me) {
        const kt = Gi[Me];
        dt = kt.vertexShader, ce = kt.fragmentShader;
      } else dt = w.vertexShader, ce = w.fragmentShader, l.update(w), ve = l.getVertexShaderID(w), qe = l.getFragmentShaderID(w);
      const Te = s.getRenderTarget(), Ye = s.state.buffers.depth.getReversed(), lt = G.isInstancedMesh === true, Fe = G.isBatchedMesh === true, Nt = !!w.map, _e = !!w.matcap, ge = !!he, k = !!w.aoMap, Ke = !!w.lightMap, ye = !!w.bumpMap, ze = !!w.normalMap, Ee = !!w.displacementMap, st = !!w.emissiveMap, Ue = !!w.metalnessMap, O = !!w.roughnessMap, I = w.anisotropy > 0, $ = w.clearcoat > 0, fe = w.dispersion > 0, K = w.iridescence > 0, le = w.sheen > 0, je = w.transmission > 0, Re = I && !!w.anisotropyMap, Ge = $ && !!w.clearcoatMap, vt = $ && !!w.clearcoatNormalMap, we = $ && !!w.clearcoatRoughnessMap, Ve = K && !!w.iridescenceMap, Ze = K && !!w.iridescenceThicknessMap, nt = le && !!w.sheenColorMap, He = le && !!w.sheenRoughnessMap, wt = !!w.specularMap, ht = !!w.specularColorMap, Wt = !!w.specularIntensityMap, q = je && !!w.transmissionMap, Ie = je && !!w.thicknessMap, ae = !!w.gradientMap, me = !!w.alphaMap, Oe = w.alphaTest > 0, Ne = !!w.alphaHash, tt = !!w.extensions;
      let bt = Qr;
      w.toneMapped && (Te === null || Te.isXRRenderTarget === true) && (bt = s.toneMapping);
      const fn = {
        shaderID: Me,
        shaderType: w.type,
        shaderName: w.name,
        vertexShader: dt,
        fragmentShader: ce,
        defines: w.defines,
        customVertexShaderID: ve,
        customFragmentShaderID: qe,
        isRawShaderMaterial: w.isRawShaderMaterial === true,
        glslVersion: w.glslVersion,
        precision: _,
        batching: Fe,
        batchingColor: Fe && G._colorsTexture !== null,
        instancing: lt,
        instancingColor: lt && G.instanceColor !== null,
        instancingMorph: lt && G.morphTexture !== null,
        supportsVertexTextures: m,
        outputColorSpace: Te === null ? s.outputColorSpace : Te.isXRRenderTarget === true ? Te.texture.colorSpace : $n,
        alphaToCoverage: !!w.alphaToCoverage,
        map: Nt,
        matcap: _e,
        envMap: ge,
        envMapMode: ge && he.mapping,
        envMapCubeUVHeight: ie,
        aoMap: k,
        lightMap: Ke,
        bumpMap: ye,
        normalMap: ze,
        displacementMap: m && Ee,
        emissiveMap: st,
        normalMapObjectSpace: ze && w.normalMapType === $0,
        normalMapTangentSpace: ze && w.normalMapType === Wm,
        metalnessMap: Ue,
        roughnessMap: O,
        anisotropy: I,
        anisotropyMap: Re,
        clearcoat: $,
        clearcoatMap: Ge,
        clearcoatNormalMap: vt,
        clearcoatRoughnessMap: we,
        dispersion: fe,
        iridescence: K,
        iridescenceMap: Ve,
        iridescenceThicknessMap: Ze,
        sheen: le,
        sheenColorMap: nt,
        sheenRoughnessMap: He,
        specularMap: wt,
        specularColorMap: ht,
        specularIntensityMap: Wt,
        transmission: je,
        transmissionMap: q,
        thicknessMap: Ie,
        gradientMap: ae,
        opaque: w.transparent === false && w.blending === yo && w.alphaToCoverage === false,
        alphaMap: me,
        alphaTest: Oe,
        alphaHash: Ne,
        combine: w.combine,
        mapUv: Nt && g(w.map.channel),
        aoMapUv: k && g(w.aoMap.channel),
        lightMapUv: Ke && g(w.lightMap.channel),
        bumpMapUv: ye && g(w.bumpMap.channel),
        normalMapUv: ze && g(w.normalMap.channel),
        displacementMapUv: Ee && g(w.displacementMap.channel),
        emissiveMapUv: st && g(w.emissiveMap.channel),
        metalnessMapUv: Ue && g(w.metalnessMap.channel),
        roughnessMapUv: O && g(w.roughnessMap.channel),
        anisotropyMapUv: Re && g(w.anisotropyMap.channel),
        clearcoatMapUv: Ge && g(w.clearcoatMap.channel),
        clearcoatNormalMapUv: vt && g(w.clearcoatNormalMap.channel),
        clearcoatRoughnessMapUv: we && g(w.clearcoatRoughnessMap.channel),
        iridescenceMapUv: Ve && g(w.iridescenceMap.channel),
        iridescenceThicknessMapUv: Ze && g(w.iridescenceThicknessMap.channel),
        sheenColorMapUv: nt && g(w.sheenColorMap.channel),
        sheenRoughnessMapUv: He && g(w.sheenRoughnessMap.channel),
        specularMapUv: wt && g(w.specularMap.channel),
        specularColorMapUv: ht && g(w.specularColorMap.channel),
        specularIntensityMapUv: Wt && g(w.specularIntensityMap.channel),
        transmissionMapUv: q && g(w.transmissionMap.channel),
        thicknessMapUv: Ie && g(w.thicknessMap.channel),
        alphaMapUv: me && g(w.alphaMap.channel),
        vertexTangents: !!ue.attributes.tangent && (ze || I),
        vertexColors: w.vertexColors,
        vertexAlphas: w.vertexColors === true && !!ue.attributes.color && ue.attributes.color.itemSize === 4,
        pointsUvs: G.isPoints === true && !!ue.attributes.uv && (Nt || me),
        fog: !!Q,
        useFog: w.fog === true,
        fogExp2: !!Q && Q.isFogExp2,
        flatShading: w.flatShading === true,
        sizeAttenuation: w.sizeAttenuation === true,
        logarithmicDepthBuffer: f,
        reverseDepthBuffer: Ye,
        skinning: G.isSkinnedMesh === true,
        morphTargets: ue.morphAttributes.position !== void 0,
        morphNormals: ue.morphAttributes.normal !== void 0,
        morphColors: ue.morphAttributes.color !== void 0,
        morphTargetsCount: Le,
        morphTextureStride: Je,
        numDirLights: D.directional.length,
        numPointLights: D.point.length,
        numSpotLights: D.spot.length,
        numSpotLightMaps: D.spotLightMap.length,
        numRectAreaLights: D.rectArea.length,
        numHemiLights: D.hemi.length,
        numDirLightShadows: D.directionalShadowMap.length,
        numPointLightShadows: D.pointShadowMap.length,
        numSpotLightShadows: D.spotShadowMap.length,
        numSpotLightShadowsWithMaps: D.numSpotLightShadowsWithMaps,
        numLightProbes: D.numLightProbes,
        numClippingPlanes: o.numPlanes,
        numClipIntersection: o.numIntersection,
        dithering: w.dithering,
        shadowMapEnabled: s.shadowMap.enabled && B.length > 0,
        shadowMapType: s.shadowMap.type,
        toneMapping: bt,
        decodeVideoTexture: Nt && w.map.isVideoTexture === true && It.getTransfer(w.map.colorSpace) === $t,
        decodeVideoTextureEmissive: st && w.emissiveMap.isVideoTexture === true && It.getTransfer(w.emissiveMap.colorSpace) === $t,
        premultipliedAlpha: w.premultipliedAlpha,
        doubleSided: w.side === Wi,
        flipSided: w.side === Qn,
        useDepthPacking: w.depthPacking >= 0,
        depthPacking: w.depthPacking || 0,
        index0AttributeName: w.index0AttributeName,
        extensionClipCullDistance: tt && w.extensions.clipCullDistance === true && n.has("WEBGL_clip_cull_distance"),
        extensionMultiDraw: (tt && w.extensions.multiDraw === true || Fe) && n.has("WEBGL_multi_draw"),
        rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
        customProgramCacheKey: w.customProgramCacheKey()
      };
      return fn.vertexUv1s = c.has(1), fn.vertexUv2s = c.has(2), fn.vertexUv3s = c.has(3), c.clear(), fn;
    }
    function v(w) {
      const D = [];
      if (w.shaderID ? D.push(w.shaderID) : (D.push(w.customVertexShaderID), D.push(w.customFragmentShaderID)), w.defines !== void 0) for (const B in w.defines) D.push(B), D.push(w.defines[B]);
      return w.isRawShaderMaterial === false && (E(D, w), T(D, w), D.push(s.outputColorSpace)), D.push(w.customProgramCacheKey), D.join();
    }
    function E(w, D) {
      w.push(D.precision), w.push(D.outputColorSpace), w.push(D.envMapMode), w.push(D.envMapCubeUVHeight), w.push(D.mapUv), w.push(D.alphaMapUv), w.push(D.lightMapUv), w.push(D.aoMapUv), w.push(D.bumpMapUv), w.push(D.normalMapUv), w.push(D.displacementMapUv), w.push(D.emissiveMapUv), w.push(D.metalnessMapUv), w.push(D.roughnessMapUv), w.push(D.anisotropyMapUv), w.push(D.clearcoatMapUv), w.push(D.clearcoatNormalMapUv), w.push(D.clearcoatRoughnessMapUv), w.push(D.iridescenceMapUv), w.push(D.iridescenceThicknessMapUv), w.push(D.sheenColorMapUv), w.push(D.sheenRoughnessMapUv), w.push(D.specularMapUv), w.push(D.specularColorMapUv), w.push(D.specularIntensityMapUv), w.push(D.transmissionMapUv), w.push(D.thicknessMapUv), w.push(D.combine), w.push(D.fogExp2), w.push(D.sizeAttenuation), w.push(D.morphTargetsCount), w.push(D.morphAttributeCount), w.push(D.numDirLights), w.push(D.numPointLights), w.push(D.numSpotLights), w.push(D.numSpotLightMaps), w.push(D.numHemiLights), w.push(D.numRectAreaLights), w.push(D.numDirLightShadows), w.push(D.numPointLightShadows), w.push(D.numSpotLightShadows), w.push(D.numSpotLightShadowsWithMaps), w.push(D.numLightProbes), w.push(D.shadowMapType), w.push(D.toneMapping), w.push(D.numClippingPlanes), w.push(D.numClipIntersection), w.push(D.depthPacking);
    }
    function T(w, D) {
      a.disableAll(), D.supportsVertexTextures && a.enable(0), D.instancing && a.enable(1), D.instancingColor && a.enable(2), D.instancingMorph && a.enable(3), D.matcap && a.enable(4), D.envMap && a.enable(5), D.normalMapObjectSpace && a.enable(6), D.normalMapTangentSpace && a.enable(7), D.clearcoat && a.enable(8), D.iridescence && a.enable(9), D.alphaTest && a.enable(10), D.vertexColors && a.enable(11), D.vertexAlphas && a.enable(12), D.vertexUv1s && a.enable(13), D.vertexUv2s && a.enable(14), D.vertexUv3s && a.enable(15), D.vertexTangents && a.enable(16), D.anisotropy && a.enable(17), D.alphaHash && a.enable(18), D.batching && a.enable(19), D.dispersion && a.enable(20), D.batchingColor && a.enable(21), w.push(a.mask), a.disableAll(), D.fog && a.enable(0), D.useFog && a.enable(1), D.flatShading && a.enable(2), D.logarithmicDepthBuffer && a.enable(3), D.reverseDepthBuffer && a.enable(4), D.skinning && a.enable(5), D.morphTargets && a.enable(6), D.morphNormals && a.enable(7), D.morphColors && a.enable(8), D.premultipliedAlpha && a.enable(9), D.shadowMapEnabled && a.enable(10), D.doubleSided && a.enable(11), D.flipSided && a.enable(12), D.useDepthPacking && a.enable(13), D.dithering && a.enable(14), D.transmission && a.enable(15), D.sheen && a.enable(16), D.opaque && a.enable(17), D.pointsUvs && a.enable(18), D.decodeVideoTexture && a.enable(19), D.decodeVideoTextureEmissive && a.enable(20), D.alphaToCoverage && a.enable(21), w.push(a.mask);
    }
    function M(w) {
      const D = y[w.type];
      let B;
      if (D) {
        const Z = Gi[D];
        B = Tc.clone(Z.uniforms);
      } else B = w.uniforms;
      return B;
    }
    function P(w, D) {
      let B;
      for (let Z = 0, G = h.length; Z < G; Z++) {
        const Q = h[Z];
        if (Q.cacheKey === D) {
          B = Q, ++B.usedTimes;
          break;
        }
      }
      return B === void 0 && (B = new MT(s, D, w, r), h.push(B)), B;
    }
    function R(w) {
      if (--w.usedTimes === 0) {
        const D = h.indexOf(w);
        h[D] = h[h.length - 1], h.pop(), w.destroy();
      }
    }
    function d(w) {
      l.remove(w);
    }
    function N() {
      l.dispose();
    }
    return {
      getParameters: x,
      getProgramCacheKey: v,
      getUniforms: M,
      acquireProgram: P,
      releaseProgram: R,
      releaseShaderCache: d,
      programs: h,
      dispose: N
    };
  }
  function CT() {
    let s = /* @__PURE__ */ new WeakMap();
    function e(o) {
      return s.has(o);
    }
    function t(o) {
      let a = s.get(o);
      return a === void 0 && (a = {}, s.set(o, a)), a;
    }
    function n(o) {
      s.delete(o);
    }
    function i(o, a, l) {
      s.get(o)[a] = l;
    }
    function r() {
      s = /* @__PURE__ */ new WeakMap();
    }
    return {
      has: e,
      get: t,
      remove: n,
      update: i,
      dispose: r
    };
  }
  function RT(s, e) {
    return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.material.id !== e.material.id ? s.material.id - e.material.id : s.z !== e.z ? s.z - e.z : s.id - e.id;
  }
  function qp(s, e) {
    return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.z !== e.z ? e.z - s.z : s.id - e.id;
  }
  function Yp() {
    const s = [];
    let e = 0;
    const t = [], n = [], i = [];
    function r() {
      e = 0, t.length = 0, n.length = 0, i.length = 0;
    }
    function o(f, m, _, y, g, x) {
      let v = s[e];
      return v === void 0 ? (v = {
        id: f.id,
        object: f,
        geometry: m,
        material: _,
        groupOrder: y,
        renderOrder: f.renderOrder,
        z: g,
        group: x
      }, s[e] = v) : (v.id = f.id, v.object = f, v.geometry = m, v.material = _, v.groupOrder = y, v.renderOrder = f.renderOrder, v.z = g, v.group = x), e++, v;
    }
    function a(f, m, _, y, g, x) {
      const v = o(f, m, _, y, g, x);
      _.transmission > 0 ? n.push(v) : _.transparent === true ? i.push(v) : t.push(v);
    }
    function l(f, m, _, y, g, x) {
      const v = o(f, m, _, y, g, x);
      _.transmission > 0 ? n.unshift(v) : _.transparent === true ? i.unshift(v) : t.unshift(v);
    }
    function c(f, m) {
      t.length > 1 && t.sort(f || RT), n.length > 1 && n.sort(m || qp), i.length > 1 && i.sort(m || qp);
    }
    function h() {
      for (let f = e, m = s.length; f < m; f++) {
        const _ = s[f];
        if (_.id === null) break;
        _.id = null, _.object = null, _.geometry = null, _.material = null, _.group = null;
      }
    }
    return {
      opaque: t,
      transmissive: n,
      transparent: i,
      init: r,
      push: a,
      unshift: l,
      finish: h,
      sort: c
    };
  }
  function PT() {
    let s = /* @__PURE__ */ new WeakMap();
    function e(n, i) {
      const r = s.get(n);
      let o;
      return r === void 0 ? (o = new Yp(), s.set(n, [
        o
      ])) : i >= r.length ? (o = new Yp(), r.push(o)) : o = r[i], o;
    }
    function t() {
      s = /* @__PURE__ */ new WeakMap();
    }
    return {
      get: e,
      dispose: t
    };
  }
  function DT() {
    const s = {};
    return {
      get: function(e) {
        if (s[e.id] !== void 0) return s[e.id];
        let t;
        switch (e.type) {
          case "DirectionalLight":
            t = {
              direction: new V(),
              color: new it()
            };
            break;
          case "SpotLight":
            t = {
              position: new V(),
              direction: new V(),
              color: new it(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0
            };
            break;
          case "PointLight":
            t = {
              position: new V(),
              color: new it(),
              distance: 0,
              decay: 0
            };
            break;
          case "HemisphereLight":
            t = {
              direction: new V(),
              skyColor: new it(),
              groundColor: new it()
            };
            break;
          case "RectAreaLight":
            t = {
              color: new it(),
              position: new V(),
              halfWidth: new V(),
              halfHeight: new V()
            };
            break;
        }
        return s[e.id] = t, t;
      }
    };
  }
  function LT() {
    const s = {};
    return {
      get: function(e) {
        if (s[e.id] !== void 0) return s[e.id];
        let t;
        switch (e.type) {
          case "DirectionalLight":
            t = {
              shadowIntensity: 1,
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Se()
            };
            break;
          case "SpotLight":
            t = {
              shadowIntensity: 1,
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Se()
            };
            break;
          case "PointLight":
            t = {
              shadowIntensity: 1,
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Se(),
              shadowCameraNear: 1,
              shadowCameraFar: 1e3
            };
            break;
        }
        return s[e.id] = t, t;
      }
    };
  }
  let IT = 0;
  function NT(s, e) {
    return (e.castShadow ? 2 : 0) - (s.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (s.map ? 1 : 0);
  }
  function UT(s) {
    const e = new DT(), t = LT(), n = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1
      },
      ambient: [
        0,
        0,
        0
      ],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0
    };
    for (let c = 0; c < 9; c++) n.probe.push(new V());
    const i = new V(), r = new pt(), o = new pt();
    function a(c) {
      let h = 0, f = 0, m = 0;
      for (let w = 0; w < 9; w++) n.probe[w].set(0, 0, 0);
      let _ = 0, y = 0, g = 0, x = 0, v = 0, E = 0, T = 0, M = 0, P = 0, R = 0, d = 0;
      c.sort(NT);
      for (let w = 0, D = c.length; w < D; w++) {
        const B = c[w], Z = B.color, G = B.intensity, Q = B.distance, ue = B.shadow && B.shadow.map ? B.shadow.map.texture : null;
        if (B.isAmbientLight) h += Z.r * G, f += Z.g * G, m += Z.b * G;
        else if (B.isLightProbe) {
          for (let te = 0; te < 9; te++) n.probe[te].addScaledVector(B.sh.coefficients[te], G);
          d++;
        } else if (B.isDirectionalLight) {
          const te = e.get(B);
          if (te.color.copy(B.color).multiplyScalar(B.intensity), B.castShadow) {
            const he = B.shadow, ie = t.get(B);
            ie.shadowIntensity = he.intensity, ie.shadowBias = he.bias, ie.shadowNormalBias = he.normalBias, ie.shadowRadius = he.radius, ie.shadowMapSize = he.mapSize, n.directionalShadow[_] = ie, n.directionalShadowMap[_] = ue, n.directionalShadowMatrix[_] = B.shadow.matrix, E++;
          }
          n.directional[_] = te, _++;
        } else if (B.isSpotLight) {
          const te = e.get(B);
          te.position.setFromMatrixPosition(B.matrixWorld), te.color.copy(Z).multiplyScalar(G), te.distance = Q, te.coneCos = Math.cos(B.angle), te.penumbraCos = Math.cos(B.angle * (1 - B.penumbra)), te.decay = B.decay, n.spot[g] = te;
          const he = B.shadow;
          if (B.map && (n.spotLightMap[P] = B.map, P++, he.updateMatrices(B), B.castShadow && R++), n.spotLightMatrix[g] = he.matrix, B.castShadow) {
            const ie = t.get(B);
            ie.shadowIntensity = he.intensity, ie.shadowBias = he.bias, ie.shadowNormalBias = he.normalBias, ie.shadowRadius = he.radius, ie.shadowMapSize = he.mapSize, n.spotShadow[g] = ie, n.spotShadowMap[g] = ue, M++;
          }
          g++;
        } else if (B.isRectAreaLight) {
          const te = e.get(B);
          te.color.copy(Z).multiplyScalar(G), te.halfWidth.set(B.width * 0.5, 0, 0), te.halfHeight.set(0, B.height * 0.5, 0), n.rectArea[x] = te, x++;
        } else if (B.isPointLight) {
          const te = e.get(B);
          if (te.color.copy(B.color).multiplyScalar(B.intensity), te.distance = B.distance, te.decay = B.decay, B.castShadow) {
            const he = B.shadow, ie = t.get(B);
            ie.shadowIntensity = he.intensity, ie.shadowBias = he.bias, ie.shadowNormalBias = he.normalBias, ie.shadowRadius = he.radius, ie.shadowMapSize = he.mapSize, ie.shadowCameraNear = he.camera.near, ie.shadowCameraFar = he.camera.far, n.pointShadow[y] = ie, n.pointShadowMap[y] = ue, n.pointShadowMatrix[y] = B.shadow.matrix, T++;
          }
          n.point[y] = te, y++;
        } else if (B.isHemisphereLight) {
          const te = e.get(B);
          te.skyColor.copy(B.color).multiplyScalar(G), te.groundColor.copy(B.groundColor).multiplyScalar(G), n.hemi[v] = te, v++;
        }
      }
      x > 0 && (s.has("OES_texture_float_linear") === true ? (n.rectAreaLTC1 = De.LTC_FLOAT_1, n.rectAreaLTC2 = De.LTC_FLOAT_2) : (n.rectAreaLTC1 = De.LTC_HALF_1, n.rectAreaLTC2 = De.LTC_HALF_2)), n.ambient[0] = h, n.ambient[1] = f, n.ambient[2] = m;
      const N = n.hash;
      (N.directionalLength !== _ || N.pointLength !== y || N.spotLength !== g || N.rectAreaLength !== x || N.hemiLength !== v || N.numDirectionalShadows !== E || N.numPointShadows !== T || N.numSpotShadows !== M || N.numSpotMaps !== P || N.numLightProbes !== d) && (n.directional.length = _, n.spot.length = g, n.rectArea.length = x, n.point.length = y, n.hemi.length = v, n.directionalShadow.length = E, n.directionalShadowMap.length = E, n.pointShadow.length = T, n.pointShadowMap.length = T, n.spotShadow.length = M, n.spotShadowMap.length = M, n.directionalShadowMatrix.length = E, n.pointShadowMatrix.length = T, n.spotLightMatrix.length = M + P - R, n.spotLightMap.length = P, n.numSpotLightShadowsWithMaps = R, n.numLightProbes = d, N.directionalLength = _, N.pointLength = y, N.spotLength = g, N.rectAreaLength = x, N.hemiLength = v, N.numDirectionalShadows = E, N.numPointShadows = T, N.numSpotShadows = M, N.numSpotMaps = P, N.numLightProbes = d, n.version = IT++);
    }
    function l(c, h) {
      let f = 0, m = 0, _ = 0, y = 0, g = 0;
      const x = h.matrixWorldInverse;
      for (let v = 0, E = c.length; v < E; v++) {
        const T = c[v];
        if (T.isDirectionalLight) {
          const M = n.directional[f];
          M.direction.setFromMatrixPosition(T.matrixWorld), i.setFromMatrixPosition(T.target.matrixWorld), M.direction.sub(i), M.direction.transformDirection(x), f++;
        } else if (T.isSpotLight) {
          const M = n.spot[_];
          M.position.setFromMatrixPosition(T.matrixWorld), M.position.applyMatrix4(x), M.direction.setFromMatrixPosition(T.matrixWorld), i.setFromMatrixPosition(T.target.matrixWorld), M.direction.sub(i), M.direction.transformDirection(x), _++;
        } else if (T.isRectAreaLight) {
          const M = n.rectArea[y];
          M.position.setFromMatrixPosition(T.matrixWorld), M.position.applyMatrix4(x), o.identity(), r.copy(T.matrixWorld), r.premultiply(x), o.extractRotation(r), M.halfWidth.set(T.width * 0.5, 0, 0), M.halfHeight.set(0, T.height * 0.5, 0), M.halfWidth.applyMatrix4(o), M.halfHeight.applyMatrix4(o), y++;
        } else if (T.isPointLight) {
          const M = n.point[m];
          M.position.setFromMatrixPosition(T.matrixWorld), M.position.applyMatrix4(x), m++;
        } else if (T.isHemisphereLight) {
          const M = n.hemi[g];
          M.direction.setFromMatrixPosition(T.matrixWorld), M.direction.transformDirection(x), g++;
        }
      }
    }
    return {
      setup: a,
      setupView: l,
      state: n
    };
  }
  function jp(s) {
    const e = new UT(s), t = [], n = [];
    function i(h) {
      c.camera = h, t.length = 0, n.length = 0;
    }
    function r(h) {
      t.push(h);
    }
    function o(h) {
      n.push(h);
    }
    function a() {
      e.setup(t);
    }
    function l(h) {
      e.setupView(t, h);
    }
    const c = {
      lightsArray: t,
      shadowsArray: n,
      camera: null,
      lights: e,
      transmissionRenderTarget: {}
    };
    return {
      init: i,
      state: c,
      setupLights: a,
      setupLightsView: l,
      pushLight: r,
      pushShadow: o
    };
  }
  function OT(s) {
    let e = /* @__PURE__ */ new WeakMap();
    function t(i, r = 0) {
      const o = e.get(i);
      let a;
      return o === void 0 ? (a = new jp(s), e.set(i, [
        a
      ])) : r >= o.length ? (a = new jp(s), o.push(a)) : a = o[r], a;
    }
    function n() {
      e = /* @__PURE__ */ new WeakMap();
    }
    return {
      get: t,
      dispose: n
    };
  }
  const FT = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, kT = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
  function BT(s, e, t) {
    let n = new Lf();
    const i = new Se(), r = new Se(), o = new zt(), a = new Fy({
      depthPacking: j0
    }), l = new ky(), c = {}, h = t.maxTextureSize, f = {
      [Er]: Qn,
      [Qn]: Er,
      [Wi]: Wi
    }, m = new kn({
      defines: {
        VSM_SAMPLES: 8
      },
      uniforms: {
        shadow_pass: {
          value: null
        },
        resolution: {
          value: new Se()
        },
        radius: {
          value: 4
        }
      },
      vertexShader: FT,
      fragmentShader: kT
    }), _ = m.clone();
    _.defines.HORIZONTAL_PASS = 1;
    const y = new si();
    y.setAttribute("position", new jn(new Float32Array([
      -1,
      -1,
      0.5,
      3,
      -1,
      0.5,
      -1,
      3,
      0.5
    ]), 3));
    const g = new hn(y, m), x = this;
    this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = Pm;
    let v = this.type;
    this.render = function(R, d, N) {
      if (x.enabled === false || x.autoUpdate === false && x.needsUpdate === false || R.length === 0) return;
      const w = s.getRenderTarget(), D = s.getActiveCubeFace(), B = s.getActiveMipmapLevel(), Z = s.state;
      Z.setBlending(Sr), Z.buffers.color.setClear(1, 1, 1, 1), Z.buffers.depth.setTest(true), Z.setScissorTest(false);
      const G = v !== mr && this.type === mr, Q = v === mr && this.type !== mr;
      for (let ue = 0, te = R.length; ue < te; ue++) {
        const he = R[ue], ie = he.shadow;
        if (ie === void 0) {
          console.warn("THREE.WebGLShadowMap:", he, "has no shadow.");
          continue;
        }
        if (ie.autoUpdate === false && ie.needsUpdate === false) continue;
        i.copy(ie.mapSize);
        const Me = ie.getFrameExtents();
        if (i.multiply(Me), r.copy(ie.mapSize), (i.x > h || i.y > h) && (i.x > h && (r.x = Math.floor(h / Me.x), i.x = r.x * Me.x, ie.mapSize.x = r.x), i.y > h && (r.y = Math.floor(h / Me.y), i.y = r.y * Me.y, ie.mapSize.y = r.y)), ie.map === null || G === true || Q === true) {
          const Le = this.type !== mr ? {
            minFilter: Yn,
            magFilter: Yn
          } : {};
          ie.map !== null && ie.map.dispose(), ie.map = new Ui(i.x, i.y, Le), ie.map.texture.name = he.name + ".shadowMap", ie.camera.updateProjectionMatrix();
        }
        s.setRenderTarget(ie.map), s.clear();
        const Ce = ie.getViewportCount();
        for (let Le = 0; Le < Ce; Le++) {
          const Je = ie.getViewport(Le);
          o.set(r.x * Je.x, r.y * Je.y, r.x * Je.z, r.y * Je.w), Z.viewport(o), ie.updateMatrices(he, Le), n = ie.getFrustum(), M(d, N, ie.camera, he, this.type);
        }
        ie.isPointLightShadow !== true && this.type === mr && E(ie, N), ie.needsUpdate = false;
      }
      v = this.type, x.needsUpdate = false, s.setRenderTarget(w, D, B);
    };
    function E(R, d) {
      const N = e.update(g);
      m.defines.VSM_SAMPLES !== R.blurSamples && (m.defines.VSM_SAMPLES = R.blurSamples, _.defines.VSM_SAMPLES = R.blurSamples, m.needsUpdate = true, _.needsUpdate = true), R.mapPass === null && (R.mapPass = new Ui(i.x, i.y)), m.uniforms.shadow_pass.value = R.map.texture, m.uniforms.resolution.value = R.mapSize, m.uniforms.radius.value = R.radius, s.setRenderTarget(R.mapPass), s.clear(), s.renderBufferDirect(d, null, N, m, g, null), _.uniforms.shadow_pass.value = R.mapPass.texture, _.uniforms.resolution.value = R.mapSize, _.uniforms.radius.value = R.radius, s.setRenderTarget(R.map), s.clear(), s.renderBufferDirect(d, null, N, _, g, null);
    }
    function T(R, d, N, w) {
      let D = null;
      const B = N.isPointLight === true ? R.customDistanceMaterial : R.customDepthMaterial;
      if (B !== void 0) D = B;
      else if (D = N.isPointLight === true ? l : a, s.localClippingEnabled && d.clipShadows === true && Array.isArray(d.clippingPlanes) && d.clippingPlanes.length !== 0 || d.displacementMap && d.displacementScale !== 0 || d.alphaMap && d.alphaTest > 0 || d.map && d.alphaTest > 0) {
        const Z = D.uuid, G = d.uuid;
        let Q = c[Z];
        Q === void 0 && (Q = {}, c[Z] = Q);
        let ue = Q[G];
        ue === void 0 && (ue = D.clone(), Q[G] = ue, d.addEventListener("dispose", P)), D = ue;
      }
      if (D.visible = d.visible, D.wireframe = d.wireframe, w === mr ? D.side = d.shadowSide !== null ? d.shadowSide : d.side : D.side = d.shadowSide !== null ? d.shadowSide : f[d.side], D.alphaMap = d.alphaMap, D.alphaTest = d.alphaTest, D.map = d.map, D.clipShadows = d.clipShadows, D.clippingPlanes = d.clippingPlanes, D.clipIntersection = d.clipIntersection, D.displacementMap = d.displacementMap, D.displacementScale = d.displacementScale, D.displacementBias = d.displacementBias, D.wireframeLinewidth = d.wireframeLinewidth, D.linewidth = d.linewidth, N.isPointLight === true && D.isMeshDistanceMaterial === true) {
        const Z = s.properties.get(D);
        Z.light = N;
      }
      return D;
    }
    function M(R, d, N, w, D) {
      if (R.visible === false) return;
      if (R.layers.test(d.layers) && (R.isMesh || R.isLine || R.isPoints) && (R.castShadow || R.receiveShadow && D === mr) && (!R.frustumCulled || n.intersectsObject(R))) {
        R.modelViewMatrix.multiplyMatrices(N.matrixWorldInverse, R.matrixWorld);
        const G = e.update(R), Q = R.material;
        if (Array.isArray(Q)) {
          const ue = G.groups;
          for (let te = 0, he = ue.length; te < he; te++) {
            const ie = ue[te], Me = Q[ie.materialIndex];
            if (Me && Me.visible) {
              const Ce = T(R, Me, w, D);
              R.onBeforeShadow(s, R, d, N, G, Ce, ie), s.renderBufferDirect(N, null, G, Ce, R, ie), R.onAfterShadow(s, R, d, N, G, Ce, ie);
            }
          }
        } else if (Q.visible) {
          const ue = T(R, Q, w, D);
          R.onBeforeShadow(s, R, d, N, G, ue, null), s.renderBufferDirect(N, null, G, ue, R, null), R.onAfterShadow(s, R, d, N, G, ue, null);
        }
      }
      const Z = R.children;
      for (let G = 0, Q = Z.length; G < Q; G++) M(Z[G], d, N, w, D);
    }
    function P(R) {
      R.target.removeEventListener("dispose", P);
      for (const N in c) {
        const w = c[N], D = R.target.uuid;
        D in w && (w[D].dispose(), delete w[D]);
      }
    }
  }
  const zT = {
    [lh]: ch,
    [uh]: dh,
    [hh]: ph,
    [Ao]: fh,
    [ch]: lh,
    [dh]: uh,
    [ph]: hh,
    [fh]: Ao
  };
  function HT(s, e) {
    function t() {
      let q = false;
      const Ie = new zt();
      let ae = null;
      const me = new zt(0, 0, 0, 0);
      return {
        setMask: function(Oe) {
          ae !== Oe && !q && (s.colorMask(Oe, Oe, Oe, Oe), ae = Oe);
        },
        setLocked: function(Oe) {
          q = Oe;
        },
        setClear: function(Oe, Ne, tt, bt, fn) {
          fn === true && (Oe *= bt, Ne *= bt, tt *= bt), Ie.set(Oe, Ne, tt, bt), me.equals(Ie) === false && (s.clearColor(Oe, Ne, tt, bt), me.copy(Ie));
        },
        reset: function() {
          q = false, ae = null, me.set(-1, 0, 0, 0);
        }
      };
    }
    function n() {
      let q = false, Ie = false, ae = null, me = null, Oe = null;
      return {
        setReversed: function(Ne) {
          if (Ie !== Ne) {
            const tt = e.get("EXT_clip_control");
            Ie ? tt.clipControlEXT(tt.LOWER_LEFT_EXT, tt.ZERO_TO_ONE_EXT) : tt.clipControlEXT(tt.LOWER_LEFT_EXT, tt.NEGATIVE_ONE_TO_ONE_EXT);
            const bt = Oe;
            Oe = null, this.setClear(bt);
          }
          Ie = Ne;
        },
        getReversed: function() {
          return Ie;
        },
        setTest: function(Ne) {
          Ne ? Te(s.DEPTH_TEST) : Ye(s.DEPTH_TEST);
        },
        setMask: function(Ne) {
          ae !== Ne && !q && (s.depthMask(Ne), ae = Ne);
        },
        setFunc: function(Ne) {
          if (Ie && (Ne = zT[Ne]), me !== Ne) {
            switch (Ne) {
              case lh:
                s.depthFunc(s.NEVER);
                break;
              case ch:
                s.depthFunc(s.ALWAYS);
                break;
              case uh:
                s.depthFunc(s.LESS);
                break;
              case Ao:
                s.depthFunc(s.LEQUAL);
                break;
              case hh:
                s.depthFunc(s.EQUAL);
                break;
              case fh:
                s.depthFunc(s.GEQUAL);
                break;
              case dh:
                s.depthFunc(s.GREATER);
                break;
              case ph:
                s.depthFunc(s.NOTEQUAL);
                break;
              default:
                s.depthFunc(s.LEQUAL);
            }
            me = Ne;
          }
        },
        setLocked: function(Ne) {
          q = Ne;
        },
        setClear: function(Ne) {
          Oe !== Ne && (Ie && (Ne = 1 - Ne), s.clearDepth(Ne), Oe = Ne);
        },
        reset: function() {
          q = false, ae = null, me = null, Oe = null, Ie = false;
        }
      };
    }
    function i() {
      let q = false, Ie = null, ae = null, me = null, Oe = null, Ne = null, tt = null, bt = null, fn = null;
      return {
        setTest: function(kt) {
          q || (kt ? Te(s.STENCIL_TEST) : Ye(s.STENCIL_TEST));
        },
        setMask: function(kt) {
          Ie !== kt && !q && (s.stencilMask(kt), Ie = kt);
        },
        setFunc: function(kt, Kn, _i) {
          (ae !== kt || me !== Kn || Oe !== _i) && (s.stencilFunc(kt, Kn, _i), ae = kt, me = Kn, Oe = _i);
        },
        setOp: function(kt, Kn, _i) {
          (Ne !== kt || tt !== Kn || bt !== _i) && (s.stencilOp(kt, Kn, _i), Ne = kt, tt = Kn, bt = _i);
        },
        setLocked: function(kt) {
          q = kt;
        },
        setClear: function(kt) {
          fn !== kt && (s.clearStencil(kt), fn = kt);
        },
        reset: function() {
          q = false, Ie = null, ae = null, me = null, Oe = null, Ne = null, tt = null, bt = null, fn = null;
        }
      };
    }
    const r = new t(), o = new n(), a = new i(), l = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap();
    let h = {}, f = {}, m = /* @__PURE__ */ new WeakMap(), _ = [], y = null, g = false, x = null, v = null, E = null, T = null, M = null, P = null, R = null, d = new it(0, 0, 0), N = 0, w = false, D = null, B = null, Z = null, G = null, Q = null;
    const ue = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let te = false, he = 0;
    const ie = s.getParameter(s.VERSION);
    ie.indexOf("WebGL") !== -1 ? (he = parseFloat(/^WebGL (\d)/.exec(ie)[1]), te = he >= 1) : ie.indexOf("OpenGL ES") !== -1 && (he = parseFloat(/^OpenGL ES (\d)/.exec(ie)[1]), te = he >= 2);
    let Me = null, Ce = {};
    const Le = s.getParameter(s.SCISSOR_BOX), Je = s.getParameter(s.VIEWPORT), dt = new zt().fromArray(Le), ce = new zt().fromArray(Je);
    function ve(q, Ie, ae, me) {
      const Oe = new Uint8Array(4), Ne = s.createTexture();
      s.bindTexture(q, Ne), s.texParameteri(q, s.TEXTURE_MIN_FILTER, s.NEAREST), s.texParameteri(q, s.TEXTURE_MAG_FILTER, s.NEAREST);
      for (let tt = 0; tt < ae; tt++) q === s.TEXTURE_3D || q === s.TEXTURE_2D_ARRAY ? s.texImage3D(Ie, 0, s.RGBA, 1, 1, me, 0, s.RGBA, s.UNSIGNED_BYTE, Oe) : s.texImage2D(Ie + tt, 0, s.RGBA, 1, 1, 0, s.RGBA, s.UNSIGNED_BYTE, Oe);
      return Ne;
    }
    const qe = {};
    qe[s.TEXTURE_2D] = ve(s.TEXTURE_2D, s.TEXTURE_2D, 1), qe[s.TEXTURE_CUBE_MAP] = ve(s.TEXTURE_CUBE_MAP, s.TEXTURE_CUBE_MAP_POSITIVE_X, 6), qe[s.TEXTURE_2D_ARRAY] = ve(s.TEXTURE_2D_ARRAY, s.TEXTURE_2D_ARRAY, 1, 1), qe[s.TEXTURE_3D] = ve(s.TEXTURE_3D, s.TEXTURE_3D, 1, 1), r.setClear(0, 0, 0, 1), o.setClear(1), a.setClear(0), Te(s.DEPTH_TEST), o.setFunc(Ao), ye(false), ze(wd), Te(s.CULL_FACE), k(Sr);
    function Te(q) {
      h[q] !== true && (s.enable(q), h[q] = true);
    }
    function Ye(q) {
      h[q] !== false && (s.disable(q), h[q] = false);
    }
    function lt(q, Ie) {
      return f[q] !== Ie ? (s.bindFramebuffer(q, Ie), f[q] = Ie, q === s.DRAW_FRAMEBUFFER && (f[s.FRAMEBUFFER] = Ie), q === s.FRAMEBUFFER && (f[s.DRAW_FRAMEBUFFER] = Ie), true) : false;
    }
    function Fe(q, Ie) {
      let ae = _, me = false;
      if (q) {
        ae = m.get(Ie), ae === void 0 && (ae = [], m.set(Ie, ae));
        const Oe = q.textures;
        if (ae.length !== Oe.length || ae[0] !== s.COLOR_ATTACHMENT0) {
          for (let Ne = 0, tt = Oe.length; Ne < tt; Ne++) ae[Ne] = s.COLOR_ATTACHMENT0 + Ne;
          ae.length = Oe.length, me = true;
        }
      } else ae[0] !== s.BACK && (ae[0] = s.BACK, me = true);
      me && s.drawBuffers(ae);
    }
    function Nt(q) {
      return y !== q ? (s.useProgram(q), y = q, true) : false;
    }
    const _e = {
      [Ms]: s.FUNC_ADD,
      [v0]: s.FUNC_SUBTRACT,
      [y0]: s.FUNC_REVERSE_SUBTRACT
    };
    _e[x0] = s.MIN, _e[b0] = s.MAX;
    const ge = {
      [S0]: s.ZERO,
      [M0]: s.ONE,
      [T0]: s.SRC_COLOR,
      [oh]: s.SRC_ALPHA,
      [P0]: s.SRC_ALPHA_SATURATE,
      [C0]: s.DST_COLOR,
      [w0]: s.DST_ALPHA,
      [E0]: s.ONE_MINUS_SRC_COLOR,
      [ah]: s.ONE_MINUS_SRC_ALPHA,
      [R0]: s.ONE_MINUS_DST_COLOR,
      [A0]: s.ONE_MINUS_DST_ALPHA,
      [D0]: s.CONSTANT_COLOR,
      [L0]: s.ONE_MINUS_CONSTANT_COLOR,
      [I0]: s.CONSTANT_ALPHA,
      [N0]: s.ONE_MINUS_CONSTANT_ALPHA
    };
    function k(q, Ie, ae, me, Oe, Ne, tt, bt, fn, kt) {
      if (q === Sr) {
        g === true && (Ye(s.BLEND), g = false);
        return;
      }
      if (g === false && (Te(s.BLEND), g = true), q !== _0) {
        if (q !== x || kt !== w) {
          if ((v !== Ms || M !== Ms) && (s.blendEquation(s.FUNC_ADD), v = Ms, M = Ms), kt) switch (q) {
            case yo:
              s.blendFuncSeparate(s.ONE, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
              break;
            case xc:
              s.blendFunc(s.ONE, s.ONE);
              break;
            case Ad:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case Cd:
              s.blendFuncSeparate(s.ZERO, s.SRC_COLOR, s.ZERO, s.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", q);
              break;
          }
          else switch (q) {
            case yo:
              s.blendFuncSeparate(s.SRC_ALPHA, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
              break;
            case xc:
              s.blendFunc(s.SRC_ALPHA, s.ONE);
              break;
            case Ad:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case Cd:
              s.blendFunc(s.ZERO, s.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", q);
              break;
          }
          E = null, T = null, P = null, R = null, d.set(0, 0, 0), N = 0, x = q, w = kt;
        }
        return;
      }
      Oe = Oe || Ie, Ne = Ne || ae, tt = tt || me, (Ie !== v || Oe !== M) && (s.blendEquationSeparate(_e[Ie], _e[Oe]), v = Ie, M = Oe), (ae !== E || me !== T || Ne !== P || tt !== R) && (s.blendFuncSeparate(ge[ae], ge[me], ge[Ne], ge[tt]), E = ae, T = me, P = Ne, R = tt), (bt.equals(d) === false || fn !== N) && (s.blendColor(bt.r, bt.g, bt.b, fn), d.copy(bt), N = fn), x = q, w = false;
    }
    function Ke(q, Ie) {
      q.side === Wi ? Ye(s.CULL_FACE) : Te(s.CULL_FACE);
      let ae = q.side === Qn;
      Ie && (ae = !ae), ye(ae), q.blending === yo && q.transparent === false ? k(Sr) : k(q.blending, q.blendEquation, q.blendSrc, q.blendDst, q.blendEquationAlpha, q.blendSrcAlpha, q.blendDstAlpha, q.blendColor, q.blendAlpha, q.premultipliedAlpha), o.setFunc(q.depthFunc), o.setTest(q.depthTest), o.setMask(q.depthWrite), r.setMask(q.colorWrite);
      const me = q.stencilWrite;
      a.setTest(me), me && (a.setMask(q.stencilWriteMask), a.setFunc(q.stencilFunc, q.stencilRef, q.stencilFuncMask), a.setOp(q.stencilFail, q.stencilZFail, q.stencilZPass)), st(q.polygonOffset, q.polygonOffsetFactor, q.polygonOffsetUnits), q.alphaToCoverage === true ? Te(s.SAMPLE_ALPHA_TO_COVERAGE) : Ye(s.SAMPLE_ALPHA_TO_COVERAGE);
    }
    function ye(q) {
      D !== q && (q ? s.frontFace(s.CW) : s.frontFace(s.CCW), D = q);
    }
    function ze(q) {
      q !== p0 ? (Te(s.CULL_FACE), q !== B && (q === wd ? s.cullFace(s.BACK) : q === m0 ? s.cullFace(s.FRONT) : s.cullFace(s.FRONT_AND_BACK))) : Ye(s.CULL_FACE), B = q;
    }
    function Ee(q) {
      q !== Z && (te && s.lineWidth(q), Z = q);
    }
    function st(q, Ie, ae) {
      q ? (Te(s.POLYGON_OFFSET_FILL), (G !== Ie || Q !== ae) && (s.polygonOffset(Ie, ae), G = Ie, Q = ae)) : Ye(s.POLYGON_OFFSET_FILL);
    }
    function Ue(q) {
      q ? Te(s.SCISSOR_TEST) : Ye(s.SCISSOR_TEST);
    }
    function O(q) {
      q === void 0 && (q = s.TEXTURE0 + ue - 1), Me !== q && (s.activeTexture(q), Me = q);
    }
    function I(q, Ie, ae) {
      ae === void 0 && (Me === null ? ae = s.TEXTURE0 + ue - 1 : ae = Me);
      let me = Ce[ae];
      me === void 0 && (me = {
        type: void 0,
        texture: void 0
      }, Ce[ae] = me), (me.type !== q || me.texture !== Ie) && (Me !== ae && (s.activeTexture(ae), Me = ae), s.bindTexture(q, Ie || qe[q]), me.type = q, me.texture = Ie);
    }
    function $() {
      const q = Ce[Me];
      q !== void 0 && q.type !== void 0 && (s.bindTexture(q.type, null), q.type = void 0, q.texture = void 0);
    }
    function fe() {
      try {
        s.compressedTexImage2D.apply(s, arguments);
      } catch (q) {
        console.error("THREE.WebGLState:", q);
      }
    }
    function K() {
      try {
        s.compressedTexImage3D.apply(s, arguments);
      } catch (q) {
        console.error("THREE.WebGLState:", q);
      }
    }
    function le() {
      try {
        s.texSubImage2D.apply(s, arguments);
      } catch (q) {
        console.error("THREE.WebGLState:", q);
      }
    }
    function je() {
      try {
        s.texSubImage3D.apply(s, arguments);
      } catch (q) {
        console.error("THREE.WebGLState:", q);
      }
    }
    function Re() {
      try {
        s.compressedTexSubImage2D.apply(s, arguments);
      } catch (q) {
        console.error("THREE.WebGLState:", q);
      }
    }
    function Ge() {
      try {
        s.compressedTexSubImage3D.apply(s, arguments);
      } catch (q) {
        console.error("THREE.WebGLState:", q);
      }
    }
    function vt() {
      try {
        s.texStorage2D.apply(s, arguments);
      } catch (q) {
        console.error("THREE.WebGLState:", q);
      }
    }
    function we() {
      try {
        s.texStorage3D.apply(s, arguments);
      } catch (q) {
        console.error("THREE.WebGLState:", q);
      }
    }
    function Ve() {
      try {
        s.texImage2D.apply(s, arguments);
      } catch (q) {
        console.error("THREE.WebGLState:", q);
      }
    }
    function Ze() {
      try {
        s.texImage3D.apply(s, arguments);
      } catch (q) {
        console.error("THREE.WebGLState:", q);
      }
    }
    function nt(q) {
      dt.equals(q) === false && (s.scissor(q.x, q.y, q.z, q.w), dt.copy(q));
    }
    function He(q) {
      ce.equals(q) === false && (s.viewport(q.x, q.y, q.z, q.w), ce.copy(q));
    }
    function wt(q, Ie) {
      let ae = c.get(Ie);
      ae === void 0 && (ae = /* @__PURE__ */ new WeakMap(), c.set(Ie, ae));
      let me = ae.get(q);
      me === void 0 && (me = s.getUniformBlockIndex(Ie, q.name), ae.set(q, me));
    }
    function ht(q, Ie) {
      const me = c.get(Ie).get(q);
      l.get(Ie) !== me && (s.uniformBlockBinding(Ie, me, q.__bindingPointIndex), l.set(Ie, me));
    }
    function Wt() {
      s.disable(s.BLEND), s.disable(s.CULL_FACE), s.disable(s.DEPTH_TEST), s.disable(s.POLYGON_OFFSET_FILL), s.disable(s.SCISSOR_TEST), s.disable(s.STENCIL_TEST), s.disable(s.SAMPLE_ALPHA_TO_COVERAGE), s.blendEquation(s.FUNC_ADD), s.blendFunc(s.ONE, s.ZERO), s.blendFuncSeparate(s.ONE, s.ZERO, s.ONE, s.ZERO), s.blendColor(0, 0, 0, 0), s.colorMask(true, true, true, true), s.clearColor(0, 0, 0, 0), s.depthMask(true), s.depthFunc(s.LESS), o.setReversed(false), s.clearDepth(1), s.stencilMask(4294967295), s.stencilFunc(s.ALWAYS, 0, 4294967295), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), s.clearStencil(0), s.cullFace(s.BACK), s.frontFace(s.CCW), s.polygonOffset(0, 0), s.activeTexture(s.TEXTURE0), s.bindFramebuffer(s.FRAMEBUFFER, null), s.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), s.bindFramebuffer(s.READ_FRAMEBUFFER, null), s.useProgram(null), s.lineWidth(1), s.scissor(0, 0, s.canvas.width, s.canvas.height), s.viewport(0, 0, s.canvas.width, s.canvas.height), h = {}, Me = null, Ce = {}, f = {}, m = /* @__PURE__ */ new WeakMap(), _ = [], y = null, g = false, x = null, v = null, E = null, T = null, M = null, P = null, R = null, d = new it(0, 0, 0), N = 0, w = false, D = null, B = null, Z = null, G = null, Q = null, dt.set(0, 0, s.canvas.width, s.canvas.height), ce.set(0, 0, s.canvas.width, s.canvas.height), r.reset(), o.reset(), a.reset();
    }
    return {
      buffers: {
        color: r,
        depth: o,
        stencil: a
      },
      enable: Te,
      disable: Ye,
      bindFramebuffer: lt,
      drawBuffers: Fe,
      useProgram: Nt,
      setBlending: k,
      setMaterial: Ke,
      setFlipSided: ye,
      setCullFace: ze,
      setLineWidth: Ee,
      setPolygonOffset: st,
      setScissorTest: Ue,
      activeTexture: O,
      bindTexture: I,
      unbindTexture: $,
      compressedTexImage2D: fe,
      compressedTexImage3D: K,
      texImage2D: Ve,
      texImage3D: Ze,
      updateUBOMapping: wt,
      uniformBlockBinding: ht,
      texStorage2D: vt,
      texStorage3D: we,
      texSubImage2D: le,
      texSubImage3D: je,
      compressedTexSubImage2D: Re,
      compressedTexSubImage3D: Ge,
      scissor: nt,
      viewport: He,
      reset: Wt
    };
  }
  function VT(s, e, t, n, i, r, o) {
    const a = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, l = typeof navigator > "u" ? false : /OculusBrowser/g.test(navigator.userAgent), c = new Se(), h = /* @__PURE__ */ new WeakMap();
    let f;
    const m = /* @__PURE__ */ new WeakMap();
    let _ = false;
    try {
      _ = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch {
    }
    function y(O, I) {
      return _ ? new OffscreenCanvas(O, I) : Za("canvas");
    }
    function g(O, I, $) {
      let fe = 1;
      const K = Ue(O);
      if ((K.width > $ || K.height > $) && (fe = $ / Math.max(K.width, K.height)), fe < 1) if (typeof HTMLImageElement < "u" && O instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && O instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && O instanceof ImageBitmap || typeof VideoFrame < "u" && O instanceof VideoFrame) {
        const le = Math.floor(fe * K.width), je = Math.floor(fe * K.height);
        f === void 0 && (f = y(le, je));
        const Re = I ? y(le, je) : f;
        return Re.width = le, Re.height = je, Re.getContext("2d").drawImage(O, 0, 0, le, je), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + K.width + "x" + K.height + ") to (" + le + "x" + je + ")."), Re;
      } else return "data" in O && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + K.width + "x" + K.height + ")."), O;
      return O;
    }
    function x(O) {
      return O.generateMipmaps;
    }
    function v(O) {
      s.generateMipmap(O);
    }
    function E(O) {
      return O.isWebGLCubeRenderTarget ? s.TEXTURE_CUBE_MAP : O.isWebGL3DRenderTarget ? s.TEXTURE_3D : O.isWebGLArrayRenderTarget || O.isCompressedArrayTexture ? s.TEXTURE_2D_ARRAY : s.TEXTURE_2D;
    }
    function T(O, I, $, fe, K = false) {
      if (O !== null) {
        if (s[O] !== void 0) return s[O];
        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + O + "'");
      }
      let le = I;
      if (I === s.RED && ($ === s.FLOAT && (le = s.R32F), $ === s.HALF_FLOAT && (le = s.R16F), $ === s.UNSIGNED_BYTE && (le = s.R8)), I === s.RED_INTEGER && ($ === s.UNSIGNED_BYTE && (le = s.R8UI), $ === s.UNSIGNED_SHORT && (le = s.R16UI), $ === s.UNSIGNED_INT && (le = s.R32UI), $ === s.BYTE && (le = s.R8I), $ === s.SHORT && (le = s.R16I), $ === s.INT && (le = s.R32I)), I === s.RG && ($ === s.FLOAT && (le = s.RG32F), $ === s.HALF_FLOAT && (le = s.RG16F), $ === s.UNSIGNED_BYTE && (le = s.RG8)), I === s.RG_INTEGER && ($ === s.UNSIGNED_BYTE && (le = s.RG8UI), $ === s.UNSIGNED_SHORT && (le = s.RG16UI), $ === s.UNSIGNED_INT && (le = s.RG32UI), $ === s.BYTE && (le = s.RG8I), $ === s.SHORT && (le = s.RG16I), $ === s.INT && (le = s.RG32I)), I === s.RGB_INTEGER && ($ === s.UNSIGNED_BYTE && (le = s.RGB8UI), $ === s.UNSIGNED_SHORT && (le = s.RGB16UI), $ === s.UNSIGNED_INT && (le = s.RGB32UI), $ === s.BYTE && (le = s.RGB8I), $ === s.SHORT && (le = s.RGB16I), $ === s.INT && (le = s.RGB32I)), I === s.RGBA_INTEGER && ($ === s.UNSIGNED_BYTE && (le = s.RGBA8UI), $ === s.UNSIGNED_SHORT && (le = s.RGBA16UI), $ === s.UNSIGNED_INT && (le = s.RGBA32UI), $ === s.BYTE && (le = s.RGBA8I), $ === s.SHORT && (le = s.RGBA16I), $ === s.INT && (le = s.RGBA32I)), I === s.RGB && $ === s.UNSIGNED_INT_5_9_9_9_REV && (le = s.RGB9_E5), I === s.RGBA) {
        const je = K ? Sc : It.getTransfer(fe);
        $ === s.FLOAT && (le = s.RGBA32F), $ === s.HALF_FLOAT && (le = s.RGBA16F), $ === s.UNSIGNED_BYTE && (le = je === $t ? s.SRGB8_ALPHA8 : s.RGBA8), $ === s.UNSIGNED_SHORT_4_4_4_4 && (le = s.RGBA4), $ === s.UNSIGNED_SHORT_5_5_5_1 && (le = s.RGB5_A1);
      }
      return (le === s.R16F || le === s.R32F || le === s.RG16F || le === s.RG32F || le === s.RGBA16F || le === s.RGBA32F) && e.get("EXT_color_buffer_float"), le;
    }
    function M(O, I) {
      let $;
      return O ? I === null || I === Us || I === Do ? $ = s.DEPTH24_STENCIL8 : I === Ni ? $ = s.DEPTH32F_STENCIL8 : I === ja && ($ = s.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : I === null || I === Us || I === Do ? $ = s.DEPTH_COMPONENT24 : I === Ni ? $ = s.DEPTH_COMPONENT32F : I === ja && ($ = s.DEPTH_COMPONENT16), $;
    }
    function P(O, I) {
      return x(O) === true || O.isFramebufferTexture && O.minFilter !== Yn && O.minFilter !== fi ? Math.log2(Math.max(I.width, I.height)) + 1 : O.mipmaps !== void 0 && O.mipmaps.length > 0 ? O.mipmaps.length : O.isCompressedTexture && Array.isArray(O.image) ? I.mipmaps.length : 1;
    }
    function R(O) {
      const I = O.target;
      I.removeEventListener("dispose", R), N(I), I.isVideoTexture && h.delete(I);
    }
    function d(O) {
      const I = O.target;
      I.removeEventListener("dispose", d), D(I);
    }
    function N(O) {
      const I = n.get(O);
      if (I.__webglInit === void 0) return;
      const $ = O.source, fe = m.get($);
      if (fe) {
        const K = fe[I.__cacheKey];
        K.usedTimes--, K.usedTimes === 0 && w(O), Object.keys(fe).length === 0 && m.delete($);
      }
      n.remove(O);
    }
    function w(O) {
      const I = n.get(O);
      s.deleteTexture(I.__webglTexture);
      const $ = O.source, fe = m.get($);
      delete fe[I.__cacheKey], o.memory.textures--;
    }
    function D(O) {
      const I = n.get(O);
      if (O.depthTexture && (O.depthTexture.dispose(), n.remove(O.depthTexture)), O.isWebGLCubeRenderTarget) for (let fe = 0; fe < 6; fe++) {
        if (Array.isArray(I.__webglFramebuffer[fe])) for (let K = 0; K < I.__webglFramebuffer[fe].length; K++) s.deleteFramebuffer(I.__webglFramebuffer[fe][K]);
        else s.deleteFramebuffer(I.__webglFramebuffer[fe]);
        I.__webglDepthbuffer && s.deleteRenderbuffer(I.__webglDepthbuffer[fe]);
      }
      else {
        if (Array.isArray(I.__webglFramebuffer)) for (let fe = 0; fe < I.__webglFramebuffer.length; fe++) s.deleteFramebuffer(I.__webglFramebuffer[fe]);
        else s.deleteFramebuffer(I.__webglFramebuffer);
        if (I.__webglDepthbuffer && s.deleteRenderbuffer(I.__webglDepthbuffer), I.__webglMultisampledFramebuffer && s.deleteFramebuffer(I.__webglMultisampledFramebuffer), I.__webglColorRenderbuffer) for (let fe = 0; fe < I.__webglColorRenderbuffer.length; fe++) I.__webglColorRenderbuffer[fe] && s.deleteRenderbuffer(I.__webglColorRenderbuffer[fe]);
        I.__webglDepthRenderbuffer && s.deleteRenderbuffer(I.__webglDepthRenderbuffer);
      }
      const $ = O.textures;
      for (let fe = 0, K = $.length; fe < K; fe++) {
        const le = n.get($[fe]);
        le.__webglTexture && (s.deleteTexture(le.__webglTexture), o.memory.textures--), n.remove($[fe]);
      }
      n.remove(O);
    }
    let B = 0;
    function Z() {
      B = 0;
    }
    function G() {
      const O = B;
      return O >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + O + " texture units while this GPU supports only " + i.maxTextures), B += 1, O;
    }
    function Q(O) {
      const I = [];
      return I.push(O.wrapS), I.push(O.wrapT), I.push(O.wrapR || 0), I.push(O.magFilter), I.push(O.minFilter), I.push(O.anisotropy), I.push(O.internalFormat), I.push(O.format), I.push(O.type), I.push(O.generateMipmaps), I.push(O.premultiplyAlpha), I.push(O.flipY), I.push(O.unpackAlignment), I.push(O.colorSpace), I.join();
    }
    function ue(O, I) {
      const $ = n.get(O);
      if (O.isVideoTexture && Ee(O), O.isRenderTargetTexture === false && O.version > 0 && $.__version !== O.version) {
        const fe = O.image;
        if (fe === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
        else if (fe.complete === false) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
        else {
          ce($, O, I);
          return;
        }
      }
      t.bindTexture(s.TEXTURE_2D, $.__webglTexture, s.TEXTURE0 + I);
    }
    function te(O, I) {
      const $ = n.get(O);
      if (O.version > 0 && $.__version !== O.version) {
        ce($, O, I);
        return;
      }
      t.bindTexture(s.TEXTURE_2D_ARRAY, $.__webglTexture, s.TEXTURE0 + I);
    }
    function he(O, I) {
      const $ = n.get(O);
      if (O.version > 0 && $.__version !== O.version) {
        ce($, O, I);
        return;
      }
      t.bindTexture(s.TEXTURE_3D, $.__webglTexture, s.TEXTURE0 + I);
    }
    function ie(O, I) {
      const $ = n.get(O);
      if (O.version > 0 && $.__version !== O.version) {
        ve($, O, I);
        return;
      }
      t.bindTexture(s.TEXTURE_CUBE_MAP, $.__webglTexture, s.TEXTURE0 + I);
    }
    const Me = {
      [Po]: s.REPEAT,
      [Yr]: s.CLAMP_TO_EDGE,
      [bc]: s.MIRRORED_REPEAT
    }, Ce = {
      [Yn]: s.NEAREST,
      [Im]: s.NEAREST_MIPMAP_NEAREST,
      [Ia]: s.NEAREST_MIPMAP_LINEAR,
      [fi]: s.LINEAR,
      [sc]: s.LINEAR_MIPMAP_NEAREST,
      [xr]: s.LINEAR_MIPMAP_LINEAR
    }, Le = {
      [K0]: s.NEVER,
      [nv]: s.ALWAYS,
      [Z0]: s.LESS,
      [Xm]: s.LEQUAL,
      [J0]: s.EQUAL,
      [tv]: s.GEQUAL,
      [Q0]: s.GREATER,
      [ev]: s.NOTEQUAL
    };
    function Je(O, I) {
      if (I.type === Ni && e.has("OES_texture_float_linear") === false && (I.magFilter === fi || I.magFilter === sc || I.magFilter === Ia || I.magFilter === xr || I.minFilter === fi || I.minFilter === sc || I.minFilter === Ia || I.minFilter === xr) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), s.texParameteri(O, s.TEXTURE_WRAP_S, Me[I.wrapS]), s.texParameteri(O, s.TEXTURE_WRAP_T, Me[I.wrapT]), (O === s.TEXTURE_3D || O === s.TEXTURE_2D_ARRAY) && s.texParameteri(O, s.TEXTURE_WRAP_R, Me[I.wrapR]), s.texParameteri(O, s.TEXTURE_MAG_FILTER, Ce[I.magFilter]), s.texParameteri(O, s.TEXTURE_MIN_FILTER, Ce[I.minFilter]), I.compareFunction && (s.texParameteri(O, s.TEXTURE_COMPARE_MODE, s.COMPARE_REF_TO_TEXTURE), s.texParameteri(O, s.TEXTURE_COMPARE_FUNC, Le[I.compareFunction])), e.has("EXT_texture_filter_anisotropic") === true) {
        if (I.magFilter === Yn || I.minFilter !== Ia && I.minFilter !== xr || I.type === Ni && e.has("OES_texture_float_linear") === false) return;
        if (I.anisotropy > 1 || n.get(I).__currentAnisotropy) {
          const $ = e.get("EXT_texture_filter_anisotropic");
          s.texParameterf(O, $.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(I.anisotropy, i.getMaxAnisotropy())), n.get(I).__currentAnisotropy = I.anisotropy;
        }
      }
    }
    function dt(O, I) {
      let $ = false;
      O.__webglInit === void 0 && (O.__webglInit = true, I.addEventListener("dispose", R));
      const fe = I.source;
      let K = m.get(fe);
      K === void 0 && (K = {}, m.set(fe, K));
      const le = Q(I);
      if (le !== O.__cacheKey) {
        K[le] === void 0 && (K[le] = {
          texture: s.createTexture(),
          usedTimes: 0
        }, o.memory.textures++, $ = true), K[le].usedTimes++;
        const je = K[O.__cacheKey];
        je !== void 0 && (K[O.__cacheKey].usedTimes--, je.usedTimes === 0 && w(I)), O.__cacheKey = le, O.__webglTexture = K[le].texture;
      }
      return $;
    }
    function ce(O, I, $) {
      let fe = s.TEXTURE_2D;
      (I.isDataArrayTexture || I.isCompressedArrayTexture) && (fe = s.TEXTURE_2D_ARRAY), I.isData3DTexture && (fe = s.TEXTURE_3D);
      const K = dt(O, I), le = I.source;
      t.bindTexture(fe, O.__webglTexture, s.TEXTURE0 + $);
      const je = n.get(le);
      if (le.version !== je.__version || K === true) {
        t.activeTexture(s.TEXTURE0 + $);
        const Re = It.getPrimaries(It.workingColorSpace), Ge = I.colorSpace === qr ? null : It.getPrimaries(I.colorSpace), vt = I.colorSpace === qr || Re === Ge ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
        s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, I.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, I.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, I.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, vt);
        let we = g(I.image, false, i.maxTextureSize);
        we = st(I, we);
        const Ve = r.convert(I.format, I.colorSpace), Ze = r.convert(I.type);
        let nt = T(I.internalFormat, Ve, Ze, I.colorSpace, I.isVideoTexture);
        Je(fe, I);
        let He;
        const wt = I.mipmaps, ht = I.isVideoTexture !== true, Wt = je.__version === void 0 || K === true, q = le.dataReady, Ie = P(I, we);
        if (I.isDepthTexture) nt = M(I.format === Lo, I.type), Wt && (ht ? t.texStorage2D(s.TEXTURE_2D, 1, nt, we.width, we.height) : t.texImage2D(s.TEXTURE_2D, 0, nt, we.width, we.height, 0, Ve, Ze, null));
        else if (I.isDataTexture) if (wt.length > 0) {
          ht && Wt && t.texStorage2D(s.TEXTURE_2D, Ie, nt, wt[0].width, wt[0].height);
          for (let ae = 0, me = wt.length; ae < me; ae++) He = wt[ae], ht ? q && t.texSubImage2D(s.TEXTURE_2D, ae, 0, 0, He.width, He.height, Ve, Ze, He.data) : t.texImage2D(s.TEXTURE_2D, ae, nt, He.width, He.height, 0, Ve, Ze, He.data);
          I.generateMipmaps = false;
        } else ht ? (Wt && t.texStorage2D(s.TEXTURE_2D, Ie, nt, we.width, we.height), q && t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, we.width, we.height, Ve, Ze, we.data)) : t.texImage2D(s.TEXTURE_2D, 0, nt, we.width, we.height, 0, Ve, Ze, we.data);
        else if (I.isCompressedTexture) if (I.isCompressedArrayTexture) {
          ht && Wt && t.texStorage3D(s.TEXTURE_2D_ARRAY, Ie, nt, wt[0].width, wt[0].height, we.depth);
          for (let ae = 0, me = wt.length; ae < me; ae++) if (He = wt[ae], I.format !== Ti) if (Ve !== null) if (ht) {
            if (q) if (I.layerUpdates.size > 0) {
              const Oe = Tp(He.width, He.height, I.format, I.type);
              for (const Ne of I.layerUpdates) {
                const tt = He.data.subarray(Ne * Oe / He.data.BYTES_PER_ELEMENT, (Ne + 1) * Oe / He.data.BYTES_PER_ELEMENT);
                t.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, ae, 0, 0, Ne, He.width, He.height, 1, Ve, tt);
              }
              I.clearLayerUpdates();
            } else t.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, ae, 0, 0, 0, He.width, He.height, we.depth, Ve, He.data);
          } else t.compressedTexImage3D(s.TEXTURE_2D_ARRAY, ae, nt, He.width, He.height, we.depth, 0, He.data, 0, 0);
          else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
          else ht ? q && t.texSubImage3D(s.TEXTURE_2D_ARRAY, ae, 0, 0, 0, He.width, He.height, we.depth, Ve, Ze, He.data) : t.texImage3D(s.TEXTURE_2D_ARRAY, ae, nt, He.width, He.height, we.depth, 0, Ve, Ze, He.data);
        } else {
          ht && Wt && t.texStorage2D(s.TEXTURE_2D, Ie, nt, wt[0].width, wt[0].height);
          for (let ae = 0, me = wt.length; ae < me; ae++) He = wt[ae], I.format !== Ti ? Ve !== null ? ht ? q && t.compressedTexSubImage2D(s.TEXTURE_2D, ae, 0, 0, He.width, He.height, Ve, He.data) : t.compressedTexImage2D(s.TEXTURE_2D, ae, nt, He.width, He.height, 0, He.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : ht ? q && t.texSubImage2D(s.TEXTURE_2D, ae, 0, 0, He.width, He.height, Ve, Ze, He.data) : t.texImage2D(s.TEXTURE_2D, ae, nt, He.width, He.height, 0, Ve, Ze, He.data);
        }
        else if (I.isDataArrayTexture) if (ht) {
          if (Wt && t.texStorage3D(s.TEXTURE_2D_ARRAY, Ie, nt, we.width, we.height, we.depth), q) if (I.layerUpdates.size > 0) {
            const ae = Tp(we.width, we.height, I.format, I.type);
            for (const me of I.layerUpdates) {
              const Oe = we.data.subarray(me * ae / we.data.BYTES_PER_ELEMENT, (me + 1) * ae / we.data.BYTES_PER_ELEMENT);
              t.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, me, we.width, we.height, 1, Ve, Ze, Oe);
            }
            I.clearLayerUpdates();
          } else t.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, 0, we.width, we.height, we.depth, Ve, Ze, we.data);
        } else t.texImage3D(s.TEXTURE_2D_ARRAY, 0, nt, we.width, we.height, we.depth, 0, Ve, Ze, we.data);
        else if (I.isData3DTexture) ht ? (Wt && t.texStorage3D(s.TEXTURE_3D, Ie, nt, we.width, we.height, we.depth), q && t.texSubImage3D(s.TEXTURE_3D, 0, 0, 0, 0, we.width, we.height, we.depth, Ve, Ze, we.data)) : t.texImage3D(s.TEXTURE_3D, 0, nt, we.width, we.height, we.depth, 0, Ve, Ze, we.data);
        else if (I.isFramebufferTexture) {
          if (Wt) if (ht) t.texStorage2D(s.TEXTURE_2D, Ie, nt, we.width, we.height);
          else {
            let ae = we.width, me = we.height;
            for (let Oe = 0; Oe < Ie; Oe++) t.texImage2D(s.TEXTURE_2D, Oe, nt, ae, me, 0, Ve, Ze, null), ae >>= 1, me >>= 1;
          }
        } else if (wt.length > 0) {
          if (ht && Wt) {
            const ae = Ue(wt[0]);
            t.texStorage2D(s.TEXTURE_2D, Ie, nt, ae.width, ae.height);
          }
          for (let ae = 0, me = wt.length; ae < me; ae++) He = wt[ae], ht ? q && t.texSubImage2D(s.TEXTURE_2D, ae, 0, 0, Ve, Ze, He) : t.texImage2D(s.TEXTURE_2D, ae, nt, Ve, Ze, He);
          I.generateMipmaps = false;
        } else if (ht) {
          if (Wt) {
            const ae = Ue(we);
            t.texStorage2D(s.TEXTURE_2D, Ie, nt, ae.width, ae.height);
          }
          q && t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, Ve, Ze, we);
        } else t.texImage2D(s.TEXTURE_2D, 0, nt, Ve, Ze, we);
        x(I) && v(fe), je.__version = le.version, I.onUpdate && I.onUpdate(I);
      }
      O.__version = I.version;
    }
    function ve(O, I, $) {
      if (I.image.length !== 6) return;
      const fe = dt(O, I), K = I.source;
      t.bindTexture(s.TEXTURE_CUBE_MAP, O.__webglTexture, s.TEXTURE0 + $);
      const le = n.get(K);
      if (K.version !== le.__version || fe === true) {
        t.activeTexture(s.TEXTURE0 + $);
        const je = It.getPrimaries(It.workingColorSpace), Re = I.colorSpace === qr ? null : It.getPrimaries(I.colorSpace), Ge = I.colorSpace === qr || je === Re ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
        s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, I.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, I.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, I.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ge);
        const vt = I.isCompressedTexture || I.image[0].isCompressedTexture, we = I.image[0] && I.image[0].isDataTexture, Ve = [];
        for (let me = 0; me < 6; me++) !vt && !we ? Ve[me] = g(I.image[me], true, i.maxCubemapSize) : Ve[me] = we ? I.image[me].image : I.image[me], Ve[me] = st(I, Ve[me]);
        const Ze = Ve[0], nt = r.convert(I.format, I.colorSpace), He = r.convert(I.type), wt = T(I.internalFormat, nt, He, I.colorSpace), ht = I.isVideoTexture !== true, Wt = le.__version === void 0 || fe === true, q = K.dataReady;
        let Ie = P(I, Ze);
        Je(s.TEXTURE_CUBE_MAP, I);
        let ae;
        if (vt) {
          ht && Wt && t.texStorage2D(s.TEXTURE_CUBE_MAP, Ie, wt, Ze.width, Ze.height);
          for (let me = 0; me < 6; me++) {
            ae = Ve[me].mipmaps;
            for (let Oe = 0; Oe < ae.length; Oe++) {
              const Ne = ae[Oe];
              I.format !== Ti ? nt !== null ? ht ? q && t.compressedTexSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + me, Oe, 0, 0, Ne.width, Ne.height, nt, Ne.data) : t.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + me, Oe, wt, Ne.width, Ne.height, 0, Ne.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : ht ? q && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + me, Oe, 0, 0, Ne.width, Ne.height, nt, He, Ne.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + me, Oe, wt, Ne.width, Ne.height, 0, nt, He, Ne.data);
            }
          }
        } else {
          if (ae = I.mipmaps, ht && Wt) {
            ae.length > 0 && Ie++;
            const me = Ue(Ve[0]);
            t.texStorage2D(s.TEXTURE_CUBE_MAP, Ie, wt, me.width, me.height);
          }
          for (let me = 0; me < 6; me++) if (we) {
            ht ? q && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + me, 0, 0, 0, Ve[me].width, Ve[me].height, nt, He, Ve[me].data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + me, 0, wt, Ve[me].width, Ve[me].height, 0, nt, He, Ve[me].data);
            for (let Oe = 0; Oe < ae.length; Oe++) {
              const tt = ae[Oe].image[me].image;
              ht ? q && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + me, Oe + 1, 0, 0, tt.width, tt.height, nt, He, tt.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + me, Oe + 1, wt, tt.width, tt.height, 0, nt, He, tt.data);
            }
          } else {
            ht ? q && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + me, 0, 0, 0, nt, He, Ve[me]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + me, 0, wt, nt, He, Ve[me]);
            for (let Oe = 0; Oe < ae.length; Oe++) {
              const Ne = ae[Oe];
              ht ? q && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + me, Oe + 1, 0, 0, nt, He, Ne.image[me]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + me, Oe + 1, wt, nt, He, Ne.image[me]);
            }
          }
        }
        x(I) && v(s.TEXTURE_CUBE_MAP), le.__version = K.version, I.onUpdate && I.onUpdate(I);
      }
      O.__version = I.version;
    }
    function qe(O, I, $, fe, K, le) {
      const je = r.convert($.format, $.colorSpace), Re = r.convert($.type), Ge = T($.internalFormat, je, Re, $.colorSpace), vt = n.get(I), we = n.get($);
      if (we.__renderTarget = I, !vt.__hasExternalTextures) {
        const Ve = Math.max(1, I.width >> le), Ze = Math.max(1, I.height >> le);
        K === s.TEXTURE_3D || K === s.TEXTURE_2D_ARRAY ? t.texImage3D(K, le, Ge, Ve, Ze, I.depth, 0, je, Re, null) : t.texImage2D(K, le, Ge, Ve, Ze, 0, je, Re, null);
      }
      t.bindFramebuffer(s.FRAMEBUFFER, O), ze(I) ? a.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, fe, K, we.__webglTexture, 0, ye(I)) : (K === s.TEXTURE_2D || K >= s.TEXTURE_CUBE_MAP_POSITIVE_X && K <= s.TEXTURE_CUBE_MAP_NEGATIVE_Z) && s.framebufferTexture2D(s.FRAMEBUFFER, fe, K, we.__webglTexture, le), t.bindFramebuffer(s.FRAMEBUFFER, null);
    }
    function Te(O, I, $) {
      if (s.bindRenderbuffer(s.RENDERBUFFER, O), I.depthBuffer) {
        const fe = I.depthTexture, K = fe && fe.isDepthTexture ? fe.type : null, le = M(I.stencilBuffer, K), je = I.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, Re = ye(I);
        ze(I) ? a.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, Re, le, I.width, I.height) : $ ? s.renderbufferStorageMultisample(s.RENDERBUFFER, Re, le, I.width, I.height) : s.renderbufferStorage(s.RENDERBUFFER, le, I.width, I.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, je, s.RENDERBUFFER, O);
      } else {
        const fe = I.textures;
        for (let K = 0; K < fe.length; K++) {
          const le = fe[K], je = r.convert(le.format, le.colorSpace), Re = r.convert(le.type), Ge = T(le.internalFormat, je, Re, le.colorSpace), vt = ye(I);
          $ && ze(I) === false ? s.renderbufferStorageMultisample(s.RENDERBUFFER, vt, Ge, I.width, I.height) : ze(I) ? a.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, vt, Ge, I.width, I.height) : s.renderbufferStorage(s.RENDERBUFFER, Ge, I.width, I.height);
        }
      }
      s.bindRenderbuffer(s.RENDERBUFFER, null);
    }
    function Ye(O, I) {
      if (I && I.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
      if (t.bindFramebuffer(s.FRAMEBUFFER, O), !(I.depthTexture && I.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
      const fe = n.get(I.depthTexture);
      fe.__renderTarget = I, (!fe.__webglTexture || I.depthTexture.image.width !== I.width || I.depthTexture.image.height !== I.height) && (I.depthTexture.image.width = I.width, I.depthTexture.image.height = I.height, I.depthTexture.needsUpdate = true), ue(I.depthTexture, 0);
      const K = fe.__webglTexture, le = ye(I);
      if (I.depthTexture.format === xo) ze(I) ? a.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, K, 0, le) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, K, 0);
      else if (I.depthTexture.format === Lo) ze(I) ? a.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, K, 0, le) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, K, 0);
      else throw new Error("Unknown depthTexture format");
    }
    function lt(O) {
      const I = n.get(O), $ = O.isWebGLCubeRenderTarget === true;
      if (I.__boundDepthTexture !== O.depthTexture) {
        const fe = O.depthTexture;
        if (I.__depthDisposeCallback && I.__depthDisposeCallback(), fe) {
          const K = () => {
            delete I.__boundDepthTexture, delete I.__depthDisposeCallback, fe.removeEventListener("dispose", K);
          };
          fe.addEventListener("dispose", K), I.__depthDisposeCallback = K;
        }
        I.__boundDepthTexture = fe;
      }
      if (O.depthTexture && !I.__autoAllocateDepthBuffer) {
        if ($) throw new Error("target.depthTexture not supported in Cube render targets");
        Ye(I.__webglFramebuffer, O);
      } else if ($) {
        I.__webglDepthbuffer = [];
        for (let fe = 0; fe < 6; fe++) if (t.bindFramebuffer(s.FRAMEBUFFER, I.__webglFramebuffer[fe]), I.__webglDepthbuffer[fe] === void 0) I.__webglDepthbuffer[fe] = s.createRenderbuffer(), Te(I.__webglDepthbuffer[fe], O, false);
        else {
          const K = O.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, le = I.__webglDepthbuffer[fe];
          s.bindRenderbuffer(s.RENDERBUFFER, le), s.framebufferRenderbuffer(s.FRAMEBUFFER, K, s.RENDERBUFFER, le);
        }
      } else if (t.bindFramebuffer(s.FRAMEBUFFER, I.__webglFramebuffer), I.__webglDepthbuffer === void 0) I.__webglDepthbuffer = s.createRenderbuffer(), Te(I.__webglDepthbuffer, O, false);
      else {
        const fe = O.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, K = I.__webglDepthbuffer;
        s.bindRenderbuffer(s.RENDERBUFFER, K), s.framebufferRenderbuffer(s.FRAMEBUFFER, fe, s.RENDERBUFFER, K);
      }
      t.bindFramebuffer(s.FRAMEBUFFER, null);
    }
    function Fe(O, I, $) {
      const fe = n.get(O);
      I !== void 0 && qe(fe.__webglFramebuffer, O, O.texture, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, 0), $ !== void 0 && lt(O);
    }
    function Nt(O) {
      const I = O.texture, $ = n.get(O), fe = n.get(I);
      O.addEventListener("dispose", d);
      const K = O.textures, le = O.isWebGLCubeRenderTarget === true, je = K.length > 1;
      if (je || (fe.__webglTexture === void 0 && (fe.__webglTexture = s.createTexture()), fe.__version = I.version, o.memory.textures++), le) {
        $.__webglFramebuffer = [];
        for (let Re = 0; Re < 6; Re++) if (I.mipmaps && I.mipmaps.length > 0) {
          $.__webglFramebuffer[Re] = [];
          for (let Ge = 0; Ge < I.mipmaps.length; Ge++) $.__webglFramebuffer[Re][Ge] = s.createFramebuffer();
        } else $.__webglFramebuffer[Re] = s.createFramebuffer();
      } else {
        if (I.mipmaps && I.mipmaps.length > 0) {
          $.__webglFramebuffer = [];
          for (let Re = 0; Re < I.mipmaps.length; Re++) $.__webglFramebuffer[Re] = s.createFramebuffer();
        } else $.__webglFramebuffer = s.createFramebuffer();
        if (je) for (let Re = 0, Ge = K.length; Re < Ge; Re++) {
          const vt = n.get(K[Re]);
          vt.__webglTexture === void 0 && (vt.__webglTexture = s.createTexture(), o.memory.textures++);
        }
        if (O.samples > 0 && ze(O) === false) {
          $.__webglMultisampledFramebuffer = s.createFramebuffer(), $.__webglColorRenderbuffer = [], t.bindFramebuffer(s.FRAMEBUFFER, $.__webglMultisampledFramebuffer);
          for (let Re = 0; Re < K.length; Re++) {
            const Ge = K[Re];
            $.__webglColorRenderbuffer[Re] = s.createRenderbuffer(), s.bindRenderbuffer(s.RENDERBUFFER, $.__webglColorRenderbuffer[Re]);
            const vt = r.convert(Ge.format, Ge.colorSpace), we = r.convert(Ge.type), Ve = T(Ge.internalFormat, vt, we, Ge.colorSpace, O.isXRRenderTarget === true), Ze = ye(O);
            s.renderbufferStorageMultisample(s.RENDERBUFFER, Ze, Ve, O.width, O.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Re, s.RENDERBUFFER, $.__webglColorRenderbuffer[Re]);
          }
          s.bindRenderbuffer(s.RENDERBUFFER, null), O.depthBuffer && ($.__webglDepthRenderbuffer = s.createRenderbuffer(), Te($.__webglDepthRenderbuffer, O, true)), t.bindFramebuffer(s.FRAMEBUFFER, null);
        }
      }
      if (le) {
        t.bindTexture(s.TEXTURE_CUBE_MAP, fe.__webglTexture), Je(s.TEXTURE_CUBE_MAP, I);
        for (let Re = 0; Re < 6; Re++) if (I.mipmaps && I.mipmaps.length > 0) for (let Ge = 0; Ge < I.mipmaps.length; Ge++) qe($.__webglFramebuffer[Re][Ge], O, I, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + Re, Ge);
        else qe($.__webglFramebuffer[Re], O, I, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + Re, 0);
        x(I) && v(s.TEXTURE_CUBE_MAP), t.unbindTexture();
      } else if (je) {
        for (let Re = 0, Ge = K.length; Re < Ge; Re++) {
          const vt = K[Re], we = n.get(vt);
          t.bindTexture(s.TEXTURE_2D, we.__webglTexture), Je(s.TEXTURE_2D, vt), qe($.__webglFramebuffer, O, vt, s.COLOR_ATTACHMENT0 + Re, s.TEXTURE_2D, 0), x(vt) && v(s.TEXTURE_2D);
        }
        t.unbindTexture();
      } else {
        let Re = s.TEXTURE_2D;
        if ((O.isWebGL3DRenderTarget || O.isWebGLArrayRenderTarget) && (Re = O.isWebGL3DRenderTarget ? s.TEXTURE_3D : s.TEXTURE_2D_ARRAY), t.bindTexture(Re, fe.__webglTexture), Je(Re, I), I.mipmaps && I.mipmaps.length > 0) for (let Ge = 0; Ge < I.mipmaps.length; Ge++) qe($.__webglFramebuffer[Ge], O, I, s.COLOR_ATTACHMENT0, Re, Ge);
        else qe($.__webglFramebuffer, O, I, s.COLOR_ATTACHMENT0, Re, 0);
        x(I) && v(Re), t.unbindTexture();
      }
      O.depthBuffer && lt(O);
    }
    function _e(O) {
      const I = O.textures;
      for (let $ = 0, fe = I.length; $ < fe; $++) {
        const K = I[$];
        if (x(K)) {
          const le = E(O), je = n.get(K).__webglTexture;
          t.bindTexture(le, je), v(le), t.unbindTexture();
        }
      }
    }
    const ge = [], k = [];
    function Ke(O) {
      if (O.samples > 0) {
        if (ze(O) === false) {
          const I = O.textures, $ = O.width, fe = O.height;
          let K = s.COLOR_BUFFER_BIT;
          const le = O.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, je = n.get(O), Re = I.length > 1;
          if (Re) for (let Ge = 0; Ge < I.length; Ge++) t.bindFramebuffer(s.FRAMEBUFFER, je.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ge, s.RENDERBUFFER, null), t.bindFramebuffer(s.FRAMEBUFFER, je.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ge, s.TEXTURE_2D, null, 0);
          t.bindFramebuffer(s.READ_FRAMEBUFFER, je.__webglMultisampledFramebuffer), t.bindFramebuffer(s.DRAW_FRAMEBUFFER, je.__webglFramebuffer);
          for (let Ge = 0; Ge < I.length; Ge++) {
            if (O.resolveDepthBuffer && (O.depthBuffer && (K |= s.DEPTH_BUFFER_BIT), O.stencilBuffer && O.resolveStencilBuffer && (K |= s.STENCIL_BUFFER_BIT)), Re) {
              s.framebufferRenderbuffer(s.READ_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, je.__webglColorRenderbuffer[Ge]);
              const vt = n.get(I[Ge]).__webglTexture;
              s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, vt, 0);
            }
            s.blitFramebuffer(0, 0, $, fe, 0, 0, $, fe, K, s.NEAREST), l === true && (ge.length = 0, k.length = 0, ge.push(s.COLOR_ATTACHMENT0 + Ge), O.depthBuffer && O.resolveDepthBuffer === false && (ge.push(le), k.push(le), s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, k)), s.invalidateFramebuffer(s.READ_FRAMEBUFFER, ge));
          }
          if (t.bindFramebuffer(s.READ_FRAMEBUFFER, null), t.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), Re) for (let Ge = 0; Ge < I.length; Ge++) {
            t.bindFramebuffer(s.FRAMEBUFFER, je.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ge, s.RENDERBUFFER, je.__webglColorRenderbuffer[Ge]);
            const vt = n.get(I[Ge]).__webglTexture;
            t.bindFramebuffer(s.FRAMEBUFFER, je.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ge, s.TEXTURE_2D, vt, 0);
          }
          t.bindFramebuffer(s.DRAW_FRAMEBUFFER, je.__webglMultisampledFramebuffer);
        } else if (O.depthBuffer && O.resolveDepthBuffer === false && l) {
          const I = O.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT;
          s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, [
            I
          ]);
        }
      }
    }
    function ye(O) {
      return Math.min(i.maxSamples, O.samples);
    }
    function ze(O) {
      const I = n.get(O);
      return O.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === true && I.__useRenderToTexture !== false;
    }
    function Ee(O) {
      const I = o.render.frame;
      h.get(O) !== I && (h.set(O, I), O.update());
    }
    function st(O, I) {
      const $ = O.colorSpace, fe = O.format, K = O.type;
      return O.isCompressedTexture === true || O.isVideoTexture === true || $ !== $n && $ !== qr && (It.getTransfer($) === $t ? (fe !== Ti || K !== wr) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", $)), I;
    }
    function Ue(O) {
      return typeof HTMLImageElement < "u" && O instanceof HTMLImageElement ? (c.width = O.naturalWidth || O.width, c.height = O.naturalHeight || O.height) : typeof VideoFrame < "u" && O instanceof VideoFrame ? (c.width = O.displayWidth, c.height = O.displayHeight) : (c.width = O.width, c.height = O.height), c;
    }
    this.allocateTextureUnit = G, this.resetTextureUnits = Z, this.setTexture2D = ue, this.setTexture2DArray = te, this.setTexture3D = he, this.setTextureCube = ie, this.rebindTextures = Fe, this.setupRenderTarget = Nt, this.updateRenderTargetMipmap = _e, this.updateMultisampleRenderTarget = Ke, this.setupDepthRenderbuffer = lt, this.setupFrameBufferTexture = qe, this.useMultisampledRTT = ze;
  }
  function GT(s, e) {
    function t(n, i = qr) {
      let r;
      const o = It.getTransfer(i);
      if (n === wr) return s.UNSIGNED_BYTE;
      if (n === Sf) return s.UNSIGNED_SHORT_4_4_4_4;
      if (n === Mf) return s.UNSIGNED_SHORT_5_5_5_1;
      if (n === Om) return s.UNSIGNED_INT_5_9_9_9_REV;
      if (n === Nm) return s.BYTE;
      if (n === Um) return s.SHORT;
      if (n === ja) return s.UNSIGNED_SHORT;
      if (n === bf) return s.INT;
      if (n === Us) return s.UNSIGNED_INT;
      if (n === Ni) return s.FLOAT;
      if (n === Mr) return s.HALF_FLOAT;
      if (n === Fm) return s.ALPHA;
      if (n === km) return s.RGB;
      if (n === Ti) return s.RGBA;
      if (n === Bm) return s.LUMINANCE;
      if (n === zm) return s.LUMINANCE_ALPHA;
      if (n === xo) return s.DEPTH_COMPONENT;
      if (n === Lo) return s.DEPTH_STENCIL;
      if (n === Tf) return s.RED;
      if (n === Ef) return s.RED_INTEGER;
      if (n === Hm) return s.RG;
      if (n === wf) return s.RG_INTEGER;
      if (n === Af) return s.RGBA_INTEGER;
      if (n === oc || n === ac || n === lc || n === cc) if (o === $t) if (r = e.get("WEBGL_compressed_texture_s3tc_srgb"), r !== null) {
        if (n === oc) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
        if (n === ac) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
        if (n === lc) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
        if (n === cc) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
      } else return null;
      else if (r = e.get("WEBGL_compressed_texture_s3tc"), r !== null) {
        if (n === oc) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (n === ac) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (n === lc) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (n === cc) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
      if (n === _h || n === vh || n === yh || n === xh) if (r = e.get("WEBGL_compressed_texture_pvrtc"), r !== null) {
        if (n === _h) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (n === vh) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (n === yh) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (n === xh) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
      if (n === bh || n === Sh || n === Mh) if (r = e.get("WEBGL_compressed_texture_etc"), r !== null) {
        if (n === bh || n === Sh) return o === $t ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
        if (n === Mh) return o === $t ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
      if (n === Th || n === Eh || n === wh || n === Ah || n === Ch || n === Rh || n === Ph || n === Dh || n === Lh || n === Ih || n === Nh || n === Uh || n === Oh || n === Fh) if (r = e.get("WEBGL_compressed_texture_astc"), r !== null) {
        if (n === Th) return o === $t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (n === Eh) return o === $t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (n === wh) return o === $t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (n === Ah) return o === $t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (n === Ch) return o === $t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (n === Rh) return o === $t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (n === Ph) return o === $t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (n === Dh) return o === $t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (n === Lh) return o === $t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (n === Ih) return o === $t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (n === Nh) return o === $t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (n === Uh) return o === $t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (n === Oh) return o === $t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (n === Fh) return o === $t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
      if (n === uc || n === kh || n === Bh) if (r = e.get("EXT_texture_compression_bptc"), r !== null) {
        if (n === uc) return o === $t ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (n === kh) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (n === Bh) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
      if (n === Vm || n === zh || n === Hh || n === Vh) if (r = e.get("EXT_texture_compression_rgtc"), r !== null) {
        if (n === uc) return r.COMPRESSED_RED_RGTC1_EXT;
        if (n === zh) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (n === Hh) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (n === Vh) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
      return n === Do ? s.UNSIGNED_INT_24_8 : s[n] !== void 0 ? s[n] : null;
    }
    return {
      convert: t
    };
  }
  const WT = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, XT = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
  class qT {
    constructor() {
      this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
    }
    init(e, t, n) {
      if (this.texture === null) {
        const i = new Mn(), r = e.properties.get(i);
        r.__webglTexture = t.texture, (t.depthNear !== n.depthNear || t.depthFar !== n.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = i;
      }
    }
    getMesh(e) {
      if (this.texture !== null && this.mesh === null) {
        const t = e.cameras[0].viewport, n = new kn({
          vertexShader: WT,
          fragmentShader: XT,
          uniforms: {
            depthColor: {
              value: this.texture
            },
            depthWidth: {
              value: t.z
            },
            depthHeight: {
              value: t.w
            }
          }
        });
        this.mesh = new hn(new hl(20, 20), n);
      }
      return this.mesh;
    }
    reset() {
      this.texture = null, this.mesh = null;
    }
    getDepthTexture() {
      return this.texture;
    }
  }
  class YT extends qo {
    constructor(e, t) {
      super();
      const n = this;
      let i = null, r = 1, o = null, a = "local-floor", l = 1, c = null, h = null, f = null, m = null, _ = null, y = null;
      const g = new qT(), x = t.getContextAttributes();
      let v = null, E = null;
      const T = [], M = [], P = new Se();
      let R = null;
      const d = new Xn();
      d.viewport = new zt();
      const N = new Xn();
      N.viewport = new zt();
      const w = [
        d,
        N
      ], D = new rx();
      let B = null, Z = null;
      this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(ce) {
        let ve = T[ce];
        return ve === void 0 && (ve = new Cu(), T[ce] = ve), ve.getTargetRaySpace();
      }, this.getControllerGrip = function(ce) {
        let ve = T[ce];
        return ve === void 0 && (ve = new Cu(), T[ce] = ve), ve.getGripSpace();
      }, this.getHand = function(ce) {
        let ve = T[ce];
        return ve === void 0 && (ve = new Cu(), T[ce] = ve), ve.getHandSpace();
      };
      function G(ce) {
        const ve = M.indexOf(ce.inputSource);
        if (ve === -1) return;
        const qe = T[ve];
        qe !== void 0 && (qe.update(ce.inputSource, ce.frame, c || o), qe.dispatchEvent({
          type: ce.type,
          data: ce.inputSource
        }));
      }
      function Q() {
        i.removeEventListener("select", G), i.removeEventListener("selectstart", G), i.removeEventListener("selectend", G), i.removeEventListener("squeeze", G), i.removeEventListener("squeezestart", G), i.removeEventListener("squeezeend", G), i.removeEventListener("end", Q), i.removeEventListener("inputsourceschange", ue);
        for (let ce = 0; ce < T.length; ce++) {
          const ve = M[ce];
          ve !== null && (M[ce] = null, T[ce].disconnect(ve));
        }
        B = null, Z = null, g.reset(), e.setRenderTarget(v), _ = null, m = null, f = null, i = null, E = null, dt.stop(), n.isPresenting = false, e.setPixelRatio(R), e.setSize(P.width, P.height, false), n.dispatchEvent({
          type: "sessionend"
        });
      }
      this.setFramebufferScaleFactor = function(ce) {
        r = ce, n.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }, this.setReferenceSpaceType = function(ce) {
        a = ce, n.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }, this.getReferenceSpace = function() {
        return c || o;
      }, this.setReferenceSpace = function(ce) {
        c = ce;
      }, this.getBaseLayer = function() {
        return m !== null ? m : _;
      }, this.getBinding = function() {
        return f;
      }, this.getFrame = function() {
        return y;
      }, this.getSession = function() {
        return i;
      }, this.setSession = async function(ce) {
        if (i = ce, i !== null) {
          if (v = e.getRenderTarget(), i.addEventListener("select", G), i.addEventListener("selectstart", G), i.addEventListener("selectend", G), i.addEventListener("squeeze", G), i.addEventListener("squeezestart", G), i.addEventListener("squeezeend", G), i.addEventListener("end", Q), i.addEventListener("inputsourceschange", ue), x.xrCompatible !== true && await t.makeXRCompatible(), R = e.getPixelRatio(), e.getSize(P), typeof XRWebGLBinding < "u" && "createProjectionLayer" in XRWebGLBinding.prototype) {
            let qe = null, Te = null, Ye = null;
            x.depth && (Ye = x.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, qe = x.stencil ? Lo : xo, Te = x.stencil ? Do : Us);
            const lt = {
              colorFormat: t.RGBA8,
              depthFormat: Ye,
              scaleFactor: r
            };
            f = new XRWebGLBinding(i, t), m = f.createProjectionLayer(lt), i.updateRenderState({
              layers: [
                m
              ]
            }), e.setPixelRatio(1), e.setSize(m.textureWidth, m.textureHeight, false), E = new Ui(m.textureWidth, m.textureHeight, {
              format: Ti,
              type: wr,
              depthTexture: new sg(m.textureWidth, m.textureHeight, Te, void 0, void 0, void 0, void 0, void 0, void 0, qe),
              stencilBuffer: x.stencil,
              colorSpace: e.outputColorSpace,
              samples: x.antialias ? 4 : 0,
              resolveDepthBuffer: m.ignoreDepthValues === false
            });
          } else {
            const qe = {
              antialias: x.antialias,
              alpha: true,
              depth: x.depth,
              stencil: x.stencil,
              framebufferScaleFactor: r
            };
            _ = new XRWebGLLayer(i, t, qe), i.updateRenderState({
              baseLayer: _
            }), e.setPixelRatio(1), e.setSize(_.framebufferWidth, _.framebufferHeight, false), E = new Ui(_.framebufferWidth, _.framebufferHeight, {
              format: Ti,
              type: wr,
              colorSpace: e.outputColorSpace,
              stencilBuffer: x.stencil
            });
          }
          E.isXRRenderTarget = true, this.setFoveation(l), c = null, o = await i.requestReferenceSpace(a), dt.setContext(i), dt.start(), n.isPresenting = true, n.dispatchEvent({
            type: "sessionstart"
          });
        }
      }, this.getEnvironmentBlendMode = function() {
        if (i !== null) return i.environmentBlendMode;
      }, this.getDepthTexture = function() {
        return g.getDepthTexture();
      };
      function ue(ce) {
        for (let ve = 0; ve < ce.removed.length; ve++) {
          const qe = ce.removed[ve], Te = M.indexOf(qe);
          Te >= 0 && (M[Te] = null, T[Te].disconnect(qe));
        }
        for (let ve = 0; ve < ce.added.length; ve++) {
          const qe = ce.added[ve];
          let Te = M.indexOf(qe);
          if (Te === -1) {
            for (let lt = 0; lt < T.length; lt++) if (lt >= M.length) {
              M.push(qe), Te = lt;
              break;
            } else if (M[lt] === null) {
              M[lt] = qe, Te = lt;
              break;
            }
            if (Te === -1) break;
          }
          const Ye = T[Te];
          Ye && Ye.connect(qe);
        }
      }
      const te = new V(), he = new V();
      function ie(ce, ve, qe) {
        te.setFromMatrixPosition(ve.matrixWorld), he.setFromMatrixPosition(qe.matrixWorld);
        const Te = te.distanceTo(he), Ye = ve.projectionMatrix.elements, lt = qe.projectionMatrix.elements, Fe = Ye[14] / (Ye[10] - 1), Nt = Ye[14] / (Ye[10] + 1), _e = (Ye[9] + 1) / Ye[5], ge = (Ye[9] - 1) / Ye[5], k = (Ye[8] - 1) / Ye[0], Ke = (lt[8] + 1) / lt[0], ye = Fe * k, ze = Fe * Ke, Ee = Te / (-k + Ke), st = Ee * -k;
        if (ve.matrixWorld.decompose(ce.position, ce.quaternion, ce.scale), ce.translateX(st), ce.translateZ(Ee), ce.matrixWorld.compose(ce.position, ce.quaternion, ce.scale), ce.matrixWorldInverse.copy(ce.matrixWorld).invert(), Ye[10] === -1) ce.projectionMatrix.copy(ve.projectionMatrix), ce.projectionMatrixInverse.copy(ve.projectionMatrixInverse);
        else {
          const Ue = Fe + Ee, O = Nt + Ee, I = ye - st, $ = ze + (Te - st), fe = _e * Nt / O * Ue, K = ge * Nt / O * Ue;
          ce.projectionMatrix.makePerspective(I, $, fe, K, Ue, O), ce.projectionMatrixInverse.copy(ce.projectionMatrix).invert();
        }
      }
      function Me(ce, ve) {
        ve === null ? ce.matrixWorld.copy(ce.matrix) : ce.matrixWorld.multiplyMatrices(ve.matrixWorld, ce.matrix), ce.matrixWorldInverse.copy(ce.matrixWorld).invert();
      }
      this.updateCamera = function(ce) {
        if (i === null) return;
        let ve = ce.near, qe = ce.far;
        g.texture !== null && (g.depthNear > 0 && (ve = g.depthNear), g.depthFar > 0 && (qe = g.depthFar)), D.near = N.near = d.near = ve, D.far = N.far = d.far = qe, (B !== D.near || Z !== D.far) && (i.updateRenderState({
          depthNear: D.near,
          depthFar: D.far
        }), B = D.near, Z = D.far), d.layers.mask = ce.layers.mask | 2, N.layers.mask = ce.layers.mask | 4, D.layers.mask = d.layers.mask | N.layers.mask;
        const Te = ce.parent, Ye = D.cameras;
        Me(D, Te);
        for (let lt = 0; lt < Ye.length; lt++) Me(Ye[lt], Te);
        Ye.length === 2 ? ie(D, d, N) : D.projectionMatrix.copy(d.projectionMatrix), Ce(ce, D, Te);
      };
      function Ce(ce, ve, qe) {
        qe === null ? ce.matrix.copy(ve.matrixWorld) : (ce.matrix.copy(qe.matrixWorld), ce.matrix.invert(), ce.matrix.multiply(ve.matrixWorld)), ce.matrix.decompose(ce.position, ce.quaternion, ce.scale), ce.updateMatrixWorld(true), ce.projectionMatrix.copy(ve.projectionMatrix), ce.projectionMatrixInverse.copy(ve.projectionMatrixInverse), ce.isPerspectiveCamera && (ce.fov = Io * 2 * Math.atan(1 / ce.projectionMatrix.elements[5]), ce.zoom = 1);
      }
      this.getCamera = function() {
        return D;
      }, this.getFoveation = function() {
        if (!(m === null && _ === null)) return l;
      }, this.setFoveation = function(ce) {
        l = ce, m !== null && (m.fixedFoveation = ce), _ !== null && _.fixedFoveation !== void 0 && (_.fixedFoveation = ce);
      }, this.hasDepthSensing = function() {
        return g.texture !== null;
      }, this.getDepthSensingMesh = function() {
        return g.getMesh(D);
      };
      let Le = null;
      function Je(ce, ve) {
        if (h = ve.getViewerPose(c || o), y = ve, h !== null) {
          const qe = h.views;
          _ !== null && (e.setRenderTargetFramebuffer(E, _.framebuffer), e.setRenderTarget(E));
          let Te = false;
          qe.length !== D.cameras.length && (D.cameras.length = 0, Te = true);
          for (let Fe = 0; Fe < qe.length; Fe++) {
            const Nt = qe[Fe];
            let _e = null;
            if (_ !== null) _e = _.getViewport(Nt);
            else {
              const k = f.getViewSubImage(m, Nt);
              _e = k.viewport, Fe === 0 && (e.setRenderTargetTextures(E, k.colorTexture, m.ignoreDepthValues ? void 0 : k.depthStencilTexture), e.setRenderTarget(E));
            }
            let ge = w[Fe];
            ge === void 0 && (ge = new Xn(), ge.layers.enable(Fe), ge.viewport = new zt(), w[Fe] = ge), ge.matrix.fromArray(Nt.transform.matrix), ge.matrix.decompose(ge.position, ge.quaternion, ge.scale), ge.projectionMatrix.fromArray(Nt.projectionMatrix), ge.projectionMatrixInverse.copy(ge.projectionMatrix).invert(), ge.viewport.set(_e.x, _e.y, _e.width, _e.height), Fe === 0 && (D.matrix.copy(ge.matrix), D.matrix.decompose(D.position, D.quaternion, D.scale)), Te === true && D.cameras.push(ge);
          }
          const Ye = i.enabledFeatures;
          if (Ye && Ye.includes("depth-sensing") && i.depthUsage == "gpu-optimized" && f) {
            const Fe = f.getDepthInformation(qe[0]);
            Fe && Fe.isValid && Fe.texture && g.init(e, Fe, i.renderState);
          }
        }
        for (let qe = 0; qe < T.length; qe++) {
          const Te = M[qe], Ye = T[qe];
          Te !== null && Ye !== void 0 && Ye.update(Te, ve, c || o);
        }
        Le && Le(ce, ve), ve.detectedPlanes && n.dispatchEvent({
          type: "planesdetected",
          data: ve
        }), y = null;
      }
      const dt = new _g();
      dt.setAnimationLoop(Je), this.setAnimationLoop = function(ce) {
        Le = ce;
      }, this.dispose = function() {
      };
    }
  }
  const gs = new Zi(), jT = new pt();
  function $T(s, e) {
    function t(x, v) {
      x.matrixAutoUpdate === true && x.updateMatrix(), v.value.copy(x.matrix);
    }
    function n(x, v) {
      v.color.getRGB(x.fogColor.value, Jm(s)), v.isFog ? (x.fogNear.value = v.near, x.fogFar.value = v.far) : v.isFogExp2 && (x.fogDensity.value = v.density);
    }
    function i(x, v, E, T, M) {
      v.isMeshBasicMaterial || v.isMeshLambertMaterial ? r(x, v) : v.isMeshToonMaterial ? (r(x, v), f(x, v)) : v.isMeshPhongMaterial ? (r(x, v), h(x, v)) : v.isMeshStandardMaterial ? (r(x, v), m(x, v), v.isMeshPhysicalMaterial && _(x, v, M)) : v.isMeshMatcapMaterial ? (r(x, v), y(x, v)) : v.isMeshDepthMaterial ? r(x, v) : v.isMeshDistanceMaterial ? (r(x, v), g(x, v)) : v.isMeshNormalMaterial ? r(x, v) : v.isLineBasicMaterial ? (o(x, v), v.isLineDashedMaterial && a(x, v)) : v.isPointsMaterial ? l(x, v, E, T) : v.isSpriteMaterial ? c(x, v) : v.isShadowMaterial ? (x.color.value.copy(v.color), x.opacity.value = v.opacity) : v.isShaderMaterial && (v.uniformsNeedUpdate = false);
    }
    function r(x, v) {
      x.opacity.value = v.opacity, v.color && x.diffuse.value.copy(v.color), v.emissive && x.emissive.value.copy(v.emissive).multiplyScalar(v.emissiveIntensity), v.map && (x.map.value = v.map, t(v.map, x.mapTransform)), v.alphaMap && (x.alphaMap.value = v.alphaMap, t(v.alphaMap, x.alphaMapTransform)), v.bumpMap && (x.bumpMap.value = v.bumpMap, t(v.bumpMap, x.bumpMapTransform), x.bumpScale.value = v.bumpScale, v.side === Qn && (x.bumpScale.value *= -1)), v.normalMap && (x.normalMap.value = v.normalMap, t(v.normalMap, x.normalMapTransform), x.normalScale.value.copy(v.normalScale), v.side === Qn && x.normalScale.value.negate()), v.displacementMap && (x.displacementMap.value = v.displacementMap, t(v.displacementMap, x.displacementMapTransform), x.displacementScale.value = v.displacementScale, x.displacementBias.value = v.displacementBias), v.emissiveMap && (x.emissiveMap.value = v.emissiveMap, t(v.emissiveMap, x.emissiveMapTransform)), v.specularMap && (x.specularMap.value = v.specularMap, t(v.specularMap, x.specularMapTransform)), v.alphaTest > 0 && (x.alphaTest.value = v.alphaTest);
      const E = e.get(v), T = E.envMap, M = E.envMapRotation;
      T && (x.envMap.value = T, gs.copy(M), gs.x *= -1, gs.y *= -1, gs.z *= -1, T.isCubeTexture && T.isRenderTargetTexture === false && (gs.y *= -1, gs.z *= -1), x.envMapRotation.value.setFromMatrix4(jT.makeRotationFromEuler(gs)), x.flipEnvMap.value = T.isCubeTexture && T.isRenderTargetTexture === false ? -1 : 1, x.reflectivity.value = v.reflectivity, x.ior.value = v.ior, x.refractionRatio.value = v.refractionRatio), v.lightMap && (x.lightMap.value = v.lightMap, x.lightMapIntensity.value = v.lightMapIntensity, t(v.lightMap, x.lightMapTransform)), v.aoMap && (x.aoMap.value = v.aoMap, x.aoMapIntensity.value = v.aoMapIntensity, t(v.aoMap, x.aoMapTransform));
    }
    function o(x, v) {
      x.diffuse.value.copy(v.color), x.opacity.value = v.opacity, v.map && (x.map.value = v.map, t(v.map, x.mapTransform));
    }
    function a(x, v) {
      x.dashSize.value = v.dashSize, x.totalSize.value = v.dashSize + v.gapSize, x.scale.value = v.scale;
    }
    function l(x, v, E, T) {
      x.diffuse.value.copy(v.color), x.opacity.value = v.opacity, x.size.value = v.size * E, x.scale.value = T * 0.5, v.map && (x.map.value = v.map, t(v.map, x.uvTransform)), v.alphaMap && (x.alphaMap.value = v.alphaMap, t(v.alphaMap, x.alphaMapTransform)), v.alphaTest > 0 && (x.alphaTest.value = v.alphaTest);
    }
    function c(x, v) {
      x.diffuse.value.copy(v.color), x.opacity.value = v.opacity, x.rotation.value = v.rotation, v.map && (x.map.value = v.map, t(v.map, x.mapTransform)), v.alphaMap && (x.alphaMap.value = v.alphaMap, t(v.alphaMap, x.alphaMapTransform)), v.alphaTest > 0 && (x.alphaTest.value = v.alphaTest);
    }
    function h(x, v) {
      x.specular.value.copy(v.specular), x.shininess.value = Math.max(v.shininess, 1e-4);
    }
    function f(x, v) {
      v.gradientMap && (x.gradientMap.value = v.gradientMap);
    }
    function m(x, v) {
      x.metalness.value = v.metalness, v.metalnessMap && (x.metalnessMap.value = v.metalnessMap, t(v.metalnessMap, x.metalnessMapTransform)), x.roughness.value = v.roughness, v.roughnessMap && (x.roughnessMap.value = v.roughnessMap, t(v.roughnessMap, x.roughnessMapTransform)), v.envMap && (x.envMapIntensity.value = v.envMapIntensity);
    }
    function _(x, v, E) {
      x.ior.value = v.ior, v.sheen > 0 && (x.sheenColor.value.copy(v.sheenColor).multiplyScalar(v.sheen), x.sheenRoughness.value = v.sheenRoughness, v.sheenColorMap && (x.sheenColorMap.value = v.sheenColorMap, t(v.sheenColorMap, x.sheenColorMapTransform)), v.sheenRoughnessMap && (x.sheenRoughnessMap.value = v.sheenRoughnessMap, t(v.sheenRoughnessMap, x.sheenRoughnessMapTransform))), v.clearcoat > 0 && (x.clearcoat.value = v.clearcoat, x.clearcoatRoughness.value = v.clearcoatRoughness, v.clearcoatMap && (x.clearcoatMap.value = v.clearcoatMap, t(v.clearcoatMap, x.clearcoatMapTransform)), v.clearcoatRoughnessMap && (x.clearcoatRoughnessMap.value = v.clearcoatRoughnessMap, t(v.clearcoatRoughnessMap, x.clearcoatRoughnessMapTransform)), v.clearcoatNormalMap && (x.clearcoatNormalMap.value = v.clearcoatNormalMap, t(v.clearcoatNormalMap, x.clearcoatNormalMapTransform), x.clearcoatNormalScale.value.copy(v.clearcoatNormalScale), v.side === Qn && x.clearcoatNormalScale.value.negate())), v.dispersion > 0 && (x.dispersion.value = v.dispersion), v.iridescence > 0 && (x.iridescence.value = v.iridescence, x.iridescenceIOR.value = v.iridescenceIOR, x.iridescenceThicknessMinimum.value = v.iridescenceThicknessRange[0], x.iridescenceThicknessMaximum.value = v.iridescenceThicknessRange[1], v.iridescenceMap && (x.iridescenceMap.value = v.iridescenceMap, t(v.iridescenceMap, x.iridescenceMapTransform)), v.iridescenceThicknessMap && (x.iridescenceThicknessMap.value = v.iridescenceThicknessMap, t(v.iridescenceThicknessMap, x.iridescenceThicknessMapTransform))), v.transmission > 0 && (x.transmission.value = v.transmission, x.transmissionSamplerMap.value = E.texture, x.transmissionSamplerSize.value.set(E.width, E.height), v.transmissionMap && (x.transmissionMap.value = v.transmissionMap, t(v.transmissionMap, x.transmissionMapTransform)), x.thickness.value = v.thickness, v.thicknessMap && (x.thicknessMap.value = v.thicknessMap, t(v.thicknessMap, x.thicknessMapTransform)), x.attenuationDistance.value = v.attenuationDistance, x.attenuationColor.value.copy(v.attenuationColor)), v.anisotropy > 0 && (x.anisotropyVector.value.set(v.anisotropy * Math.cos(v.anisotropyRotation), v.anisotropy * Math.sin(v.anisotropyRotation)), v.anisotropyMap && (x.anisotropyMap.value = v.anisotropyMap, t(v.anisotropyMap, x.anisotropyMapTransform))), x.specularIntensity.value = v.specularIntensity, x.specularColor.value.copy(v.specularColor), v.specularColorMap && (x.specularColorMap.value = v.specularColorMap, t(v.specularColorMap, x.specularColorMapTransform)), v.specularIntensityMap && (x.specularIntensityMap.value = v.specularIntensityMap, t(v.specularIntensityMap, x.specularIntensityMapTransform));
    }
    function y(x, v) {
      v.matcap && (x.matcap.value = v.matcap);
    }
    function g(x, v) {
      const E = e.get(v).light;
      x.referencePosition.value.setFromMatrixPosition(E.matrixWorld), x.nearDistance.value = E.shadow.camera.near, x.farDistance.value = E.shadow.camera.far;
    }
    return {
      refreshFogUniforms: n,
      refreshMaterialUniforms: i
    };
  }
  function KT(s, e, t, n) {
    let i = {}, r = {}, o = [];
    const a = s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS);
    function l(E, T) {
      const M = T.program;
      n.uniformBlockBinding(E, M);
    }
    function c(E, T) {
      let M = i[E.id];
      M === void 0 && (y(E), M = h(E), i[E.id] = M, E.addEventListener("dispose", x));
      const P = T.program;
      n.updateUBOMapping(E, P);
      const R = e.render.frame;
      r[E.id] !== R && (m(E), r[E.id] = R);
    }
    function h(E) {
      const T = f();
      E.__bindingPointIndex = T;
      const M = s.createBuffer(), P = E.__size, R = E.usage;
      return s.bindBuffer(s.UNIFORM_BUFFER, M), s.bufferData(s.UNIFORM_BUFFER, P, R), s.bindBuffer(s.UNIFORM_BUFFER, null), s.bindBufferBase(s.UNIFORM_BUFFER, T, M), M;
    }
    function f() {
      for (let E = 0; E < a; E++) if (o.indexOf(E) === -1) return o.push(E), E;
      return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
    }
    function m(E) {
      const T = i[E.id], M = E.uniforms, P = E.__cache;
      s.bindBuffer(s.UNIFORM_BUFFER, T);
      for (let R = 0, d = M.length; R < d; R++) {
        const N = Array.isArray(M[R]) ? M[R] : [
          M[R]
        ];
        for (let w = 0, D = N.length; w < D; w++) {
          const B = N[w];
          if (_(B, R, w, P) === true) {
            const Z = B.__offset, G = Array.isArray(B.value) ? B.value : [
              B.value
            ];
            let Q = 0;
            for (let ue = 0; ue < G.length; ue++) {
              const te = G[ue], he = g(te);
              typeof te == "number" || typeof te == "boolean" ? (B.__data[0] = te, s.bufferSubData(s.UNIFORM_BUFFER, Z + Q, B.__data)) : te.isMatrix3 ? (B.__data[0] = te.elements[0], B.__data[1] = te.elements[1], B.__data[2] = te.elements[2], B.__data[3] = 0, B.__data[4] = te.elements[3], B.__data[5] = te.elements[4], B.__data[6] = te.elements[5], B.__data[7] = 0, B.__data[8] = te.elements[6], B.__data[9] = te.elements[7], B.__data[10] = te.elements[8], B.__data[11] = 0) : (te.toArray(B.__data, Q), Q += he.storage / Float32Array.BYTES_PER_ELEMENT);
            }
            s.bufferSubData(s.UNIFORM_BUFFER, Z, B.__data);
          }
        }
      }
      s.bindBuffer(s.UNIFORM_BUFFER, null);
    }
    function _(E, T, M, P) {
      const R = E.value, d = T + "_" + M;
      if (P[d] === void 0) return typeof R == "number" || typeof R == "boolean" ? P[d] = R : P[d] = R.clone(), true;
      {
        const N = P[d];
        if (typeof R == "number" || typeof R == "boolean") {
          if (N !== R) return P[d] = R, true;
        } else if (N.equals(R) === false) return N.copy(R), true;
      }
      return false;
    }
    function y(E) {
      const T = E.uniforms;
      let M = 0;
      const P = 16;
      for (let d = 0, N = T.length; d < N; d++) {
        const w = Array.isArray(T[d]) ? T[d] : [
          T[d]
        ];
        for (let D = 0, B = w.length; D < B; D++) {
          const Z = w[D], G = Array.isArray(Z.value) ? Z.value : [
            Z.value
          ];
          for (let Q = 0, ue = G.length; Q < ue; Q++) {
            const te = G[Q], he = g(te), ie = M % P, Me = ie % he.boundary, Ce = ie + Me;
            M += Me, Ce !== 0 && P - Ce < he.storage && (M += P - Ce), Z.__data = new Float32Array(he.storage / Float32Array.BYTES_PER_ELEMENT), Z.__offset = M, M += he.storage;
          }
        }
      }
      const R = M % P;
      return R > 0 && (M += P - R), E.__size = M, E.__cache = {}, this;
    }
    function g(E) {
      const T = {
        boundary: 0,
        storage: 0
      };
      return typeof E == "number" || typeof E == "boolean" ? (T.boundary = 4, T.storage = 4) : E.isVector2 ? (T.boundary = 8, T.storage = 8) : E.isVector3 || E.isColor ? (T.boundary = 16, T.storage = 12) : E.isVector4 ? (T.boundary = 16, T.storage = 16) : E.isMatrix3 ? (T.boundary = 48, T.storage = 48) : E.isMatrix4 ? (T.boundary = 64, T.storage = 64) : E.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", E), T;
    }
    function x(E) {
      const T = E.target;
      T.removeEventListener("dispose", x);
      const M = o.indexOf(T.__bindingPointIndex);
      o.splice(M, 1), s.deleteBuffer(i[T.id]), delete i[T.id], delete r[T.id];
    }
    function v() {
      for (const E in i) s.deleteBuffer(i[E]);
      o = [], i = {}, r = {};
    }
    return {
      bind: l,
      update: c,
      dispose: v
    };
  }
  class ZT {
    constructor(e = {}) {
      const { canvas: t = xv(), context: n = null, depth: i = true, stencil: r = false, alpha: o = false, antialias: a = false, premultipliedAlpha: l = true, preserveDrawingBuffer: c = false, powerPreference: h = "default", failIfMajorPerformanceCaveat: f = false, reverseDepthBuffer: m = false } = e;
      this.isWebGLRenderer = true;
      let _;
      if (n !== null) {
        if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
        _ = n.getContextAttributes().alpha;
      } else _ = o;
      const y = new Uint32Array(4), g = new Int32Array(4);
      let x = null, v = null;
      const E = [], T = [];
      this.domElement = t, this.debug = {
        checkShaderErrors: true,
        onShaderError: null
      }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this._outputColorSpace = Dn, this.toneMapping = Qr, this.toneMappingExposure = 1;
      const M = this;
      let P = false, R = 0, d = 0, N = null, w = -1, D = null;
      const B = new zt(), Z = new zt();
      let G = null;
      const Q = new it(0);
      let ue = 0, te = t.width, he = t.height, ie = 1, Me = null, Ce = null;
      const Le = new zt(0, 0, te, he), Je = new zt(0, 0, te, he);
      let dt = false;
      const ce = new Lf();
      let ve = false, qe = false;
      this.transmissionResolutionScale = 1;
      const Te = new pt(), Ye = new pt(), lt = new V(), Fe = new zt(), Nt = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: true
      };
      let _e = false;
      function ge() {
        return N === null ? ie : 1;
      }
      let k = n;
      function Ke(U, Y) {
        return t.getContext(U, Y);
      }
      try {
        const U = {
          alpha: true,
          depth: i,
          stencil: r,
          antialias: a,
          premultipliedAlpha: l,
          preserveDrawingBuffer: c,
          powerPreference: h,
          failIfMajorPerformanceCaveat: f
        };
        if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${xf}`), t.addEventListener("webglcontextlost", me, false), t.addEventListener("webglcontextrestored", Oe, false), t.addEventListener("webglcontextcreationerror", Ne, false), k === null) {
          const Y = "webgl2";
          if (k = Ke(Y, U), k === null) throw Ke(Y) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
        }
      } catch (U) {
        throw console.error("THREE.WebGLRenderer: " + U.message), U;
      }
      let ye, ze, Ee, st, Ue, O, I, $, fe, K, le, je, Re, Ge, vt, we, Ve, Ze, nt, He, wt, ht, Wt, q;
      function Ie() {
        ye = new aM(k), ye.init(), ht = new GT(k, ye), ze = new tM(k, ye, e, ht), Ee = new HT(k, ye), ze.reverseDepthBuffer && m && Ee.buffers.depth.setReversed(true), st = new uM(k), Ue = new CT(), O = new VT(k, ye, Ee, Ue, ze, ht, st), I = new iM(M), $ = new oM(M), fe = new _x(k), Wt = new QS(k, fe), K = new lM(k, fe, st, Wt), le = new fM(k, K, fe, st), nt = new hM(k, ze, O), we = new nM(Ue), je = new AT(M, I, $, ye, ze, Wt, we), Re = new $T(M, Ue), Ge = new PT(), vt = new OT(ye), Ze = new JS(M, I, $, Ee, le, _, l), Ve = new BT(M, le, ze), q = new KT(k, st, ze, Ee), He = new eM(k, ye, st), wt = new cM(k, ye, st), st.programs = je.programs, M.capabilities = ze, M.extensions = ye, M.properties = Ue, M.renderLists = Ge, M.shadowMap = Ve, M.state = Ee, M.info = st;
      }
      Ie();
      const ae = new YT(M, k);
      this.xr = ae, this.getContext = function() {
        return k;
      }, this.getContextAttributes = function() {
        return k.getContextAttributes();
      }, this.forceContextLoss = function() {
        const U = ye.get("WEBGL_lose_context");
        U && U.loseContext();
      }, this.forceContextRestore = function() {
        const U = ye.get("WEBGL_lose_context");
        U && U.restoreContext();
      }, this.getPixelRatio = function() {
        return ie;
      }, this.setPixelRatio = function(U) {
        U !== void 0 && (ie = U, this.setSize(te, he, false));
      }, this.getSize = function(U) {
        return U.set(te, he);
      }, this.setSize = function(U, Y, ne = true) {
        if (ae.isPresenting) {
          console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
          return;
        }
        te = U, he = Y, t.width = Math.floor(U * ie), t.height = Math.floor(Y * ie), ne === true && (t.style.width = U + "px", t.style.height = Y + "px"), this.setViewport(0, 0, U, Y);
      }, this.getDrawingBufferSize = function(U) {
        return U.set(te * ie, he * ie).floor();
      }, this.setDrawingBufferSize = function(U, Y, ne) {
        te = U, he = Y, ie = ne, t.width = Math.floor(U * ne), t.height = Math.floor(Y * ne), this.setViewport(0, 0, U, Y);
      }, this.getCurrentViewport = function(U) {
        return U.copy(B);
      }, this.getViewport = function(U) {
        return U.copy(Le);
      }, this.setViewport = function(U, Y, ne, re) {
        U.isVector4 ? Le.set(U.x, U.y, U.z, U.w) : Le.set(U, Y, ne, re), Ee.viewport(B.copy(Le).multiplyScalar(ie).round());
      }, this.getScissor = function(U) {
        return U.copy(Je);
      }, this.setScissor = function(U, Y, ne, re) {
        U.isVector4 ? Je.set(U.x, U.y, U.z, U.w) : Je.set(U, Y, ne, re), Ee.scissor(Z.copy(Je).multiplyScalar(ie).round());
      }, this.getScissorTest = function() {
        return dt;
      }, this.setScissorTest = function(U) {
        Ee.setScissorTest(dt = U);
      }, this.setOpaqueSort = function(U) {
        Me = U;
      }, this.setTransparentSort = function(U) {
        Ce = U;
      }, this.getClearColor = function(U) {
        return U.copy(Ze.getClearColor());
      }, this.setClearColor = function() {
        Ze.setClearColor.apply(Ze, arguments);
      }, this.getClearAlpha = function() {
        return Ze.getClearAlpha();
      }, this.setClearAlpha = function() {
        Ze.setClearAlpha.apply(Ze, arguments);
      }, this.clear = function(U = true, Y = true, ne = true) {
        let re = 0;
        if (U) {
          let j = false;
          if (N !== null) {
            const be = N.texture.format;
            j = be === Af || be === wf || be === Ef;
          }
          if (j) {
            const be = N.texture.type, Pe = be === wr || be === Us || be === ja || be === Do || be === Sf || be === Mf, We = Ze.getClearColor(), Xe = Ze.getClearAlpha(), at = We.r, ct = We.g, et = We.b;
            Pe ? (y[0] = at, y[1] = ct, y[2] = et, y[3] = Xe, k.clearBufferuiv(k.COLOR, 0, y)) : (g[0] = at, g[1] = ct, g[2] = et, g[3] = Xe, k.clearBufferiv(k.COLOR, 0, g));
          } else re |= k.COLOR_BUFFER_BIT;
        }
        Y && (re |= k.DEPTH_BUFFER_BIT), ne && (re |= k.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), k.clear(re);
      }, this.clearColor = function() {
        this.clear(true, false, false);
      }, this.clearDepth = function() {
        this.clear(false, true, false);
      }, this.clearStencil = function() {
        this.clear(false, false, true);
      }, this.dispose = function() {
        t.removeEventListener("webglcontextlost", me, false), t.removeEventListener("webglcontextrestored", Oe, false), t.removeEventListener("webglcontextcreationerror", Ne, false), Ze.dispose(), Ge.dispose(), vt.dispose(), Ue.dispose(), I.dispose(), $.dispose(), le.dispose(), Wt.dispose(), q.dispose(), je.dispose(), ae.dispose(), ae.removeEventListener("sessionstart", ir), ae.removeEventListener("sessionend", rr), Ai.stop();
      };
      function me(U) {
        U.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), P = true;
      }
      function Oe() {
        console.log("THREE.WebGLRenderer: Context Restored."), P = false;
        const U = st.autoReset, Y = Ve.enabled, ne = Ve.autoUpdate, re = Ve.needsUpdate, j = Ve.type;
        Ie(), st.autoReset = U, Ve.enabled = Y, Ve.autoUpdate = ne, Ve.needsUpdate = re, Ve.type = j;
      }
      function Ne(U) {
        console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", U.statusMessage);
      }
      function tt(U) {
        const Y = U.target;
        Y.removeEventListener("dispose", tt), bt(Y);
      }
      function bt(U) {
        fn(U), Ue.remove(U);
      }
      function fn(U) {
        const Y = Ue.get(U).programs;
        Y !== void 0 && (Y.forEach(function(ne) {
          je.releaseProgram(ne);
        }), U.isShaderMaterial && je.releaseShaderCache(U));
      }
      this.renderBufferDirect = function(U, Y, ne, re, j, be) {
        Y === null && (Y = Nt);
        const Pe = j.isMesh && j.matrixWorld.determinant() < 0, We = Yc(U, Y, ne, re, j);
        Ee.setMaterial(re, Pe);
        let Xe = ne.index, at = 1;
        if (re.wireframe === true) {
          if (Xe = K.getWireframeAttribute(ne), Xe === void 0) return;
          at = 2;
        }
        const ct = ne.drawRange, et = ne.attributes.position;
        let At = ct.start * at, Dt = (ct.start + ct.count) * at;
        be !== null && (At = Math.max(At, be.start * at), Dt = Math.min(Dt, (be.start + be.count) * at)), Xe !== null ? (At = Math.max(At, 0), Dt = Math.min(Dt, Xe.count)) : et != null && (At = Math.max(At, 0), Dt = Math.min(Dt, et.count));
        const tn = Dt - At;
        if (tn < 0 || tn === 1 / 0) return;
        Wt.setup(j, re, We, ne, Xe);
        let St, yt = He;
        if (Xe !== null && (St = fe.get(Xe), yt = wt, yt.setIndex(St)), j.isMesh) re.wireframe === true ? (Ee.setLineWidth(re.wireframeLinewidth * ge()), yt.setMode(k.LINES)) : yt.setMode(k.TRIANGLES);
        else if (j.isLine) {
          let Qe = re.linewidth;
          Qe === void 0 && (Qe = 1), Ee.setLineWidth(Qe * ge()), j.isLineSegments ? yt.setMode(k.LINES) : j.isLineLoop ? yt.setMode(k.LINE_LOOP) : yt.setMode(k.LINE_STRIP);
        } else j.isPoints ? yt.setMode(k.POINTS) : j.isSprite && yt.setMode(k.TRIANGLES);
        if (j.isBatchedMesh) if (j._multiDrawInstances !== null) yt.renderMultiDrawInstances(j._multiDrawStarts, j._multiDrawCounts, j._multiDrawCount, j._multiDrawInstances);
        else if (ye.get("WEBGL_multi_draw")) yt.renderMultiDraw(j._multiDrawStarts, j._multiDrawCounts, j._multiDrawCount);
        else {
          const Qe = j._multiDrawStarts, xn = j._multiDrawCounts, Ft = j._multiDrawCount, Hn = Xe ? fe.get(Xe).bytesPerElement : 1, sr = Ue.get(re).currentProgram.getUniforms();
          for (let wn = 0; wn < Ft; wn++) sr.setValue(k, "_gl_DrawID", wn), yt.render(Qe[wn] / Hn, xn[wn]);
        }
        else if (j.isInstancedMesh) yt.renderInstances(At, tn, j.count);
        else if (ne.isInstancedBufferGeometry) {
          const Qe = ne._maxInstanceCount !== void 0 ? ne._maxInstanceCount : 1 / 0, xn = Math.min(ne.instanceCount, Qe);
          yt.renderInstances(At, tn, xn);
        } else yt.render(At, tn);
      };
      function kt(U, Y, ne) {
        U.transparent === true && U.side === Wi && U.forceSinglePass === false ? (U.side = Qn, U.needsUpdate = true, Ws(U, Y, ne), U.side = Er, U.needsUpdate = true, Ws(U, Y, ne), U.side = Wi) : Ws(U, Y, ne);
      }
      this.compile = function(U, Y, ne = null) {
        ne === null && (ne = U), v = vt.get(ne), v.init(Y), T.push(v), ne.traverseVisible(function(j) {
          j.isLight && j.layers.test(Y.layers) && (v.pushLight(j), j.castShadow && v.pushShadow(j));
        }), U !== ne && U.traverseVisible(function(j) {
          j.isLight && j.layers.test(Y.layers) && (v.pushLight(j), j.castShadow && v.pushShadow(j));
        }), v.setupLights();
        const re = /* @__PURE__ */ new Set();
        return U.traverse(function(j) {
          if (!(j.isMesh || j.isPoints || j.isLine || j.isSprite)) return;
          const be = j.material;
          if (be) if (Array.isArray(be)) for (let Pe = 0; Pe < be.length; Pe++) {
            const We = be[Pe];
            kt(We, ne, j), re.add(We);
          }
          else kt(be, ne, j), re.add(be);
        }), T.pop(), v = null, re;
      }, this.compileAsync = function(U, Y, ne = null) {
        const re = this.compile(U, Y, ne);
        return new Promise((j) => {
          function be() {
            if (re.forEach(function(Pe) {
              Ue.get(Pe).currentProgram.isReady() && re.delete(Pe);
            }), re.size === 0) {
              j(U);
              return;
            }
            setTimeout(be, 10);
          }
          ye.get("KHR_parallel_shader_compile") !== null ? be() : setTimeout(be, 10);
        });
      };
      let Kn = null;
      function _i(U) {
        Kn && Kn(U);
      }
      function ir() {
        Ai.stop();
      }
      function rr() {
        Ai.start();
      }
      const Ai = new _g();
      Ai.setAnimationLoop(_i), typeof self < "u" && Ai.setContext(self), this.setAnimationLoop = function(U) {
        Kn = U, ae.setAnimationLoop(U), U === null ? Ai.stop() : Ai.start();
      }, ae.addEventListener("sessionstart", ir), ae.addEventListener("sessionend", rr), this.render = function(U, Y) {
        if (Y !== void 0 && Y.isCamera !== true) {
          console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
          return;
        }
        if (P === true) return;
        if (U.matrixWorldAutoUpdate === true && U.updateMatrixWorld(), Y.parent === null && Y.matrixWorldAutoUpdate === true && Y.updateMatrixWorld(), ae.enabled === true && ae.isPresenting === true && (ae.cameraAutoUpdate === true && ae.updateCamera(Y), Y = ae.getCamera()), U.isScene === true && U.onBeforeRender(M, U, Y, N), v = vt.get(U, T.length), v.init(Y), T.push(v), Ye.multiplyMatrices(Y.projectionMatrix, Y.matrixWorldInverse), ce.setFromProjectionMatrix(Ye), qe = this.localClippingEnabled, ve = we.init(this.clippingPlanes, qe), x = Ge.get(U, E.length), x.init(), E.push(x), ae.enabled === true && ae.isPresenting === true) {
          const be = M.xr.getDepthSensingMesh();
          be !== null && Pr(be, Y, -1 / 0, M.sortObjects);
        }
        Pr(U, Y, 0, M.sortObjects), x.finish(), M.sortObjects === true && x.sort(Me, Ce), _e = ae.enabled === false || ae.isPresenting === false || ae.hasDepthSensing() === false, _e && Ze.addToRenderList(x, U), this.info.render.frame++, ve === true && we.beginShadows();
        const ne = v.state.shadowsArray;
        Ve.render(ne, U, Y), ve === true && we.endShadows(), this.info.autoReset === true && this.info.reset();
        const re = x.opaque, j = x.transmissive;
        if (v.setupLights(), Y.isArrayCamera) {
          const be = Y.cameras;
          if (j.length > 0) for (let Pe = 0, We = be.length; Pe < We; Pe++) {
            const Xe = be[Pe];
            yl(re, j, U, Xe);
          }
          _e && Ze.render(U);
          for (let Pe = 0, We = be.length; Pe < We; Pe++) {
            const Xe = be[Pe];
            vl(x, U, Xe, Xe.viewport);
          }
        } else j.length > 0 && yl(re, j, U, Y), _e && Ze.render(U), vl(x, U, Y);
        N !== null && d === 0 && (O.updateMultisampleRenderTarget(N), O.updateRenderTargetMipmap(N)), U.isScene === true && U.onAfterRender(M, U, Y), Wt.resetDefaultState(), w = -1, D = null, T.pop(), T.length > 0 ? (v = T[T.length - 1], ve === true && we.setGlobalState(M.clippingPlanes, v.state.camera)) : v = null, E.pop(), E.length > 0 ? x = E[E.length - 1] : x = null;
      };
      function Pr(U, Y, ne, re) {
        if (U.visible === false) return;
        if (U.layers.test(Y.layers)) {
          if (U.isGroup) ne = U.renderOrder;
          else if (U.isLOD) U.autoUpdate === true && U.update(Y);
          else if (U.isLight) v.pushLight(U), U.castShadow && v.pushShadow(U);
          else if (U.isSprite) {
            if (!U.frustumCulled || ce.intersectsSprite(U)) {
              re && Fe.setFromMatrixPosition(U.matrixWorld).applyMatrix4(Ye);
              const Pe = le.update(U), We = U.material;
              We.visible && x.push(U, Pe, We, ne, Fe.z, null);
            }
          } else if ((U.isMesh || U.isLine || U.isPoints) && (!U.frustumCulled || ce.intersectsObject(U))) {
            const Pe = le.update(U), We = U.material;
            if (re && (U.boundingSphere !== void 0 ? (U.boundingSphere === null && U.computeBoundingSphere(), Fe.copy(U.boundingSphere.center)) : (Pe.boundingSphere === null && Pe.computeBoundingSphere(), Fe.copy(Pe.boundingSphere.center)), Fe.applyMatrix4(U.matrixWorld).applyMatrix4(Ye)), Array.isArray(We)) {
              const Xe = Pe.groups;
              for (let at = 0, ct = Xe.length; at < ct; at++) {
                const et = Xe[at], At = We[et.materialIndex];
                At && At.visible && x.push(U, Pe, At, ne, Fe.z, et);
              }
            } else We.visible && x.push(U, Pe, We, ne, Fe.z, null);
          }
        }
        const be = U.children;
        for (let Pe = 0, We = be.length; Pe < We; Pe++) Pr(be[Pe], Y, ne, re);
      }
      function vl(U, Y, ne, re) {
        const j = U.opaque, be = U.transmissive, Pe = U.transparent;
        v.setupLightsView(ne), ve === true && we.setGlobalState(M.clippingPlanes, ne), re && Ee.viewport(B.copy(re)), j.length > 0 && Gs(j, Y, ne), be.length > 0 && Gs(be, Y, ne), Pe.length > 0 && Gs(Pe, Y, ne), Ee.buffers.depth.setTest(true), Ee.buffers.depth.setMask(true), Ee.buffers.color.setMask(true), Ee.setPolygonOffset(false);
      }
      function yl(U, Y, ne, re) {
        if ((ne.isScene === true ? ne.overrideMaterial : null) !== null) return;
        v.state.transmissionRenderTarget[re.id] === void 0 && (v.state.transmissionRenderTarget[re.id] = new Ui(1, 1, {
          generateMipmaps: true,
          type: ye.has("EXT_color_buffer_half_float") || ye.has("EXT_color_buffer_float") ? Mr : wr,
          minFilter: xr,
          samples: 4,
          stencilBuffer: r,
          resolveDepthBuffer: false,
          resolveStencilBuffer: false,
          colorSpace: It.workingColorSpace
        }));
        const be = v.state.transmissionRenderTarget[re.id], Pe = re.viewport || B;
        be.setSize(Pe.z * M.transmissionResolutionScale, Pe.w * M.transmissionResolutionScale);
        const We = M.getRenderTarget();
        M.setRenderTarget(be), M.getClearColor(Q), ue = M.getClearAlpha(), ue < 1 && M.setClearColor(16777215, 0.5), M.clear(), _e && Ze.render(ne);
        const Xe = M.toneMapping;
        M.toneMapping = Qr;
        const at = re.viewport;
        if (re.viewport !== void 0 && (re.viewport = void 0), v.setupLightsView(re), ve === true && we.setGlobalState(M.clippingPlanes, re), Gs(U, ne, re), O.updateMultisampleRenderTarget(be), O.updateRenderTargetMipmap(be), ye.has("WEBGL_multisampled_render_to_texture") === false) {
          let ct = false;
          for (let et = 0, At = Y.length; et < At; et++) {
            const Dt = Y[et], tn = Dt.object, St = Dt.geometry, yt = Dt.material, Qe = Dt.group;
            if (yt.side === Wi && tn.layers.test(re.layers)) {
              const xn = yt.side;
              yt.side = Qn, yt.needsUpdate = true, ca(tn, ne, re, St, yt, Qe), yt.side = xn, yt.needsUpdate = true, ct = true;
            }
          }
          ct === true && (O.updateMultisampleRenderTarget(be), O.updateRenderTargetMipmap(be));
        }
        M.setRenderTarget(We), M.setClearColor(Q, ue), at !== void 0 && (re.viewport = at), M.toneMapping = Xe;
      }
      function Gs(U, Y, ne) {
        const re = Y.isScene === true ? Y.overrideMaterial : null;
        for (let j = 0, be = U.length; j < be; j++) {
          const Pe = U[j], We = Pe.object, Xe = Pe.geometry, at = re === null ? Pe.material : re, ct = Pe.group;
          We.layers.test(ne.layers) && ca(We, Y, ne, Xe, at, ct);
        }
      }
      function ca(U, Y, ne, re, j, be) {
        U.onBeforeRender(M, Y, ne, re, j, be), U.modelViewMatrix.multiplyMatrices(ne.matrixWorldInverse, U.matrixWorld), U.normalMatrix.getNormalMatrix(U.modelViewMatrix), j.onBeforeRender(M, Y, ne, re, U, be), j.transparent === true && j.side === Wi && j.forceSinglePass === false ? (j.side = Qn, j.needsUpdate = true, M.renderBufferDirect(ne, Y, re, j, U, be), j.side = Er, j.needsUpdate = true, M.renderBufferDirect(ne, Y, re, j, U, be), j.side = Wi) : M.renderBufferDirect(ne, Y, re, j, U, be), U.onAfterRender(M, Y, ne, re, j, be);
      }
      function Ws(U, Y, ne) {
        Y.isScene !== true && (Y = Nt);
        const re = Ue.get(U), j = v.state.lights, be = v.state.shadowsArray, Pe = j.state.version, We = je.getParameters(U, j.state, be, Y, ne), Xe = je.getProgramCacheKey(We);
        let at = re.programs;
        re.environment = U.isMeshStandardMaterial ? Y.environment : null, re.fog = Y.fog, re.envMap = (U.isMeshStandardMaterial ? $ : I).get(U.envMap || re.environment), re.envMapRotation = re.environment !== null && U.envMap === null ? Y.environmentRotation : U.envMapRotation, at === void 0 && (U.addEventListener("dispose", tt), at = /* @__PURE__ */ new Map(), re.programs = at);
        let ct = at.get(Xe);
        if (ct !== void 0) {
          if (re.currentProgram === ct && re.lightsStateVersion === Pe) return ua(U, We), ct;
        } else We.uniforms = je.getUniforms(U), U.onBeforeCompile(We, M), ct = je.acquireProgram(We, Xe), at.set(Xe, ct), re.uniforms = We.uniforms;
        const et = re.uniforms;
        return (!U.isShaderMaterial && !U.isRawShaderMaterial || U.clipping === true) && (et.clippingPlanes = we.uniform), ua(U, We), re.needsLights = bl(U), re.lightsStateVersion = Pe, re.needsLights && (et.ambientLightColor.value = j.state.ambient, et.lightProbe.value = j.state.probe, et.directionalLights.value = j.state.directional, et.directionalLightShadows.value = j.state.directionalShadow, et.spotLights.value = j.state.spot, et.spotLightShadows.value = j.state.spotShadow, et.rectAreaLights.value = j.state.rectArea, et.ltc_1.value = j.state.rectAreaLTC1, et.ltc_2.value = j.state.rectAreaLTC2, et.pointLights.value = j.state.point, et.pointLightShadows.value = j.state.pointShadow, et.hemisphereLights.value = j.state.hemi, et.directionalShadowMap.value = j.state.directionalShadowMap, et.directionalShadowMatrix.value = j.state.directionalShadowMatrix, et.spotShadowMap.value = j.state.spotShadowMap, et.spotLightMatrix.value = j.state.spotLightMatrix, et.spotLightMap.value = j.state.spotLightMap, et.pointShadowMap.value = j.state.pointShadowMap, et.pointShadowMatrix.value = j.state.pointShadowMatrix), re.currentProgram = ct, re.uniformsList = null, ct;
      }
      function xl(U) {
        if (U.uniformsList === null) {
          const Y = U.currentProgram.getUniforms();
          U.uniformsList = fc.seqWithValue(Y.seq, U.uniforms);
        }
        return U.uniformsList;
      }
      function ua(U, Y) {
        const ne = Ue.get(U);
        ne.outputColorSpace = Y.outputColorSpace, ne.batching = Y.batching, ne.batchingColor = Y.batchingColor, ne.instancing = Y.instancing, ne.instancingColor = Y.instancingColor, ne.instancingMorph = Y.instancingMorph, ne.skinning = Y.skinning, ne.morphTargets = Y.morphTargets, ne.morphNormals = Y.morphNormals, ne.morphColors = Y.morphColors, ne.morphTargetsCount = Y.morphTargetsCount, ne.numClippingPlanes = Y.numClippingPlanes, ne.numIntersection = Y.numClipIntersection, ne.vertexAlphas = Y.vertexAlphas, ne.vertexTangents = Y.vertexTangents, ne.toneMapping = Y.toneMapping;
      }
      function Yc(U, Y, ne, re, j) {
        Y.isScene !== true && (Y = Nt), O.resetTextureUnits();
        const be = Y.fog, Pe = re.isMeshStandardMaterial ? Y.environment : null, We = N === null ? M.outputColorSpace : N.isXRRenderTarget === true ? N.texture.colorSpace : $n, Xe = (re.isMeshStandardMaterial ? $ : I).get(re.envMap || Pe), at = re.vertexColors === true && !!ne.attributes.color && ne.attributes.color.itemSize === 4, ct = !!ne.attributes.tangent && (!!re.normalMap || re.anisotropy > 0), et = !!ne.morphAttributes.position, At = !!ne.morphAttributes.normal, Dt = !!ne.morphAttributes.color;
        let tn = Qr;
        re.toneMapped && (N === null || N.isXRRenderTarget === true) && (tn = M.toneMapping);
        const St = ne.morphAttributes.position || ne.morphAttributes.normal || ne.morphAttributes.color, yt = St !== void 0 ? St.length : 0, Qe = Ue.get(re), xn = v.state.lights;
        if (ve === true && (qe === true || U !== D)) {
          const An = U === D && re.id === w;
          we.setState(re, U, An);
        }
        let Ft = false;
        re.version === Qe.__version ? (Qe.needsLights && Qe.lightsStateVersion !== xn.state.version || Qe.outputColorSpace !== We || j.isBatchedMesh && Qe.batching === false || !j.isBatchedMesh && Qe.batching === true || j.isBatchedMesh && Qe.batchingColor === true && j.colorTexture === null || j.isBatchedMesh && Qe.batchingColor === false && j.colorTexture !== null || j.isInstancedMesh && Qe.instancing === false || !j.isInstancedMesh && Qe.instancing === true || j.isSkinnedMesh && Qe.skinning === false || !j.isSkinnedMesh && Qe.skinning === true || j.isInstancedMesh && Qe.instancingColor === true && j.instanceColor === null || j.isInstancedMesh && Qe.instancingColor === false && j.instanceColor !== null || j.isInstancedMesh && Qe.instancingMorph === true && j.morphTexture === null || j.isInstancedMesh && Qe.instancingMorph === false && j.morphTexture !== null || Qe.envMap !== Xe || re.fog === true && Qe.fog !== be || Qe.numClippingPlanes !== void 0 && (Qe.numClippingPlanes !== we.numPlanes || Qe.numIntersection !== we.numIntersection) || Qe.vertexAlphas !== at || Qe.vertexTangents !== ct || Qe.morphTargets !== et || Qe.morphNormals !== At || Qe.morphColors !== Dt || Qe.toneMapping !== tn || Qe.morphTargetsCount !== yt) && (Ft = true) : (Ft = true, Qe.__version = re.version);
        let Hn = Qe.currentProgram;
        Ft === true && (Hn = Ws(re, Y, j));
        let sr = false, wn = false, Lr = false;
        const Zt = Hn.getUniforms(), Zn = Qe.uniforms;
        if (Ee.useProgram(Hn.program) && (sr = true, wn = true, Lr = true), re.id !== w && (w = re.id, wn = true), sr || D !== U) {
          Ee.buffers.depth.getReversed() ? (Te.copy(U.projectionMatrix), Sv(Te), Mv(Te), Zt.setValue(k, "projectionMatrix", Te)) : Zt.setValue(k, "projectionMatrix", U.projectionMatrix), Zt.setValue(k, "viewMatrix", U.matrixWorldInverse);
          const dn = Zt.map.cameraPosition;
          dn !== void 0 && dn.setValue(k, lt.setFromMatrixPosition(U.matrixWorld)), ze.logarithmicDepthBuffer && Zt.setValue(k, "logDepthBufFC", 2 / (Math.log(U.far + 1) / Math.LN2)), (re.isMeshPhongMaterial || re.isMeshToonMaterial || re.isMeshLambertMaterial || re.isMeshBasicMaterial || re.isMeshStandardMaterial || re.isShaderMaterial) && Zt.setValue(k, "isOrthographic", U.isOrthographicCamera === true), D !== U && (D = U, wn = true, Lr = true);
        }
        if (j.isSkinnedMesh) {
          Zt.setOptional(k, j, "bindMatrix"), Zt.setOptional(k, j, "bindMatrixInverse");
          const An = j.skeleton;
          An && (An.boneTexture === null && An.computeBoneTexture(), Zt.setValue(k, "boneTexture", An.boneTexture, O));
        }
        j.isBatchedMesh && (Zt.setOptional(k, j, "batchingTexture"), Zt.setValue(k, "batchingTexture", j._matricesTexture, O), Zt.setOptional(k, j, "batchingIdTexture"), Zt.setValue(k, "batchingIdTexture", j._indirectTexture, O), Zt.setOptional(k, j, "batchingColorTexture"), j._colorsTexture !== null && Zt.setValue(k, "batchingColorTexture", j._colorsTexture, O));
        const Qt = ne.morphAttributes;
        if ((Qt.position !== void 0 || Qt.normal !== void 0 || Qt.color !== void 0) && nt.update(j, ne, Hn), (wn || Qe.receiveShadow !== j.receiveShadow) && (Qe.receiveShadow = j.receiveShadow, Zt.setValue(k, "receiveShadow", j.receiveShadow)), re.isMeshGouraudMaterial && re.envMap !== null && (Zn.envMap.value = Xe, Zn.flipEnvMap.value = Xe.isCubeTexture && Xe.isRenderTargetTexture === false ? -1 : 1), re.isMeshStandardMaterial && re.envMap === null && Y.environment !== null && (Zn.envMapIntensity.value = Y.environmentIntensity), wn && (Zt.setValue(k, "toneMappingExposure", M.toneMappingExposure), Qe.needsLights && Dr(Zn, Lr), be && re.fog === true && Re.refreshFogUniforms(Zn, be), Re.refreshMaterialUniforms(Zn, re, ie, he, v.state.transmissionRenderTarget[U.id]), fc.upload(k, xl(Qe), Zn, O)), re.isShaderMaterial && re.uniformsNeedUpdate === true && (fc.upload(k, xl(Qe), Zn, O), re.uniformsNeedUpdate = false), re.isSpriteMaterial && Zt.setValue(k, "center", j.center), Zt.setValue(k, "modelViewMatrix", j.modelViewMatrix), Zt.setValue(k, "normalMatrix", j.normalMatrix), Zt.setValue(k, "modelMatrix", j.matrixWorld), re.isShaderMaterial || re.isRawShaderMaterial) {
          const An = re.uniformsGroups;
          for (let dn = 0, da = An.length; dn < da; dn++) {
            const or = An[dn];
            q.update(or, Hn), q.bind(or, Hn);
          }
        }
        return Hn;
      }
      function Dr(U, Y) {
        U.ambientLightColor.needsUpdate = Y, U.lightProbe.needsUpdate = Y, U.directionalLights.needsUpdate = Y, U.directionalLightShadows.needsUpdate = Y, U.pointLights.needsUpdate = Y, U.pointLightShadows.needsUpdate = Y, U.spotLights.needsUpdate = Y, U.spotLightShadows.needsUpdate = Y, U.rectAreaLights.needsUpdate = Y, U.hemisphereLights.needsUpdate = Y;
      }
      function bl(U) {
        return U.isMeshLambertMaterial || U.isMeshToonMaterial || U.isMeshPhongMaterial || U.isMeshStandardMaterial || U.isShadowMaterial || U.isShaderMaterial && U.lights === true;
      }
      this.getActiveCubeFace = function() {
        return R;
      }, this.getActiveMipmapLevel = function() {
        return d;
      }, this.getRenderTarget = function() {
        return N;
      }, this.setRenderTargetTextures = function(U, Y, ne) {
        Ue.get(U.texture).__webglTexture = Y, Ue.get(U.depthTexture).__webglTexture = ne;
        const re = Ue.get(U);
        re.__hasExternalTextures = true, re.__autoAllocateDepthBuffer = ne === void 0, re.__autoAllocateDepthBuffer || ye.has("WEBGL_multisampled_render_to_texture") === true && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), re.__useRenderToTexture = false);
      }, this.setRenderTargetFramebuffer = function(U, Y) {
        const ne = Ue.get(U);
        ne.__webglFramebuffer = Y, ne.__useDefaultFramebuffer = Y === void 0;
      };
      const ha = k.createFramebuffer();
      this.setRenderTarget = function(U, Y = 0, ne = 0) {
        N = U, R = Y, d = ne;
        let re = true, j = null, be = false, Pe = false;
        if (U) {
          const Xe = Ue.get(U);
          if (Xe.__useDefaultFramebuffer !== void 0) Ee.bindFramebuffer(k.FRAMEBUFFER, null), re = false;
          else if (Xe.__webglFramebuffer === void 0) O.setupRenderTarget(U);
          else if (Xe.__hasExternalTextures) O.rebindTextures(U, Ue.get(U.texture).__webglTexture, Ue.get(U.depthTexture).__webglTexture);
          else if (U.depthBuffer) {
            const et = U.depthTexture;
            if (Xe.__boundDepthTexture !== et) {
              if (et !== null && Ue.has(et) && (U.width !== et.image.width || U.height !== et.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
              O.setupDepthRenderbuffer(U);
            }
          }
          const at = U.texture;
          (at.isData3DTexture || at.isDataArrayTexture || at.isCompressedArrayTexture) && (Pe = true);
          const ct = Ue.get(U).__webglFramebuffer;
          U.isWebGLCubeRenderTarget ? (Array.isArray(ct[Y]) ? j = ct[Y][ne] : j = ct[Y], be = true) : U.samples > 0 && O.useMultisampledRTT(U) === false ? j = Ue.get(U).__webglMultisampledFramebuffer : Array.isArray(ct) ? j = ct[ne] : j = ct, B.copy(U.viewport), Z.copy(U.scissor), G = U.scissorTest;
        } else B.copy(Le).multiplyScalar(ie).floor(), Z.copy(Je).multiplyScalar(ie).floor(), G = dt;
        if (ne !== 0 && (j = ha), Ee.bindFramebuffer(k.FRAMEBUFFER, j) && re && Ee.drawBuffers(U, j), Ee.viewport(B), Ee.scissor(Z), Ee.setScissorTest(G), be) {
          const Xe = Ue.get(U.texture);
          k.framebufferTexture2D(k.FRAMEBUFFER, k.COLOR_ATTACHMENT0, k.TEXTURE_CUBE_MAP_POSITIVE_X + Y, Xe.__webglTexture, ne);
        } else if (Pe) {
          const Xe = Ue.get(U.texture), at = Y;
          k.framebufferTextureLayer(k.FRAMEBUFFER, k.COLOR_ATTACHMENT0, Xe.__webglTexture, ne, at);
        } else if (U !== null && ne !== 0) {
          const Xe = Ue.get(U.texture);
          k.framebufferTexture2D(k.FRAMEBUFFER, k.COLOR_ATTACHMENT0, k.TEXTURE_2D, Xe.__webglTexture, ne);
        }
        w = -1;
      }, this.readRenderTargetPixels = function(U, Y, ne, re, j, be, Pe) {
        if (!(U && U.isWebGLRenderTarget)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
          return;
        }
        let We = Ue.get(U).__webglFramebuffer;
        if (U.isWebGLCubeRenderTarget && Pe !== void 0 && (We = We[Pe]), We) {
          Ee.bindFramebuffer(k.FRAMEBUFFER, We);
          try {
            const Xe = U.texture, at = Xe.format, ct = Xe.type;
            if (!ze.textureFormatReadable(at)) {
              console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
              return;
            }
            if (!ze.textureTypeReadable(ct)) {
              console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
              return;
            }
            Y >= 0 && Y <= U.width - re && ne >= 0 && ne <= U.height - j && k.readPixels(Y, ne, re, j, ht.convert(at), ht.convert(ct), be);
          } finally {
            const Xe = N !== null ? Ue.get(N).__webglFramebuffer : null;
            Ee.bindFramebuffer(k.FRAMEBUFFER, Xe);
          }
        }
      }, this.readRenderTargetPixelsAsync = async function(U, Y, ne, re, j, be, Pe) {
        if (!(U && U.isWebGLRenderTarget)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        let We = Ue.get(U).__webglFramebuffer;
        if (U.isWebGLCubeRenderTarget && Pe !== void 0 && (We = We[Pe]), We) {
          const Xe = U.texture, at = Xe.format, ct = Xe.type;
          if (!ze.textureFormatReadable(at)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
          if (!ze.textureTypeReadable(ct)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
          if (Y >= 0 && Y <= U.width - re && ne >= 0 && ne <= U.height - j) {
            Ee.bindFramebuffer(k.FRAMEBUFFER, We);
            const et = k.createBuffer();
            k.bindBuffer(k.PIXEL_PACK_BUFFER, et), k.bufferData(k.PIXEL_PACK_BUFFER, be.byteLength, k.STREAM_READ), k.readPixels(Y, ne, re, j, ht.convert(at), ht.convert(ct), 0);
            const At = N !== null ? Ue.get(N).__webglFramebuffer : null;
            Ee.bindFramebuffer(k.FRAMEBUFFER, At);
            const Dt = k.fenceSync(k.SYNC_GPU_COMMANDS_COMPLETE, 0);
            return k.flush(), await bv(k, Dt, 4), k.bindBuffer(k.PIXEL_PACK_BUFFER, et), k.getBufferSubData(k.PIXEL_PACK_BUFFER, 0, be), k.deleteBuffer(et), k.deleteSync(Dt), be;
          } else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
        }
      }, this.copyFramebufferToTexture = function(U, Y = null, ne = 0) {
        U.isTexture !== true && (ho("WebGLRenderer: copyFramebufferToTexture function signature has changed."), Y = arguments[0] || null, U = arguments[1]);
        const re = Math.pow(2, -ne), j = Math.floor(U.image.width * re), be = Math.floor(U.image.height * re), Pe = Y !== null ? Y.x : 0, We = Y !== null ? Y.y : 0;
        O.setTexture2D(U, 0), k.copyTexSubImage2D(k.TEXTURE_2D, ne, 0, 0, Pe, We, j, be), Ee.unbindTexture();
      };
      const fa = k.createFramebuffer(), Xs = k.createFramebuffer();
      this.copyTextureToTexture = function(U, Y, ne = null, re = null, j = 0, be = null) {
        U.isTexture !== true && (ho("WebGLRenderer: copyTextureToTexture function signature has changed."), re = arguments[0] || null, U = arguments[1], Y = arguments[2], be = arguments[3] || 0, ne = null), be === null && (j !== 0 ? (ho("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), be = j, j = 0) : be = 0);
        let Pe, We, Xe, at, ct, et, At, Dt, tn;
        const St = U.isCompressedTexture ? U.mipmaps[be] : U.image;
        if (ne !== null) Pe = ne.max.x - ne.min.x, We = ne.max.y - ne.min.y, Xe = ne.isBox3 ? ne.max.z - ne.min.z : 1, at = ne.min.x, ct = ne.min.y, et = ne.isBox3 ? ne.min.z : 0;
        else {
          const Qt = Math.pow(2, -j);
          Pe = Math.floor(St.width * Qt), We = Math.floor(St.height * Qt), U.isDataArrayTexture ? Xe = St.depth : U.isData3DTexture ? Xe = Math.floor(St.depth * Qt) : Xe = 1, at = 0, ct = 0, et = 0;
        }
        re !== null ? (At = re.x, Dt = re.y, tn = re.z) : (At = 0, Dt = 0, tn = 0);
        const yt = ht.convert(Y.format), Qe = ht.convert(Y.type);
        let xn;
        Y.isData3DTexture ? (O.setTexture3D(Y, 0), xn = k.TEXTURE_3D) : Y.isDataArrayTexture || Y.isCompressedArrayTexture ? (O.setTexture2DArray(Y, 0), xn = k.TEXTURE_2D_ARRAY) : (O.setTexture2D(Y, 0), xn = k.TEXTURE_2D), k.pixelStorei(k.UNPACK_FLIP_Y_WEBGL, Y.flipY), k.pixelStorei(k.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Y.premultiplyAlpha), k.pixelStorei(k.UNPACK_ALIGNMENT, Y.unpackAlignment);
        const Ft = k.getParameter(k.UNPACK_ROW_LENGTH), Hn = k.getParameter(k.UNPACK_IMAGE_HEIGHT), sr = k.getParameter(k.UNPACK_SKIP_PIXELS), wn = k.getParameter(k.UNPACK_SKIP_ROWS), Lr = k.getParameter(k.UNPACK_SKIP_IMAGES);
        k.pixelStorei(k.UNPACK_ROW_LENGTH, St.width), k.pixelStorei(k.UNPACK_IMAGE_HEIGHT, St.height), k.pixelStorei(k.UNPACK_SKIP_PIXELS, at), k.pixelStorei(k.UNPACK_SKIP_ROWS, ct), k.pixelStorei(k.UNPACK_SKIP_IMAGES, et);
        const Zt = U.isDataArrayTexture || U.isData3DTexture, Zn = Y.isDataArrayTexture || Y.isData3DTexture;
        if (U.isDepthTexture) {
          const Qt = Ue.get(U), An = Ue.get(Y), dn = Ue.get(Qt.__renderTarget), da = Ue.get(An.__renderTarget);
          Ee.bindFramebuffer(k.READ_FRAMEBUFFER, dn.__webglFramebuffer), Ee.bindFramebuffer(k.DRAW_FRAMEBUFFER, da.__webglFramebuffer);
          for (let or = 0; or < Xe; or++) Zt && (k.framebufferTextureLayer(k.READ_FRAMEBUFFER, k.COLOR_ATTACHMENT0, Ue.get(U).__webglTexture, j, et + or), k.framebufferTextureLayer(k.DRAW_FRAMEBUFFER, k.COLOR_ATTACHMENT0, Ue.get(Y).__webglTexture, be, tn + or)), k.blitFramebuffer(at, ct, Pe, We, At, Dt, Pe, We, k.DEPTH_BUFFER_BIT, k.NEAREST);
          Ee.bindFramebuffer(k.READ_FRAMEBUFFER, null), Ee.bindFramebuffer(k.DRAW_FRAMEBUFFER, null);
        } else if (j !== 0 || U.isRenderTargetTexture || Ue.has(U)) {
          const Qt = Ue.get(U), An = Ue.get(Y);
          Ee.bindFramebuffer(k.READ_FRAMEBUFFER, fa), Ee.bindFramebuffer(k.DRAW_FRAMEBUFFER, Xs);
          for (let dn = 0; dn < Xe; dn++) Zt ? k.framebufferTextureLayer(k.READ_FRAMEBUFFER, k.COLOR_ATTACHMENT0, Qt.__webglTexture, j, et + dn) : k.framebufferTexture2D(k.READ_FRAMEBUFFER, k.COLOR_ATTACHMENT0, k.TEXTURE_2D, Qt.__webglTexture, j), Zn ? k.framebufferTextureLayer(k.DRAW_FRAMEBUFFER, k.COLOR_ATTACHMENT0, An.__webglTexture, be, tn + dn) : k.framebufferTexture2D(k.DRAW_FRAMEBUFFER, k.COLOR_ATTACHMENT0, k.TEXTURE_2D, An.__webglTexture, be), j !== 0 ? k.blitFramebuffer(at, ct, Pe, We, At, Dt, Pe, We, k.COLOR_BUFFER_BIT, k.NEAREST) : Zn ? k.copyTexSubImage3D(xn, be, At, Dt, tn + dn, at, ct, Pe, We) : k.copyTexSubImage2D(xn, be, At, Dt, at, ct, Pe, We);
          Ee.bindFramebuffer(k.READ_FRAMEBUFFER, null), Ee.bindFramebuffer(k.DRAW_FRAMEBUFFER, null);
        } else Zn ? U.isDataTexture || U.isData3DTexture ? k.texSubImage3D(xn, be, At, Dt, tn, Pe, We, Xe, yt, Qe, St.data) : Y.isCompressedArrayTexture ? k.compressedTexSubImage3D(xn, be, At, Dt, tn, Pe, We, Xe, yt, St.data) : k.texSubImage3D(xn, be, At, Dt, tn, Pe, We, Xe, yt, Qe, St) : U.isDataTexture ? k.texSubImage2D(k.TEXTURE_2D, be, At, Dt, Pe, We, yt, Qe, St.data) : U.isCompressedTexture ? k.compressedTexSubImage2D(k.TEXTURE_2D, be, At, Dt, St.width, St.height, yt, St.data) : k.texSubImage2D(k.TEXTURE_2D, be, At, Dt, Pe, We, yt, Qe, St);
        k.pixelStorei(k.UNPACK_ROW_LENGTH, Ft), k.pixelStorei(k.UNPACK_IMAGE_HEIGHT, Hn), k.pixelStorei(k.UNPACK_SKIP_PIXELS, sr), k.pixelStorei(k.UNPACK_SKIP_ROWS, wn), k.pixelStorei(k.UNPACK_SKIP_IMAGES, Lr), be === 0 && Y.generateMipmaps && k.generateMipmap(xn), Ee.unbindTexture();
      }, this.copyTextureToTexture3D = function(U, Y, ne = null, re = null, j = 0) {
        return U.isTexture !== true && (ho("WebGLRenderer: copyTextureToTexture3D function signature has changed."), ne = arguments[0] || null, re = arguments[1] || null, U = arguments[2], Y = arguments[3], j = arguments[4] || 0), ho('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(U, Y, ne, re, j);
      }, this.initRenderTarget = function(U) {
        Ue.get(U).__webglFramebuffer === void 0 && O.setupRenderTarget(U);
      }, this.initTexture = function(U) {
        U.isCubeTexture ? O.setTextureCube(U, 0) : U.isData3DTexture ? O.setTexture3D(U, 0) : U.isDataArrayTexture || U.isCompressedArrayTexture ? O.setTexture2DArray(U, 0) : O.setTexture2D(U, 0), Ee.unbindTexture();
      }, this.resetState = function() {
        R = 0, d = 0, N = null, Ee.reset(), Wt.reset();
      }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
        detail: this
      }));
    }
    get coordinateSystem() {
      return br;
    }
    get outputColorSpace() {
      return this._outputColorSpace;
    }
    set outputColorSpace(e) {
      this._outputColorSpace = e;
      const t = this.getContext();
      t.drawingBufferColorspace = It._getDrawingBufferColorSpace(e), t.unpackColorSpace = It._getUnpackColorSpace();
    }
  }
  function $p(s, e) {
    if (e === q0) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), s;
    if (e === Gh || e === Gm) {
      let t = s.getIndex();
      if (t === null) {
        const o = [], a = s.getAttribute("position");
        if (a !== void 0) {
          for (let l = 0; l < a.count; l++) o.push(l);
          s.setIndex(o), t = s.getIndex();
        } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), s;
      }
      const n = t.count - 2, i = [];
      if (e === Gh) for (let o = 1; o <= n; o++) i.push(t.getX(0)), i.push(t.getX(o)), i.push(t.getX(o + 1));
      else for (let o = 0; o < n; o++) o % 2 === 0 ? (i.push(t.getX(o)), i.push(t.getX(o + 1)), i.push(t.getX(o + 2))) : (i.push(t.getX(o + 2)), i.push(t.getX(o + 1)), i.push(t.getX(o)));
      i.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
      const r = s.clone();
      return r.setIndex(i), r.clearGroups(), r;
    } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), s;
  }
  class JT extends Bs {
    constructor(e) {
      super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
        return new iE(t);
      }), this.register(function(t) {
        return new rE(t);
      }), this.register(function(t) {
        return new dE(t);
      }), this.register(function(t) {
        return new pE(t);
      }), this.register(function(t) {
        return new mE(t);
      }), this.register(function(t) {
        return new oE(t);
      }), this.register(function(t) {
        return new aE(t);
      }), this.register(function(t) {
        return new lE(t);
      }), this.register(function(t) {
        return new cE(t);
      }), this.register(function(t) {
        return new nE(t);
      }), this.register(function(t) {
        return new uE(t);
      }), this.register(function(t) {
        return new sE(t);
      }), this.register(function(t) {
        return new fE(t);
      }), this.register(function(t) {
        return new hE(t);
      }), this.register(function(t) {
        return new eE(t);
      }), this.register(function(t) {
        return new gE(t);
      }), this.register(function(t) {
        return new _E(t);
      });
    }
    load(e, t, n, i) {
      const r = this;
      let o;
      if (this.resourcePath !== "") o = this.resourcePath;
      else if (this.path !== "") {
        const c = Ha.extractUrlBase(e);
        o = Ha.resolveURL(c, this.path);
      } else o = Ha.extractUrlBase(e);
      this.manager.itemStart(e);
      const a = function(c) {
        i ? i(c) : console.error(c), r.manager.itemError(e), r.manager.itemEnd(e);
      }, l = new Bf(this.manager);
      l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(c) {
        try {
          r.parse(c, o, function(h) {
            t(h), r.manager.itemEnd(e);
          }, a);
        } catch (h) {
          a(h);
        }
      }, n, a);
    }
    setDRACOLoader(e) {
      return this.dracoLoader = e, this;
    }
    setKTX2Loader(e) {
      return this.ktx2Loader = e, this;
    }
    setMeshoptDecoder(e) {
      return this.meshoptDecoder = e, this;
    }
    register(e) {
      return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
    }
    unregister(e) {
      return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
    }
    parse(e, t, n, i) {
      let r;
      const o = {}, a = {}, l = new TextDecoder();
      if (typeof e == "string") r = JSON.parse(e);
      else if (e instanceof ArrayBuffer) if (l.decode(new Uint8Array(e, 0, 4)) === Sg) {
        try {
          o[Et.KHR_BINARY_GLTF] = new vE(e);
        } catch (f) {
          i && i(f);
          return;
        }
        r = JSON.parse(o[Et.KHR_BINARY_GLTF].content);
      } else r = JSON.parse(l.decode(e));
      else r = e;
      if (r.asset === void 0 || r.asset.version[0] < 2) {
        i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
        return;
      }
      const c = new DE(r, {
        path: t || this.resourcePath || "",
        crossOrigin: this.crossOrigin,
        requestHeader: this.requestHeader,
        manager: this.manager,
        ktx2Loader: this.ktx2Loader,
        meshoptDecoder: this.meshoptDecoder
      });
      c.fileLoader.setRequestHeader(this.requestHeader);
      for (let h = 0; h < this.pluginCallbacks.length; h++) {
        const f = this.pluginCallbacks[h](c);
        f.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), a[f.name] = f, o[f.name] = true;
      }
      if (r.extensionsUsed) for (let h = 0; h < r.extensionsUsed.length; ++h) {
        const f = r.extensionsUsed[h], m = r.extensionsRequired || [];
        switch (f) {
          case Et.KHR_MATERIALS_UNLIT:
            o[f] = new tE();
            break;
          case Et.KHR_DRACO_MESH_COMPRESSION:
            o[f] = new yE(r, this.dracoLoader);
            break;
          case Et.KHR_TEXTURE_TRANSFORM:
            o[f] = new xE();
            break;
          case Et.KHR_MESH_QUANTIZATION:
            o[f] = new bE();
            break;
          default:
            m.indexOf(f) >= 0 && a[f] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + f + '".');
        }
      }
      c.setExtensions(o), c.setPlugins(a), c.parse(n, i);
    }
    parseAsync(e, t) {
      const n = this;
      return new Promise(function(i, r) {
        n.parse(e, t, i, r);
      });
    }
  }
  function QT() {
    let s = {};
    return {
      get: function(e) {
        return s[e];
      },
      add: function(e, t) {
        s[e] = t;
      },
      remove: function(e) {
        delete s[e];
      },
      removeAll: function() {
        s = {};
      }
    };
  }
  const Et = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_MATERIALS_BUMP: "EXT_materials_bump",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_TEXTURE_AVIF: "EXT_texture_avif",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
  };
  class eE {
    constructor(e) {
      this.parser = e, this.name = Et.KHR_LIGHTS_PUNCTUAL, this.cache = {
        refs: {},
        uses: {}
      };
    }
    _markDefs() {
      const e = this.parser, t = this.parser.json.nodes || [];
      for (let n = 0, i = t.length; n < i; n++) {
        const r = t[n];
        r.extensions && r.extensions[this.name] && r.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, r.extensions[this.name].light);
      }
    }
    _loadLight(e) {
      const t = this.parser, n = "light:" + e;
      let i = t.cache.get(n);
      if (i) return i;
      const r = t.json, l = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
      let c;
      const h = new it(16777215);
      l.color !== void 0 && h.setRGB(l.color[0], l.color[1], l.color[2], $n);
      const f = l.range !== void 0 ? l.range : 0;
      switch (l.type) {
        case "directional":
          c = new mg(h), c.target.position.set(0, 0, -1), c.add(c.target);
          break;
        case "point":
          c = new Hf(h), c.distance = f;
          break;
        case "spot":
          c = new ex(h), c.distance = f, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, c.angle = l.spot.outerConeAngle, c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
          break;
        default:
          throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
      }
      return c.position.set(0, 0, 0), _r(c, l), l.intensity !== void 0 && (c.intensity = l.intensity), c.name = t.createUniqueName(l.name || "light_" + e), i = Promise.resolve(c), t.cache.add(n, i), i;
    }
    getDependency(e, t) {
      if (e === "light") return this._loadLight(t);
    }
    createNodeAttachment(e) {
      const t = this, n = this.parser, r = n.json.nodes[e], a = (r.extensions && r.extensions[this.name] || {}).light;
      return a === void 0 ? null : this._loadLight(a).then(function(l) {
        return n._getNodeRef(t.cache, a, l);
      });
    }
  }
  class tE {
    constructor() {
      this.name = Et.KHR_MATERIALS_UNLIT;
    }
    getMaterialType() {
      return qi;
    }
    extendParams(e, t, n) {
      const i = [];
      e.color = new it(1, 1, 1), e.opacity = 1;
      const r = t.pbrMetallicRoughness;
      if (r) {
        if (Array.isArray(r.baseColorFactor)) {
          const o = r.baseColorFactor;
          e.color.setRGB(o[0], o[1], o[2], $n), e.opacity = o[3];
        }
        r.baseColorTexture !== void 0 && i.push(n.assignTexture(e, "map", r.baseColorTexture, Dn));
      }
      return Promise.all(i);
    }
  }
  class nE {
    constructor(e) {
      this.parser = e, this.name = Et.KHR_MATERIALS_EMISSIVE_STRENGTH;
    }
    extendMaterialParams(e, t) {
      const i = this.parser.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const r = i.extensions[this.name].emissiveStrength;
      return r !== void 0 && (t.emissiveIntensity = r), Promise.resolve();
    }
  }
  class iE {
    constructor(e) {
      this.parser = e, this.name = Et.KHR_MATERIALS_CLEARCOAT;
    }
    getMaterialType(e) {
      const n = this.parser.json.materials[e];
      return !n.extensions || !n.extensions[this.name] ? null : tr;
    }
    extendMaterialParams(e, t) {
      const n = this.parser, i = n.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const r = [], o = i.extensions[this.name];
      if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor), o.clearcoatTexture !== void 0 && r.push(n.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), o.clearcoatRoughnessTexture !== void 0 && r.push(n.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), o.clearcoatNormalTexture !== void 0 && (r.push(n.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0)) {
        const a = o.clearcoatNormalTexture.scale;
        t.clearcoatNormalScale = new Se(a, a);
      }
      return Promise.all(r);
    }
  }
  class rE {
    constructor(e) {
      this.parser = e, this.name = Et.KHR_MATERIALS_DISPERSION;
    }
    getMaterialType(e) {
      const n = this.parser.json.materials[e];
      return !n.extensions || !n.extensions[this.name] ? null : tr;
    }
    extendMaterialParams(e, t) {
      const i = this.parser.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const r = i.extensions[this.name];
      return t.dispersion = r.dispersion !== void 0 ? r.dispersion : 0, Promise.resolve();
    }
  }
  class sE {
    constructor(e) {
      this.parser = e, this.name = Et.KHR_MATERIALS_IRIDESCENCE;
    }
    getMaterialType(e) {
      const n = this.parser.json.materials[e];
      return !n.extensions || !n.extensions[this.name] ? null : tr;
    }
    extendMaterialParams(e, t) {
      const n = this.parser, i = n.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const r = [], o = i.extensions[this.name];
      return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor), o.iridescenceTexture !== void 0 && r.push(n.assignTexture(t, "iridescenceMap", o.iridescenceTexture)), o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [
        100,
        400
      ]), o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), o.iridescenceThicknessTexture !== void 0 && r.push(n.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)), Promise.all(r);
    }
  }
  class oE {
    constructor(e) {
      this.parser = e, this.name = Et.KHR_MATERIALS_SHEEN;
    }
    getMaterialType(e) {
      const n = this.parser.json.materials[e];
      return !n.extensions || !n.extensions[this.name] ? null : tr;
    }
    extendMaterialParams(e, t) {
      const n = this.parser, i = n.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const r = [];
      t.sheenColor = new it(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
      const o = i.extensions[this.name];
      if (o.sheenColorFactor !== void 0) {
        const a = o.sheenColorFactor;
        t.sheenColor.setRGB(a[0], a[1], a[2], $n);
      }
      return o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor), o.sheenColorTexture !== void 0 && r.push(n.assignTexture(t, "sheenColorMap", o.sheenColorTexture, Dn)), o.sheenRoughnessTexture !== void 0 && r.push(n.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(r);
    }
  }
  class aE {
    constructor(e) {
      this.parser = e, this.name = Et.KHR_MATERIALS_TRANSMISSION;
    }
    getMaterialType(e) {
      const n = this.parser.json.materials[e];
      return !n.extensions || !n.extensions[this.name] ? null : tr;
    }
    extendMaterialParams(e, t) {
      const n = this.parser, i = n.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const r = [], o = i.extensions[this.name];
      return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor), o.transmissionTexture !== void 0 && r.push(n.assignTexture(t, "transmissionMap", o.transmissionTexture)), Promise.all(r);
    }
  }
  class lE {
    constructor(e) {
      this.parser = e, this.name = Et.KHR_MATERIALS_VOLUME;
    }
    getMaterialType(e) {
      const n = this.parser.json.materials[e];
      return !n.extensions || !n.extensions[this.name] ? null : tr;
    }
    extendMaterialParams(e, t) {
      const n = this.parser, i = n.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const r = [], o = i.extensions[this.name];
      t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0, o.thicknessTexture !== void 0 && r.push(n.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 1 / 0;
      const a = o.attenuationColor || [
        1,
        1,
        1
      ];
      return t.attenuationColor = new it().setRGB(a[0], a[1], a[2], $n), Promise.all(r);
    }
  }
  class cE {
    constructor(e) {
      this.parser = e, this.name = Et.KHR_MATERIALS_IOR;
    }
    getMaterialType(e) {
      const n = this.parser.json.materials[e];
      return !n.extensions || !n.extensions[this.name] ? null : tr;
    }
    extendMaterialParams(e, t) {
      const i = this.parser.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const r = i.extensions[this.name];
      return t.ior = r.ior !== void 0 ? r.ior : 1.5, Promise.resolve();
    }
  }
  class uE {
    constructor(e) {
      this.parser = e, this.name = Et.KHR_MATERIALS_SPECULAR;
    }
    getMaterialType(e) {
      const n = this.parser.json.materials[e];
      return !n.extensions || !n.extensions[this.name] ? null : tr;
    }
    extendMaterialParams(e, t) {
      const n = this.parser, i = n.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const r = [], o = i.extensions[this.name];
      t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1, o.specularTexture !== void 0 && r.push(n.assignTexture(t, "specularIntensityMap", o.specularTexture));
      const a = o.specularColorFactor || [
        1,
        1,
        1
      ];
      return t.specularColor = new it().setRGB(a[0], a[1], a[2], $n), o.specularColorTexture !== void 0 && r.push(n.assignTexture(t, "specularColorMap", o.specularColorTexture, Dn)), Promise.all(r);
    }
  }
  class hE {
    constructor(e) {
      this.parser = e, this.name = Et.EXT_MATERIALS_BUMP;
    }
    getMaterialType(e) {
      const n = this.parser.json.materials[e];
      return !n.extensions || !n.extensions[this.name] ? null : tr;
    }
    extendMaterialParams(e, t) {
      const n = this.parser, i = n.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const r = [], o = i.extensions[this.name];
      return t.bumpScale = o.bumpFactor !== void 0 ? o.bumpFactor : 1, o.bumpTexture !== void 0 && r.push(n.assignTexture(t, "bumpMap", o.bumpTexture)), Promise.all(r);
    }
  }
  class fE {
    constructor(e) {
      this.parser = e, this.name = Et.KHR_MATERIALS_ANISOTROPY;
    }
    getMaterialType(e) {
      const n = this.parser.json.materials[e];
      return !n.extensions || !n.extensions[this.name] ? null : tr;
    }
    extendMaterialParams(e, t) {
      const n = this.parser, i = n.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const r = [], o = i.extensions[this.name];
      return o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength), o.anisotropyRotation !== void 0 && (t.anisotropyRotation = o.anisotropyRotation), o.anisotropyTexture !== void 0 && r.push(n.assignTexture(t, "anisotropyMap", o.anisotropyTexture)), Promise.all(r);
    }
  }
  class dE {
    constructor(e) {
      this.parser = e, this.name = Et.KHR_TEXTURE_BASISU;
    }
    loadTexture(e) {
      const t = this.parser, n = t.json, i = n.textures[e];
      if (!i.extensions || !i.extensions[this.name]) return null;
      const r = i.extensions[this.name], o = t.options.ktx2Loader;
      if (!o) {
        if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
        return null;
      }
      return t.loadTextureImage(e, r.source, o);
    }
  }
  class pE {
    constructor(e) {
      this.parser = e, this.name = Et.EXT_TEXTURE_WEBP, this.isSupported = null;
    }
    loadTexture(e) {
      const t = this.name, n = this.parser, i = n.json, r = i.textures[e];
      if (!r.extensions || !r.extensions[t]) return null;
      const o = r.extensions[t], a = i.images[o.source];
      let l = n.textureLoader;
      if (a.uri) {
        const c = n.options.manager.getHandler(a.uri);
        c !== null && (l = c);
      }
      return this.detectSupport().then(function(c) {
        if (c) return n.loadTextureImage(e, o.source, l);
        if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
        return n.loadTexture(e);
      });
    }
    detectSupport() {
      return this.isSupported || (this.isSupported = new Promise(function(e) {
        const t = new Image();
        t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
          e(t.height === 1);
        };
      })), this.isSupported;
    }
  }
  class mE {
    constructor(e) {
      this.parser = e, this.name = Et.EXT_TEXTURE_AVIF, this.isSupported = null;
    }
    loadTexture(e) {
      const t = this.name, n = this.parser, i = n.json, r = i.textures[e];
      if (!r.extensions || !r.extensions[t]) return null;
      const o = r.extensions[t], a = i.images[o.source];
      let l = n.textureLoader;
      if (a.uri) {
        const c = n.options.manager.getHandler(a.uri);
        c !== null && (l = c);
      }
      return this.detectSupport().then(function(c) {
        if (c) return n.loadTextureImage(e, o.source, l);
        if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
        return n.loadTexture(e);
      });
    }
    detectSupport() {
      return this.isSupported || (this.isSupported = new Promise(function(e) {
        const t = new Image();
        t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
          e(t.height === 1);
        };
      })), this.isSupported;
    }
  }
  class gE {
    constructor(e) {
      this.name = Et.EXT_MESHOPT_COMPRESSION, this.parser = e;
    }
    loadBufferView(e) {
      const t = this.parser.json, n = t.bufferViews[e];
      if (n.extensions && n.extensions[this.name]) {
        const i = n.extensions[this.name], r = this.parser.getDependency("buffer", i.buffer), o = this.parser.options.meshoptDecoder;
        if (!o || !o.supported) {
          if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
          return null;
        }
        return r.then(function(a) {
          const l = i.byteOffset || 0, c = i.byteLength || 0, h = i.count, f = i.byteStride, m = new Uint8Array(a, l, c);
          return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(h, f, m, i.mode, i.filter).then(function(_) {
            return _.buffer;
          }) : o.ready.then(function() {
            const _ = new ArrayBuffer(h * f);
            return o.decodeGltfBuffer(new Uint8Array(_), h, f, m, i.mode, i.filter), _;
          });
        });
      } else return null;
    }
  }
  class _E {
    constructor(e) {
      this.name = Et.EXT_MESH_GPU_INSTANCING, this.parser = e;
    }
    createNodeMesh(e) {
      const t = this.parser.json, n = t.nodes[e];
      if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0) return null;
      const i = t.meshes[n.mesh];
      for (const c of i.primitives) if (c.mode !== Mi.TRIANGLES && c.mode !== Mi.TRIANGLE_STRIP && c.mode !== Mi.TRIANGLE_FAN && c.mode !== void 0) return null;
      const o = n.extensions[this.name].attributes, a = [], l = {};
      for (const c in o) a.push(this.parser.getDependency("accessor", o[c]).then((h) => (l[c] = h, l[c])));
      return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)), Promise.all(a).then((c) => {
        const h = c.pop(), f = h.isGroup ? h.children : [
          h
        ], m = c[0].count, _ = [];
        for (const y of f) {
          const g = new pt(), x = new V(), v = new rs(), E = new V(1, 1, 1), T = new Qv(y.geometry, y.material, m);
          for (let M = 0; M < m; M++) l.TRANSLATION && x.fromBufferAttribute(l.TRANSLATION, M), l.ROTATION && v.fromBufferAttribute(l.ROTATION, M), l.SCALE && E.fromBufferAttribute(l.SCALE, M), T.setMatrixAt(M, g.compose(x, v, E));
          for (const M in l) if (M === "_COLOR_0") {
            const P = l[M];
            T.instanceColor = new Xh(P.array, P.itemSize, P.normalized);
          } else M !== "TRANSLATION" && M !== "ROTATION" && M !== "SCALE" && y.geometry.setAttribute(M, l[M]);
          on.prototype.copy.call(T, y), this.parser.assignFinalMaterial(T), _.push(T);
        }
        return h.isGroup ? (h.clear(), h.add(..._), h) : _[0];
      }));
    }
  }
  const Sg = "glTF", Aa = 12, Kp = {
    JSON: 1313821514,
    BIN: 5130562
  };
  class vE {
    constructor(e) {
      this.name = Et.KHR_BINARY_GLTF, this.content = null, this.body = null;
      const t = new DataView(e, 0, Aa), n = new TextDecoder();
      if (this.header = {
        magic: n.decode(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, true),
        length: t.getUint32(8, true)
      }, this.header.magic !== Sg) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
      if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
      const i = this.header.length - Aa, r = new DataView(e, Aa);
      let o = 0;
      for (; o < i; ) {
        const a = r.getUint32(o, true);
        o += 4;
        const l = r.getUint32(o, true);
        if (o += 4, l === Kp.JSON) {
          const c = new Uint8Array(e, Aa + o, a);
          this.content = n.decode(c);
        } else if (l === Kp.BIN) {
          const c = Aa + o;
          this.body = e.slice(c, c + a);
        }
        o += a;
      }
      if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
  class yE {
    constructor(e, t) {
      if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
      this.name = Et.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
    }
    decodePrimitive(e, t) {
      const n = this.json, i = this.dracoLoader, r = e.extensions[this.name].bufferView, o = e.extensions[this.name].attributes, a = {}, l = {}, c = {};
      for (const h in o) {
        const f = Qh[h] || h.toLowerCase();
        a[f] = o[h];
      }
      for (const h in e.attributes) {
        const f = Qh[h] || h.toLowerCase();
        if (o[h] !== void 0) {
          const m = n.accessors[e.attributes[h]], _ = Mo[m.componentType];
          c[f] = _.name, l[f] = m.normalized === true;
        }
      }
      return t.getDependency("bufferView", r).then(function(h) {
        return new Promise(function(f, m) {
          i.decodeDracoFile(h, function(_) {
            for (const y in _.attributes) {
              const g = _.attributes[y], x = l[y];
              x !== void 0 && (g.normalized = x);
            }
            f(_);
          }, a, c, $n, m);
        });
      });
    }
  }
  class xE {
    constructor() {
      this.name = Et.KHR_TEXTURE_TRANSFORM;
    }
    extendTexture(e, t) {
      return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = true), e;
    }
  }
  class bE {
    constructor() {
      this.name = Et.KHR_MESH_QUANTIZATION;
    }
  }
  class Mg extends fl {
    constructor(e, t, n, i) {
      super(e, t, n, i);
    }
    copySampleValue_(e) {
      const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i * 3 + i;
      for (let o = 0; o !== i; o++) t[o] = n[r + o];
      return t;
    }
    interpolate_(e, t, n, i) {
      const r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = a * 2, c = a * 3, h = i - t, f = (n - t) / h, m = f * f, _ = m * f, y = e * c, g = y - c, x = -2 * _ + 3 * m, v = _ - m, E = 1 - x, T = v - m + f;
      for (let M = 0; M !== a; M++) {
        const P = o[g + M + a], R = o[g + M + l] * h, d = o[y + M + a], N = o[y + M] * h;
        r[M] = E * P + T * R + x * d + v * N;
      }
      return r;
    }
  }
  const SE = new rs();
  class ME extends Mg {
    interpolate_(e, t, n, i) {
      const r = super.interpolate_(e, t, n, i);
      return SE.fromArray(r).normalize().toArray(r), r;
    }
  }
  const Mi = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6
  }, Mo = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  }, Zp = {
    9728: Yn,
    9729: fi,
    9984: Im,
    9985: sc,
    9986: Ia,
    9987: xr
  }, Jp = {
    33071: Yr,
    33648: bc,
    10497: Po
  }, Wu = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  }, Qh = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
  }, Vr = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
  }, TE = {
    CUBICSPLINE: void 0,
    LINEAR: Ka,
    STEP: $a
  }, Xu = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
  };
  function EE(s) {
    return s.DefaultMaterial === void 0 && (s.DefaultMaterial = new Yo({
      color: 16777215,
      emissive: 0,
      metalness: 1,
      roughness: 1,
      transparent: false,
      depthTest: true,
      side: Er
    })), s.DefaultMaterial;
  }
  function _s(s, e, t) {
    for (const n in t.extensions) s[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[n] = t.extensions[n]);
  }
  function _r(s, e) {
    e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(s.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
  }
  function wE(s, e, t) {
    let n = false, i = false, r = false;
    for (let c = 0, h = e.length; c < h; c++) {
      const f = e[c];
      if (f.POSITION !== void 0 && (n = true), f.NORMAL !== void 0 && (i = true), f.COLOR_0 !== void 0 && (r = true), n && i && r) break;
    }
    if (!n && !i && !r) return Promise.resolve(s);
    const o = [], a = [], l = [];
    for (let c = 0, h = e.length; c < h; c++) {
      const f = e[c];
      if (n) {
        const m = f.POSITION !== void 0 ? t.getDependency("accessor", f.POSITION) : s.attributes.position;
        o.push(m);
      }
      if (i) {
        const m = f.NORMAL !== void 0 ? t.getDependency("accessor", f.NORMAL) : s.attributes.normal;
        a.push(m);
      }
      if (r) {
        const m = f.COLOR_0 !== void 0 ? t.getDependency("accessor", f.COLOR_0) : s.attributes.color;
        l.push(m);
      }
    }
    return Promise.all([
      Promise.all(o),
      Promise.all(a),
      Promise.all(l)
    ]).then(function(c) {
      const h = c[0], f = c[1], m = c[2];
      return n && (s.morphAttributes.position = h), i && (s.morphAttributes.normal = f), r && (s.morphAttributes.color = m), s.morphTargetsRelative = true, s;
    });
  }
  function AE(s, e) {
    if (s.updateMorphTargets(), e.weights !== void 0) for (let t = 0, n = e.weights.length; t < n; t++) s.morphTargetInfluences[t] = e.weights[t];
    if (e.extras && Array.isArray(e.extras.targetNames)) {
      const t = e.extras.targetNames;
      if (s.morphTargetInfluences.length === t.length) {
        s.morphTargetDictionary = {};
        for (let n = 0, i = t.length; n < i; n++) s.morphTargetDictionary[t[n]] = n;
      } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
  function CE(s) {
    let e;
    const t = s.extensions && s.extensions[Et.KHR_DRACO_MESH_COMPRESSION];
    if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + qu(t.attributes) : e = s.indices + ":" + qu(s.attributes) + ":" + s.mode, s.targets !== void 0) for (let n = 0, i = s.targets.length; n < i; n++) e += ":" + qu(s.targets[n]);
    return e;
  }
  function qu(s) {
    let e = "";
    const t = Object.keys(s).sort();
    for (let n = 0, i = t.length; n < i; n++) e += t[n] + ":" + s[t[n]] + ";";
    return e;
  }
  function ef(s) {
    switch (s) {
      case Int8Array:
        return 1 / 127;
      case Uint8Array:
        return 1 / 255;
      case Int16Array:
        return 1 / 32767;
      case Uint16Array:
        return 1 / 65535;
      default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
    }
  }
  function RE(s) {
    return s.search(/\.jpe?g($|\?)/i) > 0 || s.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : s.search(/\.webp($|\?)/i) > 0 || s.search(/^data\:image\/webp/) === 0 ? "image/webp" : s.search(/\.ktx2($|\?)/i) > 0 || s.search(/^data\:image\/ktx2/) === 0 ? "image/ktx2" : "image/png";
  }
  const PE = new pt();
  class DE {
    constructor(e = {}, t = {}) {
      this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new QT(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
        refs: {},
        uses: {}
      }, this.cameraCache = {
        refs: {},
        uses: {}
      }, this.lightCache = {
        refs: {},
        uses: {}
      }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
      let n = false, i = -1, r = false, o = -1;
      if (typeof navigator < "u") {
        const a = navigator.userAgent;
        n = /^((?!chrome|android).)*safari/i.test(a) === true;
        const l = a.match(/Version\/(\d+)/);
        i = n && l ? parseInt(l[1], 10) : -1, r = a.indexOf("Firefox") > -1, o = r ? a.match(/Firefox\/([0-9]+)\./)[1] : -1;
      }
      typeof createImageBitmap > "u" || n && i < 17 || r && o < 98 ? this.textureLoader = new Jy(this.options.manager) : this.textureLoader = new ix(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new Bf(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(true);
    }
    setExtensions(e) {
      this.extensions = e;
    }
    setPlugins(e) {
      this.plugins = e;
    }
    parse(e, t) {
      const n = this, i = this.json, r = this.extensions;
      this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(o) {
        return o._markDefs && o._markDefs();
      }), Promise.all(this._invokeAll(function(o) {
        return o.beforeRoot && o.beforeRoot();
      })).then(function() {
        return Promise.all([
          n.getDependencies("scene"),
          n.getDependencies("animation"),
          n.getDependencies("camera")
        ]);
      }).then(function(o) {
        const a = {
          scene: o[0][i.scene || 0],
          scenes: o[0],
          animations: o[1],
          cameras: o[2],
          asset: i.asset,
          parser: n,
          userData: {}
        };
        return _s(r, a, i), _r(a, i), Promise.all(n._invokeAll(function(l) {
          return l.afterRoot && l.afterRoot(a);
        })).then(function() {
          for (const l of a.scenes) l.updateMatrixWorld();
          e(a);
        });
      }).catch(t);
    }
    _markDefs() {
      const e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || [];
      for (let i = 0, r = t.length; i < r; i++) {
        const o = t[i].joints;
        for (let a = 0, l = o.length; a < l; a++) e[o[a]].isBone = true;
      }
      for (let i = 0, r = e.length; i < r; i++) {
        const o = e[i];
        o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (n[o.mesh].isSkinnedMesh = true)), o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera);
      }
    }
    _addNodeRef(e, t) {
      t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
    }
    _getNodeRef(e, t, n) {
      if (e.refs[t] <= 1) return n;
      const i = n.clone(), r = (o, a) => {
        const l = this.associations.get(o);
        l != null && this.associations.set(a, l);
        for (const [c, h] of o.children.entries()) r(h, a.children[c]);
      };
      return r(n, i), i.name += "_instance_" + e.uses[t]++, i;
    }
    _invokeOne(e) {
      const t = Object.values(this.plugins);
      t.push(this);
      for (let n = 0; n < t.length; n++) {
        const i = e(t[n]);
        if (i) return i;
      }
      return null;
    }
    _invokeAll(e) {
      const t = Object.values(this.plugins);
      t.unshift(this);
      const n = [];
      for (let i = 0; i < t.length; i++) {
        const r = e(t[i]);
        r && n.push(r);
      }
      return n;
    }
    getDependency(e, t) {
      const n = e + ":" + t;
      let i = this.cache.get(n);
      if (!i) {
        switch (e) {
          case "scene":
            i = this.loadScene(t);
            break;
          case "node":
            i = this._invokeOne(function(r) {
              return r.loadNode && r.loadNode(t);
            });
            break;
          case "mesh":
            i = this._invokeOne(function(r) {
              return r.loadMesh && r.loadMesh(t);
            });
            break;
          case "accessor":
            i = this.loadAccessor(t);
            break;
          case "bufferView":
            i = this._invokeOne(function(r) {
              return r.loadBufferView && r.loadBufferView(t);
            });
            break;
          case "buffer":
            i = this.loadBuffer(t);
            break;
          case "material":
            i = this._invokeOne(function(r) {
              return r.loadMaterial && r.loadMaterial(t);
            });
            break;
          case "texture":
            i = this._invokeOne(function(r) {
              return r.loadTexture && r.loadTexture(t);
            });
            break;
          case "skin":
            i = this.loadSkin(t);
            break;
          case "animation":
            i = this._invokeOne(function(r) {
              return r.loadAnimation && r.loadAnimation(t);
            });
            break;
          case "camera":
            i = this.loadCamera(t);
            break;
          default:
            if (i = this._invokeOne(function(r) {
              return r != this && r.getDependency && r.getDependency(e, t);
            }), !i) throw new Error("Unknown type: " + e);
            break;
        }
        this.cache.add(n, i);
      }
      return i;
    }
    getDependencies(e) {
      let t = this.cache.get(e);
      if (!t) {
        const n = this, i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
        t = Promise.all(i.map(function(r, o) {
          return n.getDependency(e, o);
        })), this.cache.add(e, t);
      }
      return t;
    }
    loadBuffer(e) {
      const t = this.json.buffers[e], n = this.fileLoader;
      if (t.type && t.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
      if (t.uri === void 0 && e === 0) return Promise.resolve(this.extensions[Et.KHR_BINARY_GLTF].body);
      const i = this.options;
      return new Promise(function(r, o) {
        n.load(Ha.resolveURL(t.uri, i.path), r, void 0, function() {
          o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
        });
      });
    }
    loadBufferView(e) {
      const t = this.json.bufferViews[e];
      return this.getDependency("buffer", t.buffer).then(function(n) {
        const i = t.byteLength || 0, r = t.byteOffset || 0;
        return n.slice(r, r + i);
      });
    }
    loadAccessor(e) {
      const t = this, n = this.json, i = this.json.accessors[e];
      if (i.bufferView === void 0 && i.sparse === void 0) {
        const o = Wu[i.type], a = Mo[i.componentType], l = i.normalized === true, c = new a(i.count * o);
        return Promise.resolve(new jn(c, o, l));
      }
      const r = [];
      return i.bufferView !== void 0 ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null), i.sparse !== void 0 && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(r).then(function(o) {
        const a = o[0], l = Wu[i.type], c = Mo[i.componentType], h = c.BYTES_PER_ELEMENT, f = h * l, m = i.byteOffset || 0, _ = i.bufferView !== void 0 ? n.bufferViews[i.bufferView].byteStride : void 0, y = i.normalized === true;
        let g, x;
        if (_ && _ !== f) {
          const v = Math.floor(m / _), E = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + v + ":" + i.count;
          let T = t.cache.get(E);
          T || (g = new c(a, v * _, i.count * _ / h), T = new jv(g, _ / h), t.cache.add(E, T)), x = new Pf(T, l, m % _ / h, y);
        } else a === null ? g = new c(i.count * l) : g = new c(a, m, i.count * l), x = new jn(g, l, y);
        if (i.sparse !== void 0) {
          const v = Wu.SCALAR, E = Mo[i.sparse.indices.componentType], T = i.sparse.indices.byteOffset || 0, M = i.sparse.values.byteOffset || 0, P = new E(o[1], T, i.sparse.count * v), R = new c(o[2], M, i.sparse.count * l);
          a !== null && (x = new jn(x.array.slice(), x.itemSize, x.normalized)), x.normalized = false;
          for (let d = 0, N = P.length; d < N; d++) {
            const w = P[d];
            if (x.setX(w, R[d * l]), l >= 2 && x.setY(w, R[d * l + 1]), l >= 3 && x.setZ(w, R[d * l + 2]), l >= 4 && x.setW(w, R[d * l + 3]), l >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
          }
          x.normalized = y;
        }
        return x;
      });
    }
    loadTexture(e) {
      const t = this.json, n = this.options, r = t.textures[e].source, o = t.images[r];
      let a = this.textureLoader;
      if (o.uri) {
        const l = n.manager.getHandler(o.uri);
        l !== null && (a = l);
      }
      return this.loadTextureImage(e, r, a);
    }
    loadTextureImage(e, t, n) {
      const i = this, r = this.json, o = r.textures[e], a = r.images[t], l = (a.uri || a.bufferView) + ":" + o.sampler;
      if (this.textureCache[l]) return this.textureCache[l];
      const c = this.loadImageSource(t, n).then(function(h) {
        h.flipY = false, h.name = o.name || a.name || "", h.name === "" && typeof a.uri == "string" && a.uri.startsWith("data:image/") === false && (h.name = a.uri);
        const m = (r.samplers || {})[o.sampler] || {};
        return h.magFilter = Zp[m.magFilter] || fi, h.minFilter = Zp[m.minFilter] || xr, h.wrapS = Jp[m.wrapS] || Po, h.wrapT = Jp[m.wrapT] || Po, h.generateMipmaps = !h.isCompressedTexture && h.minFilter !== Yn && h.minFilter !== fi, i.associations.set(h, {
          textures: e
        }), h;
      }).catch(function() {
        return null;
      });
      return this.textureCache[l] = c, c;
    }
    loadImageSource(e, t) {
      const n = this, i = this.json, r = this.options;
      if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then((f) => f.clone());
      const o = i.images[e], a = self.URL || self.webkitURL;
      let l = o.uri || "", c = false;
      if (o.bufferView !== void 0) l = n.getDependency("bufferView", o.bufferView).then(function(f) {
        c = true;
        const m = new Blob([
          f
        ], {
          type: o.mimeType
        });
        return l = a.createObjectURL(m), l;
      });
      else if (o.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
      const h = Promise.resolve(l).then(function(f) {
        return new Promise(function(m, _) {
          let y = m;
          t.isImageBitmapLoader === true && (y = function(g) {
            const x = new Mn(g);
            x.needsUpdate = true, m(x);
          }), t.load(Ha.resolveURL(f, r.path), y, void 0, _);
        });
      }).then(function(f) {
        return c === true && a.revokeObjectURL(l), _r(f, o), f.userData.mimeType = o.mimeType || RE(o.uri), f;
      }).catch(function(f) {
        throw console.error("THREE.GLTFLoader: Couldn't load texture", l), f;
      });
      return this.sourceCache[e] = h, h;
    }
    assignTexture(e, t, n, i) {
      const r = this;
      return this.getDependency("texture", n.index).then(function(o) {
        if (!o) return null;
        if (n.texCoord !== void 0 && n.texCoord > 0 && (o = o.clone(), o.channel = n.texCoord), r.extensions[Et.KHR_TEXTURE_TRANSFORM]) {
          const a = n.extensions !== void 0 ? n.extensions[Et.KHR_TEXTURE_TRANSFORM] : void 0;
          if (a) {
            const l = r.associations.get(o);
            o = r.extensions[Et.KHR_TEXTURE_TRANSFORM].extendTexture(o, a), r.associations.set(o, l);
          }
        }
        return i !== void 0 && (o.colorSpace = i), e[t] = o, o;
      });
    }
    assignFinalMaterial(e) {
      const t = e.geometry;
      let n = e.material;
      const i = t.attributes.tangent === void 0, r = t.attributes.color !== void 0, o = t.attributes.normal === void 0;
      if (e.isPoints) {
        const a = "PointsMaterial:" + n.uuid;
        let l = this.cache.get(a);
        l || (l = new Nf(), ji.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, l.sizeAttenuation = false, this.cache.add(a, l)), n = l;
      } else if (e.isLine) {
        const a = "LineBasicMaterial:" + n.uuid;
        let l = this.cache.get(a);
        l || (l = new ig(), ji.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, this.cache.add(a, l)), n = l;
      }
      if (i || r || o) {
        let a = "ClonedMaterial:" + n.uuid + ":";
        i && (a += "derivative-tangents:"), r && (a += "vertex-colors:"), o && (a += "flat-shading:");
        let l = this.cache.get(a);
        l || (l = n.clone(), r && (l.vertexColors = true), o && (l.flatShading = true), i && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(a, l), this.associations.set(l, this.associations.get(n))), n = l;
      }
      e.material = n;
    }
    getMaterialType() {
      return Yo;
    }
    loadMaterial(e) {
      const t = this, n = this.json, i = this.extensions, r = n.materials[e];
      let o;
      const a = {}, l = r.extensions || {}, c = [];
      if (l[Et.KHR_MATERIALS_UNLIT]) {
        const f = i[Et.KHR_MATERIALS_UNLIT];
        o = f.getMaterialType(), c.push(f.extendParams(a, r, t));
      } else {
        const f = r.pbrMetallicRoughness || {};
        if (a.color = new it(1, 1, 1), a.opacity = 1, Array.isArray(f.baseColorFactor)) {
          const m = f.baseColorFactor;
          a.color.setRGB(m[0], m[1], m[2], $n), a.opacity = m[3];
        }
        f.baseColorTexture !== void 0 && c.push(t.assignTexture(a, "map", f.baseColorTexture, Dn)), a.metalness = f.metallicFactor !== void 0 ? f.metallicFactor : 1, a.roughness = f.roughnessFactor !== void 0 ? f.roughnessFactor : 1, f.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(a, "metalnessMap", f.metallicRoughnessTexture)), c.push(t.assignTexture(a, "roughnessMap", f.metallicRoughnessTexture))), o = this._invokeOne(function(m) {
          return m.getMaterialType && m.getMaterialType(e);
        }), c.push(Promise.all(this._invokeAll(function(m) {
          return m.extendMaterialParams && m.extendMaterialParams(e, a);
        })));
      }
      r.doubleSided === true && (a.side = Wi);
      const h = r.alphaMode || Xu.OPAQUE;
      if (h === Xu.BLEND ? (a.transparent = true, a.depthWrite = false) : (a.transparent = false, h === Xu.MASK && (a.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : 0.5)), r.normalTexture !== void 0 && o !== qi && (c.push(t.assignTexture(a, "normalMap", r.normalTexture)), a.normalScale = new Se(1, 1), r.normalTexture.scale !== void 0)) {
        const f = r.normalTexture.scale;
        a.normalScale.set(f, f);
      }
      if (r.occlusionTexture !== void 0 && o !== qi && (c.push(t.assignTexture(a, "aoMap", r.occlusionTexture)), r.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = r.occlusionTexture.strength)), r.emissiveFactor !== void 0 && o !== qi) {
        const f = r.emissiveFactor;
        a.emissive = new it().setRGB(f[0], f[1], f[2], $n);
      }
      return r.emissiveTexture !== void 0 && o !== qi && c.push(t.assignTexture(a, "emissiveMap", r.emissiveTexture, Dn)), Promise.all(c).then(function() {
        const f = new o(a);
        return r.name && (f.name = r.name), _r(f, r), t.associations.set(f, {
          materials: e
        }), r.extensions && _s(i, f, r), f;
      });
    }
    createUniqueName(e) {
      const t = Yt.sanitizeNodeName(e || "");
      return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
    }
    loadGeometries(e) {
      const t = this, n = this.extensions, i = this.primitiveCache;
      function r(a) {
        return n[Et.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function(l) {
          return Qp(l, a, t);
        });
      }
      const o = [];
      for (let a = 0, l = e.length; a < l; a++) {
        const c = e[a], h = CE(c), f = i[h];
        if (f) o.push(f.promise);
        else {
          let m;
          c.extensions && c.extensions[Et.KHR_DRACO_MESH_COMPRESSION] ? m = r(c) : m = Qp(new si(), c, t), i[h] = {
            primitive: c,
            promise: m
          }, o.push(m);
        }
      }
      return Promise.all(o);
    }
    loadMesh(e) {
      const t = this, n = this.json, i = this.extensions, r = n.meshes[e], o = r.primitives, a = [];
      for (let l = 0, c = o.length; l < c; l++) {
        const h = o[l].material === void 0 ? EE(this.cache) : this.getDependency("material", o[l].material);
        a.push(h);
      }
      return a.push(t.loadGeometries(o)), Promise.all(a).then(function(l) {
        const c = l.slice(0, l.length - 1), h = l[l.length - 1], f = [];
        for (let _ = 0, y = h.length; _ < y; _++) {
          const g = h[_], x = o[_];
          let v;
          const E = c[_];
          if (x.mode === Mi.TRIANGLES || x.mode === Mi.TRIANGLE_STRIP || x.mode === Mi.TRIANGLE_FAN || x.mode === void 0) v = r.isSkinnedMesh === true ? new Kv(g, E) : new hn(g, E), v.isSkinnedMesh === true && v.normalizeSkinWeights(), x.mode === Mi.TRIANGLE_STRIP ? v.geometry = $p(v.geometry, Gm) : x.mode === Mi.TRIANGLE_FAN && (v.geometry = $p(v.geometry, Gh));
          else if (x.mode === Mi.LINES) v = new ny(g, E);
          else if (x.mode === Mi.LINE_STRIP) v = new If(g, E);
          else if (x.mode === Mi.LINE_LOOP) v = new iy(g, E);
          else if (x.mode === Mi.POINTS) v = new rg(g, E);
          else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + x.mode);
          Object.keys(v.geometry.morphAttributes).length > 0 && AE(v, r), v.name = t.createUniqueName(r.name || "mesh_" + e), _r(v, r), x.extensions && _s(i, v, x), t.assignFinalMaterial(v), f.push(v);
        }
        for (let _ = 0, y = f.length; _ < y; _++) t.associations.set(f[_], {
          meshes: e,
          primitives: _
        });
        if (f.length === 1) return r.extensions && _s(i, f[0], r), f[0];
        const m = new jr();
        r.extensions && _s(i, m, r), t.associations.set(m, {
          meshes: e
        });
        for (let _ = 0, y = f.length; _ < y; _++) m.add(f[_]);
        return m;
      });
    }
    loadCamera(e) {
      let t;
      const n = this.json.cameras[e], i = n[n.type];
      if (!i) {
        console.warn("THREE.GLTFLoader: Missing camera parameters.");
        return;
      }
      return n.type === "perspective" ? t = new Xn(yv.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : n.type === "orthographic" && (t = new Hc(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (t.name = this.createUniqueName(n.name)), _r(t, n), Promise.resolve(t);
    }
    loadSkin(e) {
      const t = this.json.skins[e], n = [];
      for (let i = 0, r = t.joints.length; i < r; i++) n.push(this._loadNodeShallow(t.joints[i]));
      return t.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function(i) {
        const r = i.pop(), o = i, a = [], l = [];
        for (let c = 0, h = o.length; c < h; c++) {
          const f = o[c];
          if (f) {
            a.push(f);
            const m = new pt();
            r !== null && m.fromArray(r.array, c * 16), l.push(m);
          } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c]);
        }
        return new Df(a, l);
      });
    }
    loadAnimation(e) {
      const t = this.json, n = this, i = t.animations[e], r = i.name ? i.name : "animation_" + e, o = [], a = [], l = [], c = [], h = [];
      for (let f = 0, m = i.channels.length; f < m; f++) {
        const _ = i.channels[f], y = i.samplers[_.sampler], g = _.target, x = g.node, v = i.parameters !== void 0 ? i.parameters[y.input] : y.input, E = i.parameters !== void 0 ? i.parameters[y.output] : y.output;
        g.node !== void 0 && (o.push(this.getDependency("node", x)), a.push(this.getDependency("accessor", v)), l.push(this.getDependency("accessor", E)), c.push(y), h.push(g));
      }
      return Promise.all([
        Promise.all(o),
        Promise.all(a),
        Promise.all(l),
        Promise.all(c),
        Promise.all(h)
      ]).then(function(f) {
        const m = f[0], _ = f[1], y = f[2], g = f[3], x = f[4], v = [];
        for (let E = 0, T = m.length; E < T; E++) {
          const M = m[E], P = _[E], R = y[E], d = g[E], N = x[E];
          if (M === void 0) continue;
          M.updateMatrix && M.updateMatrix();
          const w = n._createAnimationTracks(M, P, R, d, N);
          if (w) for (let D = 0; D < w.length; D++) v.push(w[D]);
        }
        return new Xy(r, void 0, v);
      });
    }
    createNodeMesh(e) {
      const t = this.json, n = this, i = t.nodes[e];
      return i.mesh === void 0 ? null : n.getDependency("mesh", i.mesh).then(function(r) {
        const o = n._getNodeRef(n.meshCache, i.mesh, r);
        return i.weights !== void 0 && o.traverse(function(a) {
          if (a.isMesh) for (let l = 0, c = i.weights.length; l < c; l++) a.morphTargetInfluences[l] = i.weights[l];
        }), o;
      });
    }
    loadNode(e) {
      const t = this.json, n = this, i = t.nodes[e], r = n._loadNodeShallow(e), o = [], a = i.children || [];
      for (let c = 0, h = a.length; c < h; c++) o.push(n.getDependency("node", a[c]));
      const l = i.skin === void 0 ? Promise.resolve(null) : n.getDependency("skin", i.skin);
      return Promise.all([
        r,
        Promise.all(o),
        l
      ]).then(function(c) {
        const h = c[0], f = c[1], m = c[2];
        m !== null && h.traverse(function(_) {
          _.isSkinnedMesh && _.bind(m, PE);
        });
        for (let _ = 0, y = f.length; _ < y; _++) h.add(f[_]);
        return h;
      });
    }
    _loadNodeShallow(e) {
      const t = this.json, n = this.extensions, i = this;
      if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
      const r = t.nodes[e], o = r.name ? i.createUniqueName(r.name) : "", a = [], l = i._invokeOne(function(c) {
        return c.createNodeMesh && c.createNodeMesh(e);
      });
      return l && a.push(l), r.camera !== void 0 && a.push(i.getDependency("camera", r.camera).then(function(c) {
        return i._getNodeRef(i.cameraCache, r.camera, c);
      })), i._invokeAll(function(c) {
        return c.createNodeAttachment && c.createNodeAttachment(e);
      }).forEach(function(c) {
        a.push(c);
      }), this.nodeCache[e] = Promise.all(a).then(function(c) {
        let h;
        if (r.isBone === true ? h = new tg() : c.length > 1 ? h = new jr() : c.length === 1 ? h = c[0] : h = new on(), h !== c[0]) for (let f = 0, m = c.length; f < m; f++) h.add(c[f]);
        if (r.name && (h.userData.name = r.name, h.name = o), _r(h, r), r.extensions && _s(n, h, r), r.matrix !== void 0) {
          const f = new pt();
          f.fromArray(r.matrix), h.applyMatrix4(f);
        } else r.translation !== void 0 && h.position.fromArray(r.translation), r.rotation !== void 0 && h.quaternion.fromArray(r.rotation), r.scale !== void 0 && h.scale.fromArray(r.scale);
        return i.associations.has(h) || i.associations.set(h, {}), i.associations.get(h).nodes = e, h;
      }), this.nodeCache[e];
    }
    loadScene(e) {
      const t = this.extensions, n = this.json.scenes[e], i = this, r = new jr();
      n.name && (r.name = i.createUniqueName(n.name)), _r(r, n), n.extensions && _s(t, r, n);
      const o = n.nodes || [], a = [];
      for (let l = 0, c = o.length; l < c; l++) a.push(i.getDependency("node", o[l]));
      return Promise.all(a).then(function(l) {
        for (let h = 0, f = l.length; h < f; h++) r.add(l[h]);
        const c = (h) => {
          const f = /* @__PURE__ */ new Map();
          for (const [m, _] of i.associations) (m instanceof ji || m instanceof Mn) && f.set(m, _);
          return h.traverse((m) => {
            const _ = i.associations.get(m);
            _ != null && f.set(m, _);
          }), f;
        };
        return i.associations = c(r), r;
      });
    }
    _createAnimationTracks(e, t, n, i, r) {
      const o = [], a = e.name ? e.name : e.uuid, l = [];
      Vr[r.path] === Vr.weights ? e.traverse(function(m) {
        m.morphTargetInfluences && l.push(m.name ? m.name : m.uuid);
      }) : l.push(a);
      let c;
      switch (Vr[r.path]) {
        case Vr.weights:
          c = Uo;
          break;
        case Vr.rotation:
          c = Oo;
          break;
        case Vr.position:
        case Vr.scale:
          c = Fo;
          break;
        default:
          switch (n.itemSize) {
            case 1:
              c = Uo;
              break;
            case 2:
            case 3:
            default:
              c = Fo;
              break;
          }
          break;
      }
      const h = i.interpolation !== void 0 ? TE[i.interpolation] : Ka, f = this._getArrayFromAccessor(n);
      for (let m = 0, _ = l.length; m < _; m++) {
        const y = new c(l[m] + "." + Vr[r.path], t.array, f, h);
        i.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(y), o.push(y);
      }
      return o;
    }
    _getArrayFromAccessor(e) {
      let t = e.array;
      if (e.normalized) {
        const n = ef(t.constructor), i = new Float32Array(t.length);
        for (let r = 0, o = t.length; r < o; r++) i[r] = t[r] * n;
        t = i;
      }
      return t;
    }
    _createCubicSplineTrackInterpolant(e) {
      e.createInterpolant = function(n) {
        const i = this instanceof Oo ? ME : Mg;
        return new i(this.times, this.values, this.getValueSize() / 3, n);
      }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
    }
  }
  function LE(s, e, t) {
    const n = e.attributes, i = new Rr();
    if (n.POSITION !== void 0) {
      const a = t.json.accessors[n.POSITION], l = a.min, c = a.max;
      if (l !== void 0 && c !== void 0) {
        if (i.set(new V(l[0], l[1], l[2]), new V(c[0], c[1], c[2])), a.normalized) {
          const h = ef(Mo[a.componentType]);
          i.min.multiplyScalar(h), i.max.multiplyScalar(h);
        }
      } else {
        console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        return;
      }
    } else return;
    const r = e.targets;
    if (r !== void 0) {
      const a = new V(), l = new V();
      for (let c = 0, h = r.length; c < h; c++) {
        const f = r[c];
        if (f.POSITION !== void 0) {
          const m = t.json.accessors[f.POSITION], _ = m.min, y = m.max;
          if (_ !== void 0 && y !== void 0) {
            if (l.setX(Math.max(Math.abs(_[0]), Math.abs(y[0]))), l.setY(Math.max(Math.abs(_[1]), Math.abs(y[1]))), l.setZ(Math.max(Math.abs(_[2]), Math.abs(y[2]))), m.normalized) {
              const g = ef(Mo[m.componentType]);
              l.multiplyScalar(g);
            }
            a.max(l);
          } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }
      i.expandByVector(a);
    }
    s.boundingBox = i;
    const o = new Qi();
    i.getCenter(o.center), o.radius = i.min.distanceTo(i.max) / 2, s.boundingSphere = o;
  }
  function Qp(s, e, t) {
    const n = e.attributes, i = [];
    function r(o, a) {
      return t.getDependency("accessor", o).then(function(l) {
        s.setAttribute(a, l);
      });
    }
    for (const o in n) {
      const a = Qh[o] || o.toLowerCase();
      a in s.attributes || i.push(r(n[o], a));
    }
    if (e.indices !== void 0 && !s.index) {
      const o = t.getDependency("accessor", e.indices).then(function(a) {
        s.setIndex(a);
      });
      i.push(o);
    }
    return It.workingColorSpace !== $n && "COLOR_0" in n && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${It.workingColorSpace}" not supported.`), _r(s, e), LE(s, e, t), Promise.all(i).then(function() {
      return e.targets !== void 0 ? wE(s, e.targets, t) : s;
    });
  }
  class Xf extends Bs {
    constructor(e) {
      super(e);
    }
    load(e, t, n, i) {
      const r = this, o = new Bf(this.manager);
      o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(a) {
        const l = r.parse(JSON.parse(a));
        t && t(l);
      }, n, i);
    }
    parse(e) {
      return new IE(e);
    }
  }
  class IE {
    constructor(e) {
      this.isFont = true, this.type = "Font", this.data = e;
    }
    generateShapes(e, t = 100) {
      const n = [], i = NE(e, t, this.data);
      for (let r = 0, o = i.length; r < o; r++) n.push(...i[r].toShapes());
      return n;
    }
  }
  function NE(s, e, t) {
    const n = Array.from(s), i = e / t.resolution, r = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * i, o = [];
    let a = 0, l = 0;
    for (let c = 0; c < n.length; c++) {
      const h = n[c];
      if (h === `
`) a = 0, l -= r;
      else {
        const f = UE(h, i, a, l, t);
        a += f.offsetX, o.push(f.path);
      }
    }
    return o;
  }
  function UE(s, e, t, n, i) {
    const r = i.glyphs[s] || i.glyphs["?"];
    if (!r) {
      console.error('THREE.Font: character "' + s + '" does not exists in font family ' + i.familyName + ".");
      return;
    }
    const o = new mx();
    let a, l, c, h, f, m, _, y;
    if (r.o) {
      const g = r._cachedOutline || (r._cachedOutline = r.o.split(" "));
      for (let x = 0, v = g.length; x < v; ) switch (g[x++]) {
        case "m":
          a = g[x++] * e + t, l = g[x++] * e + n, o.moveTo(a, l);
          break;
        case "l":
          a = g[x++] * e + t, l = g[x++] * e + n, o.lineTo(a, l);
          break;
        case "q":
          c = g[x++] * e + t, h = g[x++] * e + n, f = g[x++] * e + t, m = g[x++] * e + n, o.quadraticCurveTo(f, m, c, h);
          break;
        case "b":
          c = g[x++] * e + t, h = g[x++] * e + n, f = g[x++] * e + t, m = g[x++] * e + n, _ = g[x++] * e + t, y = g[x++] * e + n, o.bezierCurveTo(f, m, _, y, c, h);
          break;
      }
    }
    return {
      offsetX: r.ha * e,
      path: o
    };
  }
  class qf extends Ff {
    constructor(e, t = {}) {
      const n = t.font;
      if (n === void 0) super();
      else {
        const i = n.generateShapes(e, t.size);
        t.depth === void 0 && (t.depth = 50), t.bevelThickness === void 0 && (t.bevelThickness = 10), t.bevelSize === void 0 && (t.bevelSize = 8), t.bevelEnabled === void 0 && (t.bevelEnabled = false), super(i, t);
      }
      this.type = "TextGeometry";
    }
  }
  function vr(s) {
    if (s === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return s;
  }
  function Tg(s, e) {
    s.prototype = Object.create(e.prototype), s.prototype.constructor = s, s.__proto__ = e;
  }
  var pi = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
      lineHeight: ""
    }
  }, ko = {
    duration: 0.5,
    overwrite: false,
    delay: 0
  }, Yf, In, en, $i = 1e8, Bn = 1 / $i, tf = Math.PI * 2, OE = tf / 4, FE = 0, Eg = Math.sqrt, kE = Math.cos, BE = Math.sin, Rn = function(e) {
    return typeof e == "string";
  }, ln = function(e) {
    return typeof e == "function";
  }, Ar = function(e) {
    return typeof e == "number";
  }, jf = function(e) {
    return typeof e > "u";
  }, Ji = function(e) {
    return typeof e == "object";
  }, ei = function(e) {
    return e !== false;
  }, $f = function() {
    return typeof window < "u";
  }, nc = function(e) {
    return ln(e) || Rn(e);
  }, wg = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {
  }, zn = Array.isArray, nf = /(?:-?\.?\d|\.)+/gi, Ag = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, _o = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, Yu = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, Cg = /[+-]=-?[.\d]+/, Rg = /[^,'"\[\]\s]+/gi, zE = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, nn, Vi, rf, Kf, mi = {}, Ac = {}, Pg, Dg = function(e) {
    return (Ac = Bo(e, mi)) && ri;
  }, Zf = function(e, t) {
    return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()");
  }, tl = function(e, t) {
    return !t && console.warn(e);
  }, Lg = function(e, t) {
    return e && (mi[e] = t) && Ac && (Ac[e] = t) || mi;
  }, nl = function() {
    return 0;
  }, HE = {
    suppressEvents: true,
    isStart: true,
    kill: false
  }, dc = {
    suppressEvents: true,
    kill: false
  }, VE = {
    suppressEvents: true
  }, Jf = {}, es = [], sf = {}, Ig, ui = {}, ju = {}, em = 30, pc = [], Qf = "", ed = function(e) {
    var t = e[0], n, i;
    if (Ji(t) || ln(t) || (e = [
      e
    ]), !(n = (t._gsap || {}).harness)) {
      for (i = pc.length; i-- && !pc[i].targetTest(t); ) ;
      n = pc[i];
    }
    for (i = e.length; i--; ) e[i] && (e[i]._gsap || (e[i]._gsap = new i_(e[i], n))) || e.splice(i, 1);
    return e;
  }, Ps = function(e) {
    return e._gsap || ed(Ei(e))[0]._gsap;
  }, Ng = function(e, t, n) {
    return (n = e[t]) && ln(n) ? e[t]() : jf(n) && e.getAttribute && e.getAttribute(t) || n;
  }, ti = function(e, t) {
    return (e = e.split(",")).forEach(t) || e;
  }, cn = function(e) {
    return Math.round(e * 1e5) / 1e5 || 0;
  }, yn = function(e) {
    return Math.round(e * 1e7) / 1e7 || 0;
  }, To = function(e, t) {
    var n = t.charAt(0), i = parseFloat(t.substr(2));
    return e = parseFloat(e), n === "+" ? e + i : n === "-" ? e - i : n === "*" ? e * i : e / i;
  }, GE = function(e, t) {
    for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n; ) ;
    return i < n;
  }, Cc = function() {
    var e = es.length, t = es.slice(0), n, i;
    for (sf = {}, es.length = 0, n = 0; n < e; n++) i = t[n], i && i._lazy && (i.render(i._lazy[0], i._lazy[1], true)._lazy = 0);
  }, Ug = function(e, t, n, i) {
    es.length && !In && Cc(), e.render(t, n, In && t < 0 && (e._initted || e._startAt)), es.length && !In && Cc();
  }, Og = function(e) {
    var t = parseFloat(e);
    return (t || t === 0) && (e + "").match(Rg).length < 2 ? t : Rn(e) ? e.trim() : e;
  }, Fg = function(e) {
    return e;
  }, gi = function(e, t) {
    for (var n in t) n in e || (e[n] = t[n]);
    return e;
  }, WE = function(e) {
    return function(t, n) {
      for (var i in n) i in t || i === "duration" && e || i === "ease" || (t[i] = n[i]);
    };
  }, Bo = function(e, t) {
    for (var n in t) e[n] = t[n];
    return e;
  }, tm = function s(e, t) {
    for (var n in t) n !== "__proto__" && n !== "constructor" && n !== "prototype" && (e[n] = Ji(t[n]) ? s(e[n] || (e[n] = {}), t[n]) : t[n]);
    return e;
  }, Rc = function(e, t) {
    var n = {}, i;
    for (i in e) i in t || (n[i] = e[i]);
    return n;
  }, Va = function(e) {
    var t = e.parent || nn, n = e.keyframes ? WE(zn(e.keyframes)) : gi;
    if (ei(e.inherit)) for (; t; ) n(e, t.vars.defaults), t = t.parent || t._dp;
    return e;
  }, XE = function(e, t) {
    for (var n = e.length, i = n === t.length; i && n-- && e[n] === t[n]; ) ;
    return n < 0;
  }, kg = function(e, t, n, i, r) {
    var o = e[i], a;
    if (r) for (a = t[r]; o && o[r] > a; ) o = o._prev;
    return o ? (t._next = o._next, o._next = t) : (t._next = e[n], e[n] = t), t._next ? t._next._prev = t : e[i] = t, t._prev = o, t.parent = t._dp = e, t;
  }, Gc = function(e, t, n, i) {
    n === void 0 && (n = "_first"), i === void 0 && (i = "_last");
    var r = t._prev, o = t._next;
    r ? r._next = o : e[n] === t && (e[n] = o), o ? o._prev = r : e[i] === t && (e[i] = r), t._next = t._prev = t.parent = null;
  }, ns = function(e, t) {
    e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e), e._act = 0;
  }, Ds = function(e, t) {
    if (e && (!t || t._end > e._dur || t._start < 0)) for (var n = e; n; ) n._dirty = 1, n = n.parent;
    return e;
  }, qE = function(e) {
    for (var t = e.parent; t && t.parent; ) t._dirty = 1, t.totalDuration(), t = t.parent;
    return e;
  }, of = function(e, t, n, i) {
    return e._startAt && (In ? e._startAt.revert(dc) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, true, i));
  }, YE = function s(e) {
    return !e || e._ts && s(e.parent);
  }, nm = function(e) {
    return e._repeat ? zo(e._tTime, e = e.duration() + e._rDelay) * e : 0;
  }, zo = function(e, t) {
    var n = Math.floor(e = yn(e / t));
    return e && n === e ? n - 1 : n;
  }, Pc = function(e, t) {
    return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur);
  }, Wc = function(e) {
    return e._end = yn(e._start + (e._tDur / Math.abs(e._ts || e._rts || Bn) || 0));
  }, Xc = function(e, t) {
    var n = e._dp;
    return n && n.smoothChildTiming && e._ts && (e._start = yn(n._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), Wc(e), n._dirty || Ds(n, e)), e;
  }, Bg = function(e, t) {
    var n;
    if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (n = Pc(e.rawTime(), t), (!t._dur || dl(0, t.totalDuration(), n) - t._tTime > Bn) && t.render(n, true)), Ds(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
      if (e._dur < e.duration()) for (n = e; n._dp; ) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
      e._zTime = -1e-8;
    }
  }, Xi = function(e, t, n, i) {
    return t.parent && ns(t), t._start = yn((Ar(n) ? n : n || e !== nn ? Si(e, n, t) : e._time) + t._delay), t._end = yn(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), kg(e, t, "_first", "_last", e._sort ? "_start" : 0), af(t) || (e._recent = t), i || Bg(e, t), e._ts < 0 && Xc(e, e._tTime), e;
  }, zg = function(e, t) {
    return (mi.ScrollTrigger || Zf("scrollTrigger", t)) && mi.ScrollTrigger.create(t, e);
  }, Hg = function(e, t, n, i, r) {
    if (nd(e, t, r), !e._initted) return 1;
    if (!n && e._pt && !In && (e._dur && e.vars.lazy !== false || !e._dur && e.vars.lazy) && Ig !== hi.frame) return es.push(e), e._lazy = [
      r,
      i
    ], 1;
  }, jE = function s(e) {
    var t = e.parent;
    return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || s(t));
  }, af = function(e) {
    var t = e.data;
    return t === "isFromStart" || t === "isStart";
  }, $E = function(e, t, n, i) {
    var r = e.ratio, o = t < 0 || !t && (!e._start && jE(e) && !(!e._initted && af(e)) || (e._ts < 0 || e._dp._ts < 0) && !af(e)) ? 0 : 1, a = e._rDelay, l = 0, c, h, f;
    if (a && e._repeat && (l = dl(0, e._tDur, t), h = zo(l, a), e._yoyo && h & 1 && (o = 1 - o), h !== zo(e._tTime, a) && (r = 1 - o, e.vars.repeatRefresh && e._initted && e.invalidate())), o !== r || In || i || e._zTime === Bn || !t && e._zTime) {
      if (!e._initted && Hg(e, t, i, n, l)) return;
      for (f = e._zTime, e._zTime = t || (n ? Bn : 0), n || (n = t && !f), e.ratio = o, e._from && (o = 1 - o), e._time = 0, e._tTime = l, c = e._pt; c; ) c.r(o, c.d), c = c._next;
      t < 0 && of(e, t, n, true), e._onUpdate && !n && di(e, "onUpdate"), l && e._repeat && !n && e.parent && di(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === o && (o && ns(e, 1), !n && !In && (di(e, o ? "onComplete" : "onReverseComplete", true), e._prom && e._prom()));
    } else e._zTime || (e._zTime = t);
  }, KE = function(e, t, n) {
    var i;
    if (n > t) for (i = e._first; i && i._start <= n; ) {
      if (i.data === "isPause" && i._start > t) return i;
      i = i._next;
    }
    else for (i = e._last; i && i._start >= n; ) {
      if (i.data === "isPause" && i._start < t) return i;
      i = i._prev;
    }
  }, Ho = function(e, t, n, i) {
    var r = e._repeat, o = yn(t) || 0, a = e._tTime / e._tDur;
    return a && !i && (e._time *= o / e._dur), e._dur = o, e._tDur = r ? r < 0 ? 1e10 : yn(o * (r + 1) + e._rDelay * r) : o, a > 0 && !i && Xc(e, e._tTime = e._tDur * a), e.parent && Wc(e), n || Ds(e.parent, e), e;
  }, im = function(e) {
    return e instanceof qn ? Ds(e) : Ho(e, e._dur);
  }, ZE = {
    _start: 0,
    endTime: nl,
    totalDuration: nl
  }, Si = function s(e, t, n) {
    var i = e.labels, r = e._recent || ZE, o = e.duration() >= $i ? r.endTime(false) : e._dur, a, l, c;
    return Rn(t) && (isNaN(t) || t in i) ? (l = t.charAt(0), c = t.substr(-1) === "%", a = t.indexOf("="), l === "<" || l === ">" ? (a >= 0 && (t = t.replace(/=/, "")), (l === "<" ? r._start : r.endTime(r._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (c ? (a < 0 ? r : n).totalDuration() / 100 : 1)) : a < 0 ? (t in i || (i[t] = o), i[t]) : (l = parseFloat(t.charAt(a - 1) + t.substr(a + 1)), c && n && (l = l / 100 * (zn(n) ? n[0] : n).totalDuration()), a > 1 ? s(e, t.substr(0, a - 1), n) + l : o + l)) : t == null ? o : +t;
  }, Ga = function(e, t, n) {
    var i = Ar(t[1]), r = (i ? 2 : 1) + (e < 2 ? 0 : 1), o = t[r], a, l;
    if (i && (o.duration = t[1]), o.parent = n, e) {
      for (a = o, l = n; l && !("immediateRender" in a); ) a = l.vars.defaults || {}, l = ei(l.vars.inherit) && l.parent;
      o.immediateRender = ei(a.immediateRender), e < 2 ? o.runBackwards = 1 : o.startAt = t[r - 1];
    }
    return new vn(t[0], o, t[r + 1]);
  }, ss = function(e, t) {
    return e || e === 0 ? t(e) : t;
  }, dl = function(e, t, n) {
    return n < e ? e : n > t ? t : n;
  }, Fn = function(e, t) {
    return !Rn(e) || !(t = zE.exec(e)) ? "" : t[1];
  }, JE = function(e, t, n) {
    return ss(n, function(i) {
      return dl(e, t, i);
    });
  }, lf = [].slice, Vg = function(e, t) {
    return e && Ji(e) && "length" in e && (!t && !e.length || e.length - 1 in e && Ji(e[0])) && !e.nodeType && e !== Vi;
  }, QE = function(e, t, n) {
    return n === void 0 && (n = []), e.forEach(function(i) {
      var r;
      return Rn(i) && !t || Vg(i, 1) ? (r = n).push.apply(r, Ei(i)) : n.push(i);
    }) || n;
  }, Ei = function(e, t, n) {
    return en && !t && en.selector ? en.selector(e) : Rn(e) && !n && (rf || !Vo()) ? lf.call((t || Kf).querySelectorAll(e), 0) : zn(e) ? QE(e, n) : Vg(e) ? lf.call(e, 0) : e ? [
      e
    ] : [];
  }, cf = function(e) {
    return e = Ei(e)[0] || tl("Invalid scope") || {}, function(t) {
      var n = e.current || e.nativeElement || e;
      return Ei(t, n.querySelectorAll ? n : n === e ? tl("Invalid scope") || Kf.createElement("div") : e);
    };
  }, Gg = function(e) {
    return e.sort(function() {
      return 0.5 - Math.random();
    });
  }, Wg = function(e) {
    if (ln(e)) return e;
    var t = Ji(e) ? e : {
      each: e
    }, n = Ls(t.ease), i = t.from || 0, r = parseFloat(t.base) || 0, o = {}, a = i > 0 && i < 1, l = isNaN(i) || a, c = t.axis, h = i, f = i;
    return Rn(i) ? h = f = {
      center: 0.5,
      edges: 0.5,
      end: 1
    }[i] || 0 : !a && l && (h = i[0], f = i[1]), function(m, _, y) {
      var g = (y || t).length, x = o[g], v, E, T, M, P, R, d, N, w;
      if (!x) {
        if (w = t.grid === "auto" ? 0 : (t.grid || [
          1,
          $i
        ])[1], !w) {
          for (d = -1e8; d < (d = y[w++].getBoundingClientRect().left) && w < g; ) ;
          w < g && w--;
        }
        for (x = o[g] = [], v = l ? Math.min(w, g) * h - 0.5 : i % w, E = w === $i ? 0 : l ? g * f / w - 0.5 : i / w | 0, d = 0, N = $i, R = 0; R < g; R++) T = R % w - v, M = E - (R / w | 0), x[R] = P = c ? Math.abs(c === "y" ? M : T) : Eg(T * T + M * M), P > d && (d = P), P < N && (N = P);
        i === "random" && Gg(x), x.max = d - N, x.min = N, x.v = g = (parseFloat(t.amount) || parseFloat(t.each) * (w > g ? g - 1 : c ? c === "y" ? g / w : w : Math.max(w, g / w)) || 0) * (i === "edges" ? -1 : 1), x.b = g < 0 ? r - g : r, x.u = Fn(t.amount || t.each) || 0, n = n && g < 0 ? e_(n) : n;
      }
      return g = (x[m] - x.min) / x.max || 0, yn(x.b + (n ? n(g) : g) * x.v) + x.u;
    };
  }, uf = function(e) {
    var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
    return function(n) {
      var i = yn(Math.round(parseFloat(n) / e) * e * t);
      return (i - i % 1) / t + (Ar(n) ? 0 : Fn(n));
    };
  }, Xg = function(e, t) {
    var n = zn(e), i, r;
    return !n && Ji(e) && (i = n = e.radius || $i, e.values ? (e = Ei(e.values), (r = !Ar(e[0])) && (i *= i)) : e = uf(e.increment)), ss(t, n ? ln(e) ? function(o) {
      return r = e(o), Math.abs(r - o) <= i ? r : o;
    } : function(o) {
      for (var a = parseFloat(r ? o.x : o), l = parseFloat(r ? o.y : 0), c = $i, h = 0, f = e.length, m, _; f--; ) r ? (m = e[f].x - a, _ = e[f].y - l, m = m * m + _ * _) : m = Math.abs(e[f] - a), m < c && (c = m, h = f);
      return h = !i || c <= i ? e[h] : o, r || h === o || Ar(o) ? h : h + Fn(o);
    } : uf(e));
  }, qg = function(e, t, n, i) {
    return ss(zn(e) ? !t : n === true ? !!(n = 0) : !i, function() {
      return zn(e) ? e[~~(Math.random() * e.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + n * 0.99)) / n) * n * i) / i;
    });
  }, ew = function() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
    return function(i) {
      return t.reduce(function(r, o) {
        return o(r);
      }, i);
    };
  }, tw = function(e, t) {
    return function(n) {
      return e(parseFloat(n)) + (t || Fn(n));
    };
  }, nw = function(e, t, n) {
    return jg(e, t, 0, 1, n);
  }, Yg = function(e, t, n) {
    return ss(n, function(i) {
      return e[~~t(i)];
    });
  }, iw = function s(e, t, n) {
    var i = t - e;
    return zn(e) ? Yg(e, s(0, e.length), t) : ss(n, function(r) {
      return (i + (r - e) % i) % i + e;
    });
  }, rw = function s(e, t, n) {
    var i = t - e, r = i * 2;
    return zn(e) ? Yg(e, s(0, e.length - 1), t) : ss(n, function(o) {
      return o = (r + (o - e) % r) % r || 0, e + (o > i ? r - o : o);
    });
  }, il = function(e) {
    for (var t = 0, n = "", i, r, o, a; ~(i = e.indexOf("random(", t)); ) o = e.indexOf(")", i), a = e.charAt(i + 7) === "[", r = e.substr(i + 7, o - i - 7).match(a ? Rg : nf), n += e.substr(t, i - t) + qg(a ? r : +r[0], a ? 0 : +r[1], +r[2] || 1e-5), t = o + 1;
    return n + e.substr(t, e.length - t);
  }, jg = function(e, t, n, i, r) {
    var o = t - e, a = i - n;
    return ss(r, function(l) {
      return n + ((l - e) / o * a || 0);
    });
  }, sw = function s(e, t, n, i) {
    var r = isNaN(e + t) ? 0 : function(_) {
      return (1 - _) * e + _ * t;
    };
    if (!r) {
      var o = Rn(e), a = {}, l, c, h, f, m;
      if (n === true && (i = 1) && (n = null), o) e = {
        p: e
      }, t = {
        p: t
      };
      else if (zn(e) && !zn(t)) {
        for (h = [], f = e.length, m = f - 2, c = 1; c < f; c++) h.push(s(e[c - 1], e[c]));
        f--, r = function(y) {
          y *= f;
          var g = Math.min(m, ~~y);
          return h[g](y - g);
        }, n = t;
      } else i || (e = Bo(zn(e) ? [] : {}, e));
      if (!h) {
        for (l in t) td.call(a, e, l, "get", t[l]);
        r = function(y) {
          return sd(y, a) || (o ? e.p : e);
        };
      }
    }
    return ss(n, r);
  }, rm = function(e, t, n) {
    var i = e.labels, r = $i, o, a, l;
    for (o in i) a = i[o] - t, a < 0 == !!n && a && r > (a = Math.abs(a)) && (l = o, r = a);
    return l;
  }, di = function(e, t, n) {
    var i = e.vars, r = i[t], o = en, a = e._ctx, l, c, h;
    if (r) return l = i[t + "Params"], c = i.callbackScope || e, n && es.length && Cc(), a && (en = a), h = l ? r.apply(c, l) : r.call(c), en = o, h;
  }, Ua = function(e) {
    return ns(e), e.scrollTrigger && e.scrollTrigger.kill(!!In), e.progress() < 1 && di(e, "onInterrupt"), e;
  }, vo, $g = [], Kg = function(e) {
    if (e) if (e = !e.name && e.default || e, $f() || e.headless) {
      var t = e.name, n = ln(e), i = t && !n && e.init ? function() {
        this._props = [];
      } : e, r = {
        init: nl,
        render: sd,
        add: td,
        kill: bw,
        modifier: xw,
        rawVars: 0
      }, o = {
        targetTest: 0,
        get: 0,
        getSetter: rd,
        aliases: {},
        register: 0
      };
      if (Vo(), e !== i) {
        if (ui[t]) return;
        gi(i, gi(Rc(e, r), o)), Bo(i.prototype, Bo(r, Rc(e, o))), ui[i.prop = t] = i, e.targetTest && (pc.push(i), Jf[t] = 1), t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin";
      }
      Lg(t, i), e.register && e.register(ri, i, ni);
    } else $g.push(e);
  }, Kt = 255, Oa = {
    aqua: [
      0,
      Kt,
      Kt
    ],
    lime: [
      0,
      Kt,
      0
    ],
    silver: [
      192,
      192,
      192
    ],
    black: [
      0,
      0,
      0
    ],
    maroon: [
      128,
      0,
      0
    ],
    teal: [
      0,
      128,
      128
    ],
    blue: [
      0,
      0,
      Kt
    ],
    navy: [
      0,
      0,
      128
    ],
    white: [
      Kt,
      Kt,
      Kt
    ],
    olive: [
      128,
      128,
      0
    ],
    yellow: [
      Kt,
      Kt,
      0
    ],
    orange: [
      Kt,
      165,
      0
    ],
    gray: [
      128,
      128,
      128
    ],
    purple: [
      128,
      0,
      128
    ],
    green: [
      0,
      128,
      0
    ],
    red: [
      Kt,
      0,
      0
    ],
    pink: [
      Kt,
      192,
      203
    ],
    cyan: [
      0,
      Kt,
      Kt
    ],
    transparent: [
      Kt,
      Kt,
      Kt,
      0
    ]
  }, $u = function(e, t, n) {
    return e += e < 0 ? 1 : e > 1 ? -1 : 0, (e * 6 < 1 ? t + (n - t) * e * 6 : e < 0.5 ? n : e * 3 < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) * Kt + 0.5 | 0;
  }, Zg = function(e, t, n) {
    var i = e ? Ar(e) ? [
      e >> 16,
      e >> 8 & Kt,
      e & Kt
    ] : 0 : Oa.black, r, o, a, l, c, h, f, m, _, y;
    if (!i) {
      if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), Oa[e]) i = Oa[e];
      else if (e.charAt(0) === "#") {
        if (e.length < 6 && (r = e.charAt(1), o = e.charAt(2), a = e.charAt(3), e = "#" + r + r + o + o + a + a + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")), e.length === 9) return i = parseInt(e.substr(1, 6), 16), [
          i >> 16,
          i >> 8 & Kt,
          i & Kt,
          parseInt(e.substr(7), 16) / 255
        ];
        e = parseInt(e.substr(1), 16), i = [
          e >> 16,
          e >> 8 & Kt,
          e & Kt
        ];
      } else if (e.substr(0, 3) === "hsl") {
        if (i = y = e.match(nf), !t) l = +i[0] % 360 / 360, c = +i[1] / 100, h = +i[2] / 100, o = h <= 0.5 ? h * (c + 1) : h + c - h * c, r = h * 2 - o, i.length > 3 && (i[3] *= 1), i[0] = $u(l + 1 / 3, r, o), i[1] = $u(l, r, o), i[2] = $u(l - 1 / 3, r, o);
        else if (~e.indexOf("=")) return i = e.match(Ag), n && i.length < 4 && (i[3] = 1), i;
      } else i = e.match(nf) || Oa.transparent;
      i = i.map(Number);
    }
    return t && !y && (r = i[0] / Kt, o = i[1] / Kt, a = i[2] / Kt, f = Math.max(r, o, a), m = Math.min(r, o, a), h = (f + m) / 2, f === m ? l = c = 0 : (_ = f - m, c = h > 0.5 ? _ / (2 - f - m) : _ / (f + m), l = f === r ? (o - a) / _ + (o < a ? 6 : 0) : f === o ? (a - r) / _ + 2 : (r - o) / _ + 4, l *= 60), i[0] = ~~(l + 0.5), i[1] = ~~(c * 100 + 0.5), i[2] = ~~(h * 100 + 0.5)), n && i.length < 4 && (i[3] = 1), i;
  }, Jg = function(e) {
    var t = [], n = [], i = -1;
    return e.split(ts).forEach(function(r) {
      var o = r.match(_o) || [];
      t.push.apply(t, o), n.push(i += o.length + 1);
    }), t.c = n, t;
  }, sm = function(e, t, n) {
    var i = "", r = (e + i).match(ts), o = t ? "hsla(" : "rgba(", a = 0, l, c, h, f;
    if (!r) return e;
    if (r = r.map(function(m) {
      return (m = Zg(m, t, 1)) && o + (t ? m[0] + "," + m[1] + "%," + m[2] + "%," + m[3] : m.join(",")) + ")";
    }), n && (h = Jg(e), l = n.c, l.join(i) !== h.c.join(i))) for (c = e.replace(ts, "1").split(_o), f = c.length - 1; a < f; a++) i += c[a] + (~l.indexOf(a) ? r.shift() || o + "0,0,0,0)" : (h.length ? h : r.length ? r : n).shift());
    if (!c) for (c = e.split(ts), f = c.length - 1; a < f; a++) i += c[a] + r[a];
    return i + c[f];
  }, ts = function() {
    var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", e;
    for (e in Oa) s += "|" + e + "\\b";
    return new RegExp(s + ")", "gi");
  }(), ow = /hsl[a]?\(/, Qg = function(e) {
    var t = e.join(" "), n;
    if (ts.lastIndex = 0, ts.test(t)) return n = ow.test(t), e[1] = sm(e[1], n), e[0] = sm(e[0], n, Jg(e[1])), true;
  }, rl, hi = function() {
    var s = Date.now, e = 500, t = 33, n = s(), i = n, r = 1e3 / 240, o = r, a = [], l, c, h, f, m, _, y = function g(x) {
      var v = s() - i, E = x === true, T, M, P, R;
      if ((v > e || v < 0) && (n += v - t), i += v, P = i - n, T = P - o, (T > 0 || E) && (R = ++f.frame, m = P - f.time * 1e3, f.time = P = P / 1e3, o += T + (T >= r ? 4 : r - T), M = 1), E || (l = c(g)), M) for (_ = 0; _ < a.length; _++) a[_](P, m, R, x);
    };
    return f = {
      time: 0,
      frame: 0,
      tick: function() {
        y(true);
      },
      deltaRatio: function(x) {
        return m / (1e3 / (x || 60));
      },
      wake: function() {
        Pg && (!rf && $f() && (Vi = rf = window, Kf = Vi.document || {}, mi.gsap = ri, (Vi.gsapVersions || (Vi.gsapVersions = [])).push(ri.version), Dg(Ac || Vi.GreenSockGlobals || !Vi.gsap && Vi || {}), $g.forEach(Kg)), h = typeof requestAnimationFrame < "u" && requestAnimationFrame, l && f.sleep(), c = h || function(x) {
          return setTimeout(x, o - f.time * 1e3 + 1 | 0);
        }, rl = 1, y(2));
      },
      sleep: function() {
        (h ? cancelAnimationFrame : clearTimeout)(l), rl = 0, c = nl;
      },
      lagSmoothing: function(x, v) {
        e = x || 1 / 0, t = Math.min(v || 33, e);
      },
      fps: function(x) {
        r = 1e3 / (x || 240), o = f.time * 1e3 + r;
      },
      add: function(x, v, E) {
        var T = v ? function(M, P, R, d) {
          x(M, P, R, d), f.remove(T);
        } : x;
        return f.remove(x), a[E ? "unshift" : "push"](T), Vo(), T;
      },
      remove: function(x, v) {
        ~(v = a.indexOf(x)) && a.splice(v, 1) && _ >= v && _--;
      },
      _listeners: a
    }, f;
  }(), Vo = function() {
    return !rl && hi.wake();
  }, Pt = {}, aw = /^[\d.\-M][\d.\-,\s]/, lw = /["']/g, cw = function(e) {
    for (var t = {}, n = e.substr(1, e.length - 3).split(":"), i = n[0], r = 1, o = n.length, a, l, c; r < o; r++) l = n[r], a = r !== o - 1 ? l.lastIndexOf(",") : l.length, c = l.substr(0, a), t[i] = isNaN(c) ? c.replace(lw, "").trim() : +c, i = l.substr(a + 1).trim();
    return t;
  }, uw = function(e) {
    var t = e.indexOf("(") + 1, n = e.indexOf(")"), i = e.indexOf("(", t);
    return e.substring(t, ~i && i < n ? e.indexOf(")", n + 1) : n);
  }, hw = function(e) {
    var t = (e + "").split("("), n = Pt[t[0]];
    return n && t.length > 1 && n.config ? n.config.apply(null, ~e.indexOf("{") ? [
      cw(t[1])
    ] : uw(e).split(",").map(Og)) : Pt._CE && aw.test(e) ? Pt._CE("", e) : n;
  }, e_ = function(e) {
    return function(t) {
      return 1 - e(1 - t);
    };
  }, t_ = function s(e, t) {
    for (var n = e._first, i; n; ) n instanceof qn ? s(n, t) : n.vars.yoyoEase && (!n._yoyo || !n._repeat) && n._yoyo !== t && (n.timeline ? s(n.timeline, t) : (i = n._ease, n._ease = n._yEase, n._yEase = i, n._yoyo = t)), n = n._next;
  }, Ls = function(e, t) {
    return e && (ln(e) ? e : Pt[e] || hw(e)) || t;
  }, Hs = function(e, t, n, i) {
    n === void 0 && (n = function(l) {
      return 1 - t(1 - l);
    }), i === void 0 && (i = function(l) {
      return l < 0.5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2;
    });
    var r = {
      easeIn: t,
      easeOut: n,
      easeInOut: i
    }, o;
    return ti(e, function(a) {
      Pt[a] = mi[a] = r, Pt[o = a.toLowerCase()] = n;
      for (var l in r) Pt[o + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")] = Pt[a + "." + l] = r[l];
    }), r;
  }, n_ = function(e) {
    return function(t) {
      return t < 0.5 ? (1 - e(1 - t * 2)) / 2 : 0.5 + e((t - 0.5) * 2) / 2;
    };
  }, Ku = function s(e, t, n) {
    var i = t >= 1 ? t : 1, r = (n || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1), o = r / tf * (Math.asin(1 / i) || 0), a = function(h) {
      return h === 1 ? 1 : i * Math.pow(2, -10 * h) * BE((h - o) * r) + 1;
    }, l = e === "out" ? a : e === "in" ? function(c) {
      return 1 - a(1 - c);
    } : n_(a);
    return r = tf / r, l.config = function(c, h) {
      return s(e, c, h);
    }, l;
  }, Zu = function s(e, t) {
    t === void 0 && (t = 1.70158);
    var n = function(o) {
      return o ? --o * o * ((t + 1) * o + t) + 1 : 0;
    }, i = e === "out" ? n : e === "in" ? function(r) {
      return 1 - n(1 - r);
    } : n_(n);
    return i.config = function(r) {
      return s(e, r);
    }, i;
  };
  ti("Linear,Quad,Cubic,Quart,Quint,Strong", function(s, e) {
    var t = e < 5 ? e + 1 : e;
    Hs(s + ",Power" + (t - 1), e ? function(n) {
      return Math.pow(n, t);
    } : function(n) {
      return n;
    }, function(n) {
      return 1 - Math.pow(1 - n, t);
    }, function(n) {
      return n < 0.5 ? Math.pow(n * 2, t) / 2 : 1 - Math.pow((1 - n) * 2, t) / 2;
    });
  });
  Pt.Linear.easeNone = Pt.none = Pt.Linear.easeIn;
  Hs("Elastic", Ku("in"), Ku("out"), Ku());
  (function(s, e) {
    var t = 1 / e, n = 2 * t, i = 2.5 * t, r = function(a) {
      return a < t ? s * a * a : a < n ? s * Math.pow(a - 1.5 / e, 2) + 0.75 : a < i ? s * (a -= 2.25 / e) * a + 0.9375 : s * Math.pow(a - 2.625 / e, 2) + 0.984375;
    };
    Hs("Bounce", function(o) {
      return 1 - r(1 - o);
    }, r);
  })(7.5625, 2.75);
  Hs("Expo", function(s) {
    return Math.pow(2, 10 * (s - 1)) * s + s * s * s * s * s * s * (1 - s);
  });
  Hs("Circ", function(s) {
    return -(Eg(1 - s * s) - 1);
  });
  Hs("Sine", function(s) {
    return s === 1 ? 1 : -kE(s * OE) + 1;
  });
  Hs("Back", Zu("in"), Zu("out"), Zu());
  Pt.SteppedEase = Pt.steps = mi.SteppedEase = {
    config: function(e, t) {
      e === void 0 && (e = 1);
      var n = 1 / e, i = e + (t ? 0 : 1), r = t ? 1 : 0, o = 1 - Bn;
      return function(a) {
        return ((i * dl(0, o, a) | 0) + r) * n;
      };
    }
  };
  ko.ease = Pt["quad.out"];
  ti("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(s) {
    return Qf += s + "," + s + "Params,";
  });
  var i_ = function(e, t) {
    this.id = FE++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : Ng, this.set = t ? t.getSetter : rd;
  }, sl = function() {
    function s(t) {
      this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Ho(this, +t.duration, 1, 1), this.data = t.data, en && (this._ctx = en, en.data.push(this)), rl || hi.wake();
    }
    var e = s.prototype;
    return e.delay = function(n) {
      return n || n === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + n - this._delay), this._delay = n, this) : this._delay;
    }, e.duration = function(n) {
      return arguments.length ? this.totalDuration(this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n) : this.totalDuration() && this._dur;
    }, e.totalDuration = function(n) {
      return arguments.length ? (this._dirty = 0, Ho(this, this._repeat < 0 ? n : (n - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur;
    }, e.totalTime = function(n, i) {
      if (Vo(), !arguments.length) return this._tTime;
      var r = this._dp;
      if (r && r.smoothChildTiming && this._ts) {
        for (Xc(this, n), !r._dp || r.parent || Bg(r, this); r && r.parent; ) r.parent._time !== r._start + (r._ts >= 0 ? r._tTime / r._ts : (r.totalDuration() - r._tTime) / -r._ts) && r.totalTime(r._tTime, true), r = r.parent;
        !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && n < this._tDur || this._ts < 0 && n > 0 || !this._tDur && !n) && Xi(this._dp, this, this._start - this._delay);
      }
      return (this._tTime !== n || !this._dur && !i || this._initted && Math.abs(this._zTime) === Bn || !n && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = n), Ug(this, n, i)), this;
    }, e.time = function(n, i) {
      return arguments.length ? this.totalTime(Math.min(this.totalDuration(), n + nm(this)) % (this._dur + this._rDelay) || (n ? this._dur : 0), i) : this._time;
    }, e.totalProgress = function(n, i) {
      return arguments.length ? this.totalTime(this.totalDuration() * n, i) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0;
    }, e.progress = function(n, i) {
      return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) + nm(this), i) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
    }, e.iteration = function(n, i) {
      var r = this.duration() + this._rDelay;
      return arguments.length ? this.totalTime(this._time + (n - 1) * r, i) : this._repeat ? zo(this._tTime, r) + 1 : 1;
    }, e.timeScale = function(n, i) {
      if (!arguments.length) return this._rts === -1e-8 ? 0 : this._rts;
      if (this._rts === n) return this;
      var r = this.parent && this._ts ? Pc(this.parent._time, this) : this._tTime;
      return this._rts = +n || 0, this._ts = this._ps || n === -1e-8 ? 0 : this._rts, this.totalTime(dl(-Math.abs(this._delay), this._tDur, r), i !== false), Wc(this), qE(this);
    }, e.paused = function(n) {
      return arguments.length ? (this._ps !== n && (this._ps = n, n ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Vo(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== Bn && (this._tTime -= Bn)))), this) : this._ps;
    }, e.startTime = function(n) {
      if (arguments.length) {
        this._start = n;
        var i = this.parent || this._dp;
        return i && (i._sort || !this.parent) && Xi(i, this, n - this._delay), this;
      }
      return this._start;
    }, e.endTime = function(n) {
      return this._start + (ei(n) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
    }, e.rawTime = function(n) {
      var i = this.parent || this._dp;
      return i ? n && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Pc(i.rawTime(n), this) : this._tTime : this._tTime;
    }, e.revert = function(n) {
      n === void 0 && (n = VE);
      var i = In;
      return In = n, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(n), this.totalTime(-0.01, n.suppressEvents)), this.data !== "nested" && n.kill !== false && this.kill(), In = i, this;
    }, e.globalTime = function(n) {
      for (var i = this, r = arguments.length ? n : i.rawTime(); i; ) r = i._start + r / (Math.abs(i._ts) || 1), i = i._dp;
      return !this.parent && this._sat ? this._sat.globalTime(n) : r;
    }, e.repeat = function(n) {
      return arguments.length ? (this._repeat = n === 1 / 0 ? -2 : n, im(this)) : this._repeat === -2 ? 1 / 0 : this._repeat;
    }, e.repeatDelay = function(n) {
      if (arguments.length) {
        var i = this._time;
        return this._rDelay = n, im(this), i ? this.time(i) : this;
      }
      return this._rDelay;
    }, e.yoyo = function(n) {
      return arguments.length ? (this._yoyo = n, this) : this._yoyo;
    }, e.seek = function(n, i) {
      return this.totalTime(Si(this, n), ei(i));
    }, e.restart = function(n, i) {
      return this.play().totalTime(n ? -this._delay : 0, ei(i)), this._dur || (this._zTime = -1e-8), this;
    }, e.play = function(n, i) {
      return n != null && this.seek(n, i), this.reversed(false).paused(false);
    }, e.reverse = function(n, i) {
      return n != null && this.seek(n || this.totalDuration(), i), this.reversed(true).paused(false);
    }, e.pause = function(n, i) {
      return n != null && this.seek(n, i), this.paused(true);
    }, e.resume = function() {
      return this.paused(false);
    }, e.reversed = function(n) {
      return arguments.length ? (!!n !== this.reversed() && this.timeScale(-this._rts || (n ? -1e-8 : 0)), this) : this._rts < 0;
    }, e.invalidate = function() {
      return this._initted = this._act = 0, this._zTime = -1e-8, this;
    }, e.isActive = function() {
      var n = this.parent || this._dp, i = this._start, r;
      return !!(!n || this._ts && this._initted && n.isActive() && (r = n.rawTime(true)) >= i && r < this.endTime(true) - Bn);
    }, e.eventCallback = function(n, i, r) {
      var o = this.vars;
      return arguments.length > 1 ? (i ? (o[n] = i, r && (o[n + "Params"] = r), n === "onUpdate" && (this._onUpdate = i)) : delete o[n], this) : o[n];
    }, e.then = function(n) {
      var i = this;
      return new Promise(function(r) {
        var o = ln(n) ? n : Fg, a = function() {
          var c = i.then;
          i.then = null, ln(o) && (o = o(i)) && (o.then || o === i) && (i.then = c), r(o), i.then = c;
        };
        i._initted && i.totalProgress() === 1 && i._ts >= 0 || !i._tTime && i._ts < 0 ? a() : i._prom = a;
      });
    }, e.kill = function() {
      Ua(this);
    }, s;
  }();
  gi(sl.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: false,
    parent: null,
    _initted: false,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -1e-8,
    _prom: 0,
    _ps: false,
    _rts: 1
  });
  var qn = function(s) {
    Tg(e, s);
    function e(n, i) {
      var r;
      return n === void 0 && (n = {}), r = s.call(this, n) || this, r.labels = {}, r.smoothChildTiming = !!n.smoothChildTiming, r.autoRemoveChildren = !!n.autoRemoveChildren, r._sort = ei(n.sortChildren), nn && Xi(n.parent || nn, vr(r), i), n.reversed && r.reverse(), n.paused && r.paused(true), n.scrollTrigger && zg(vr(r), n.scrollTrigger), r;
    }
    var t = e.prototype;
    return t.to = function(i, r, o) {
      return Ga(0, arguments, this), this;
    }, t.from = function(i, r, o) {
      return Ga(1, arguments, this), this;
    }, t.fromTo = function(i, r, o, a) {
      return Ga(2, arguments, this), this;
    }, t.set = function(i, r, o) {
      return r.duration = 0, r.parent = this, Va(r).repeatDelay || (r.repeat = 0), r.immediateRender = !!r.immediateRender, new vn(i, r, Si(this, o), 1), this;
    }, t.call = function(i, r, o) {
      return Xi(this, vn.delayedCall(0, i, r), o);
    }, t.staggerTo = function(i, r, o, a, l, c, h) {
      return o.duration = r, o.stagger = o.stagger || a, o.onComplete = c, o.onCompleteParams = h, o.parent = this, new vn(i, o, Si(this, l)), this;
    }, t.staggerFrom = function(i, r, o, a, l, c, h) {
      return o.runBackwards = 1, Va(o).immediateRender = ei(o.immediateRender), this.staggerTo(i, r, o, a, l, c, h);
    }, t.staggerFromTo = function(i, r, o, a, l, c, h, f) {
      return a.startAt = o, Va(a).immediateRender = ei(a.immediateRender), this.staggerTo(i, r, a, l, c, h, f);
    }, t.render = function(i, r, o) {
      var a = this._time, l = this._dirty ? this.totalDuration() : this._tDur, c = this._dur, h = i <= 0 ? 0 : yn(i), f = this._zTime < 0 != i < 0 && (this._initted || !c), m, _, y, g, x, v, E, T, M, P, R, d;
      if (this !== nn && h > l && i >= 0 && (h = l), h !== this._tTime || o || f) {
        if (a !== this._time && c && (h += this._time - a, i += this._time - a), m = h, M = this._start, T = this._ts, v = !T, f && (c || (a = this._zTime), (i || !r) && (this._zTime = i)), this._repeat) {
          if (R = this._yoyo, x = c + this._rDelay, this._repeat < -1 && i < 0) return this.totalTime(x * 100 + i, r, o);
          if (m = yn(h % x), h === l ? (g = this._repeat, m = c) : (P = yn(h / x), g = ~~P, g && g === P && (m = c, g--), m > c && (m = c)), P = zo(this._tTime, x), !a && this._tTime && P !== g && this._tTime - P * x - this._dur <= 0 && (P = g), R && g & 1 && (m = c - m, d = 1), g !== P && !this._lock) {
            var N = R && P & 1, w = N === (R && g & 1);
            if (g < P && (N = !N), a = N ? 0 : h % c ? c : h, this._lock = 1, this.render(a || (d ? 0 : yn(g * x)), r, !c)._lock = 0, this._tTime = h, !r && this.parent && di(this, "onRepeat"), this.vars.repeatRefresh && !d && (this.invalidate()._lock = 1), a && a !== this._time || v !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
            if (c = this._dur, l = this._tDur, w && (this._lock = 2, a = N ? c : -1e-4, this.render(a, true), this.vars.repeatRefresh && !d && this.invalidate()), this._lock = 0, !this._ts && !v) return this;
            t_(this, d);
          }
        }
        if (this._hasPause && !this._forcing && this._lock < 2 && (E = KE(this, yn(a), yn(m)), E && (h -= m - (m = E._start))), this._tTime = h, this._time = m, this._act = !T, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = i, a = 0), !a && m && !r && !g && (di(this, "onStart"), this._tTime !== h)) return this;
        if (m >= a && i >= 0) for (_ = this._first; _; ) {
          if (y = _._next, (_._act || m >= _._start) && _._ts && E !== _) {
            if (_.parent !== this) return this.render(i, r, o);
            if (_.render(_._ts > 0 ? (m - _._start) * _._ts : (_._dirty ? _.totalDuration() : _._tDur) + (m - _._start) * _._ts, r, o), m !== this._time || !this._ts && !v) {
              E = 0, y && (h += this._zTime = -1e-8);
              break;
            }
          }
          _ = y;
        }
        else {
          _ = this._last;
          for (var D = i < 0 ? i : m; _; ) {
            if (y = _._prev, (_._act || D <= _._end) && _._ts && E !== _) {
              if (_.parent !== this) return this.render(i, r, o);
              if (_.render(_._ts > 0 ? (D - _._start) * _._ts : (_._dirty ? _.totalDuration() : _._tDur) + (D - _._start) * _._ts, r, o || In && (_._initted || _._startAt)), m !== this._time || !this._ts && !v) {
                E = 0, y && (h += this._zTime = D ? -1e-8 : Bn);
                break;
              }
            }
            _ = y;
          }
        }
        if (E && !r && (this.pause(), E.render(m >= a ? 0 : -1e-8)._zTime = m >= a ? 1 : -1, this._ts)) return this._start = M, Wc(this), this.render(i, r, o);
        this._onUpdate && !r && di(this, "onUpdate", true), (h === l && this._tTime >= this.totalDuration() || !h && a) && (M === this._start || Math.abs(T) !== Math.abs(this._ts)) && (this._lock || ((i || !c) && (h === l && this._ts > 0 || !h && this._ts < 0) && ns(this, 1), !r && !(i < 0 && !a) && (h || a || !l) && (di(this, h === l && i >= 0 ? "onComplete" : "onReverseComplete", true), this._prom && !(h < l && this.timeScale() > 0) && this._prom())));
      }
      return this;
    }, t.add = function(i, r) {
      var o = this;
      if (Ar(r) || (r = Si(this, r, i)), !(i instanceof sl)) {
        if (zn(i)) return i.forEach(function(a) {
          return o.add(a, r);
        }), this;
        if (Rn(i)) return this.addLabel(i, r);
        if (ln(i)) i = vn.delayedCall(0, i);
        else return this;
      }
      return this !== i ? Xi(this, i, r) : this;
    }, t.getChildren = function(i, r, o, a) {
      i === void 0 && (i = true), r === void 0 && (r = true), o === void 0 && (o = true), a === void 0 && (a = -1e8);
      for (var l = [], c = this._first; c; ) c._start >= a && (c instanceof vn ? r && l.push(c) : (o && l.push(c), i && l.push.apply(l, c.getChildren(true, r, o)))), c = c._next;
      return l;
    }, t.getById = function(i) {
      for (var r = this.getChildren(1, 1, 1), o = r.length; o--; ) if (r[o].vars.id === i) return r[o];
    }, t.remove = function(i) {
      return Rn(i) ? this.removeLabel(i) : ln(i) ? this.killTweensOf(i) : (i.parent === this && Gc(this, i), i === this._recent && (this._recent = this._last), Ds(this));
    }, t.totalTime = function(i, r) {
      return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = yn(hi.time - (this._ts > 0 ? i / this._ts : (this.totalDuration() - i) / -this._ts))), s.prototype.totalTime.call(this, i, r), this._forcing = 0, this) : this._tTime;
    }, t.addLabel = function(i, r) {
      return this.labels[i] = Si(this, r), this;
    }, t.removeLabel = function(i) {
      return delete this.labels[i], this;
    }, t.addPause = function(i, r, o) {
      var a = vn.delayedCall(0, r || nl, o);
      return a.data = "isPause", this._hasPause = 1, Xi(this, a, Si(this, i));
    }, t.removePause = function(i) {
      var r = this._first;
      for (i = Si(this, i); r; ) r._start === i && r.data === "isPause" && ns(r), r = r._next;
    }, t.killTweensOf = function(i, r, o) {
      for (var a = this.getTweensOf(i, o), l = a.length; l--; ) Kr !== a[l] && a[l].kill(i, r);
      return this;
    }, t.getTweensOf = function(i, r) {
      for (var o = [], a = Ei(i), l = this._first, c = Ar(r), h; l; ) l instanceof vn ? GE(l._targets, a) && (c ? (!Kr || l._initted && l._ts) && l.globalTime(0) <= r && l.globalTime(l.totalDuration()) > r : !r || l.isActive()) && o.push(l) : (h = l.getTweensOf(a, r)).length && o.push.apply(o, h), l = l._next;
      return o;
    }, t.tweenTo = function(i, r) {
      r = r || {};
      var o = this, a = Si(o, i), l = r, c = l.startAt, h = l.onStart, f = l.onStartParams, m = l.immediateRender, _, y = vn.to(o, gi({
        ease: r.ease || "none",
        lazy: false,
        immediateRender: false,
        time: a,
        overwrite: "auto",
        duration: r.duration || Math.abs((a - (c && "time" in c ? c.time : o._time)) / o.timeScale()) || Bn,
        onStart: function() {
          if (o.pause(), !_) {
            var x = r.duration || Math.abs((a - (c && "time" in c ? c.time : o._time)) / o.timeScale());
            y._dur !== x && Ho(y, x, 0, 1).render(y._time, true, true), _ = 1;
          }
          h && h.apply(y, f || []);
        }
      }, r));
      return m ? y.render(0) : y;
    }, t.tweenFromTo = function(i, r, o) {
      return this.tweenTo(r, gi({
        startAt: {
          time: Si(this, i)
        }
      }, o));
    }, t.recent = function() {
      return this._recent;
    }, t.nextLabel = function(i) {
      return i === void 0 && (i = this._time), rm(this, Si(this, i));
    }, t.previousLabel = function(i) {
      return i === void 0 && (i = this._time), rm(this, Si(this, i), 1);
    }, t.currentLabel = function(i) {
      return arguments.length ? this.seek(i, true) : this.previousLabel(this._time + Bn);
    }, t.shiftChildren = function(i, r, o) {
      o === void 0 && (o = 0);
      for (var a = this._first, l = this.labels, c; a; ) a._start >= o && (a._start += i, a._end += i), a = a._next;
      if (r) for (c in l) l[c] >= o && (l[c] += i);
      return Ds(this);
    }, t.invalidate = function(i) {
      var r = this._first;
      for (this._lock = 0; r; ) r.invalidate(i), r = r._next;
      return s.prototype.invalidate.call(this, i);
    }, t.clear = function(i) {
      i === void 0 && (i = true);
      for (var r = this._first, o; r; ) o = r._next, this.remove(r), r = o;
      return this._dp && (this._time = this._tTime = this._pTime = 0), i && (this.labels = {}), Ds(this);
    }, t.totalDuration = function(i) {
      var r = 0, o = this, a = o._last, l = $i, c, h, f;
      if (arguments.length) return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -i : i));
      if (o._dirty) {
        for (f = o.parent; a; ) c = a._prev, a._dirty && a.totalDuration(), h = a._start, h > l && o._sort && a._ts && !o._lock ? (o._lock = 1, Xi(o, a, h - a._delay, 1)._lock = 0) : l = h, h < 0 && a._ts && (r -= h, (!f && !o._dp || f && f.smoothChildTiming) && (o._start += h / o._ts, o._time -= h, o._tTime -= h), o.shiftChildren(-h, false, -1 / 0), l = 0), a._end > r && a._ts && (r = a._end), a = c;
        Ho(o, o === nn && o._time > r ? o._time : r, 1, 1), o._dirty = 0;
      }
      return o._tDur;
    }, e.updateRoot = function(i) {
      if (nn._ts && (Ug(nn, Pc(i, nn)), Ig = hi.frame), hi.frame >= em) {
        em += pi.autoSleep || 120;
        var r = nn._first;
        if ((!r || !r._ts) && pi.autoSleep && hi._listeners.length < 2) {
          for (; r && !r._ts; ) r = r._next;
          r || hi.sleep();
        }
      }
    }, e;
  }(sl);
  gi(qn.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
  });
  var fw = function(e, t, n, i, r, o, a) {
    var l = new ni(this._pt, e, t, 0, 1, c_, null, r), c = 0, h = 0, f, m, _, y, g, x, v, E;
    for (l.b = n, l.e = i, n += "", i += "", (v = ~i.indexOf("random(")) && (i = il(i)), o && (E = [
      n,
      i
    ], o(E, e, t), n = E[0], i = E[1]), m = n.match(Yu) || []; f = Yu.exec(i); ) y = f[0], g = i.substring(c, f.index), _ ? _ = (_ + 1) % 5 : g.substr(-5) === "rgba(" && (_ = 1), y !== m[h++] && (x = parseFloat(m[h - 1]) || 0, l._pt = {
      _next: l._pt,
      p: g || h === 1 ? g : ",",
      s: x,
      c: y.charAt(1) === "=" ? To(x, y) - x : parseFloat(y) - x,
      m: _ && _ < 4 ? Math.round : 0
    }, c = Yu.lastIndex);
    return l.c = c < i.length ? i.substring(c, i.length) : "", l.fp = a, (Cg.test(i) || v) && (l.e = 0), this._pt = l, l;
  }, td = function(e, t, n, i, r, o, a, l, c, h) {
    ln(i) && (i = i(r || 0, e, o));
    var f = e[t], m = n !== "get" ? n : ln(f) ? c ? e[t.indexOf("set") || !ln(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](c) : e[t]() : f, _ = ln(f) ? c ? _w : a_ : id, y;
    if (Rn(i) && (~i.indexOf("random(") && (i = il(i)), i.charAt(1) === "=" && (y = To(m, i) + (Fn(m) || 0), (y || y === 0) && (i = y))), !h || m !== i || hf) return !isNaN(m * i) && i !== "" ? (y = new ni(this._pt, e, t, +m || 0, i - (m || 0), typeof f == "boolean" ? yw : l_, 0, _), c && (y.fp = c), a && y.modifier(a, this, e), this._pt = y) : (!f && !(t in e) && Zf(t, i), fw.call(this, e, t, m, i, _, l || pi.stringFilter, c));
  }, dw = function(e, t, n, i, r) {
    if (ln(e) && (e = Wa(e, r, t, n, i)), !Ji(e) || e.style && e.nodeType || zn(e) || wg(e)) return Rn(e) ? Wa(e, r, t, n, i) : e;
    var o = {}, a;
    for (a in e) o[a] = Wa(e[a], r, t, n, i);
    return o;
  }, r_ = function(e, t, n, i, r, o) {
    var a, l, c, h;
    if (ui[e] && (a = new ui[e]()).init(r, a.rawVars ? t[e] : dw(t[e], i, r, o, n), n, i, o) !== false && (n._pt = l = new ni(n._pt, r, e, 0, 1, a.render, a, 0, a.priority), n !== vo)) for (c = n._ptLookup[n._targets.indexOf(r)], h = a._props.length; h--; ) c[a._props[h]] = l;
    return a;
  }, Kr, hf, nd = function s(e, t, n) {
    var i = e.vars, r = i.ease, o = i.startAt, a = i.immediateRender, l = i.lazy, c = i.onUpdate, h = i.runBackwards, f = i.yoyoEase, m = i.keyframes, _ = i.autoRevert, y = e._dur, g = e._startAt, x = e._targets, v = e.parent, E = v && v.data === "nested" ? v.vars.targets : x, T = e._overwrite === "auto" && !Yf, M = e.timeline, P, R, d, N, w, D, B, Z, G, Q, ue, te, he;
    if (M && (!m || !r) && (r = "none"), e._ease = Ls(r, ko.ease), e._yEase = f ? e_(Ls(f === true ? r : f, ko.ease)) : 0, f && e._yoyo && !e._repeat && (f = e._yEase, e._yEase = e._ease, e._ease = f), e._from = !M && !!i.runBackwards, !M || m && !i.stagger) {
      if (Z = x[0] ? Ps(x[0]).harness : 0, te = Z && i[Z.prop], P = Rc(i, Jf), g && (g._zTime < 0 && g.progress(1), t < 0 && h && a && !_ ? g.render(-1, true) : g.revert(h && y ? dc : HE), g._lazy = 0), o) {
        if (ns(e._startAt = vn.set(x, gi({
          data: "isStart",
          overwrite: false,
          parent: v,
          immediateRender: true,
          lazy: !g && ei(l),
          startAt: null,
          delay: 0,
          onUpdate: c && function() {
            return di(e, "onUpdate");
          },
          stagger: 0
        }, o))), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (In || !a && !_) && e._startAt.revert(dc), a && y && t <= 0 && n <= 0) {
          t && (e._zTime = t);
          return;
        }
      } else if (h && y && !g) {
        if (t && (a = false), d = gi({
          overwrite: false,
          data: "isFromStart",
          lazy: a && !g && ei(l),
          immediateRender: a,
          stagger: 0,
          parent: v
        }, P), te && (d[Z.prop] = te), ns(e._startAt = vn.set(x, d)), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (In ? e._startAt.revert(dc) : e._startAt.render(-1, true)), e._zTime = t, !a) s(e._startAt, Bn, Bn);
        else if (!t) return;
      }
      for (e._pt = e._ptCache = 0, l = y && ei(l) || l && !y, R = 0; R < x.length; R++) {
        if (w = x[R], B = w._gsap || ed(x)[R]._gsap, e._ptLookup[R] = Q = {}, sf[B.id] && es.length && Cc(), ue = E === x ? R : E.indexOf(w), Z && (G = new Z()).init(w, te || P, e, ue, E) !== false && (e._pt = N = new ni(e._pt, w, G.name, 0, 1, G.render, G, 0, G.priority), G._props.forEach(function(ie) {
          Q[ie] = N;
        }), G.priority && (D = 1)), !Z || te) for (d in P) ui[d] && (G = r_(d, P, e, ue, w, E)) ? G.priority && (D = 1) : Q[d] = N = td.call(e, w, d, "get", P[d], ue, E, 0, i.stringFilter);
        e._op && e._op[R] && e.kill(w, e._op[R]), T && e._pt && (Kr = e, nn.killTweensOf(w, Q, e.globalTime(t)), he = !e.parent, Kr = 0), e._pt && l && (sf[B.id] = 1);
      }
      D && u_(e), e._onInit && e._onInit(e);
    }
    e._onUpdate = c, e._initted = (!e._op || e._pt) && !he, m && t <= 0 && M.render($i, true, true);
  }, pw = function(e, t, n, i, r, o, a, l) {
    var c = (e._pt && e._ptCache || (e._ptCache = {}))[t], h, f, m, _;
    if (!c) for (c = e._ptCache[t] = [], m = e._ptLookup, _ = e._targets.length; _--; ) {
      if (h = m[_][t], h && h.d && h.d._pt) for (h = h.d._pt; h && h.p !== t && h.fp !== t; ) h = h._next;
      if (!h) return hf = 1, e.vars[t] = "+=0", nd(e, a), hf = 0, l ? tl(t + " not eligible for reset") : 1;
      c.push(h);
    }
    for (_ = c.length; _--; ) f = c[_], h = f._pt || f, h.s = (i || i === 0) && !r ? i : h.s + (i || 0) + o * h.c, h.c = n - h.s, f.e && (f.e = cn(n) + Fn(f.e)), f.b && (f.b = h.s + Fn(f.b));
  }, mw = function(e, t) {
    var n = e[0] ? Ps(e[0]).harness : 0, i = n && n.aliases, r, o, a, l;
    if (!i) return t;
    r = Bo({}, t);
    for (o in i) if (o in r) for (l = i[o].split(","), a = l.length; a--; ) r[l[a]] = r[o];
    return r;
  }, gw = function(e, t, n, i) {
    var r = t.ease || i || "power1.inOut", o, a;
    if (zn(t)) a = n[e] || (n[e] = []), t.forEach(function(l, c) {
      return a.push({
        t: c / (t.length - 1) * 100,
        v: l,
        e: r
      });
    });
    else for (o in t) a = n[o] || (n[o] = []), o === "ease" || a.push({
      t: parseFloat(e),
      v: t[o],
      e: r
    });
  }, Wa = function(e, t, n, i, r) {
    return ln(e) ? e.call(t, n, i, r) : Rn(e) && ~e.indexOf("random(") ? il(e) : e;
  }, s_ = Qf + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", o_ = {};
  ti(s_ + ",id,stagger,delay,duration,paused,scrollTrigger", function(s) {
    return o_[s] = 1;
  });
  var vn = function(s) {
    Tg(e, s);
    function e(n, i, r, o) {
      var a;
      typeof i == "number" && (r.duration = i, i = r, r = null), a = s.call(this, o ? i : Va(i)) || this;
      var l = a.vars, c = l.duration, h = l.delay, f = l.immediateRender, m = l.stagger, _ = l.overwrite, y = l.keyframes, g = l.defaults, x = l.scrollTrigger, v = l.yoyoEase, E = i.parent || nn, T = (zn(n) || wg(n) ? Ar(n[0]) : "length" in i) ? [
        n
      ] : Ei(n), M, P, R, d, N, w, D, B;
      if (a._targets = T.length ? ed(T) : tl("GSAP target " + n + " not found. https://gsap.com", !pi.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = _, y || m || nc(c) || nc(h)) {
        if (i = a.vars, M = a.timeline = new qn({
          data: "nested",
          defaults: g || {},
          targets: E && E.data === "nested" ? E.vars.targets : T
        }), M.kill(), M.parent = M._dp = vr(a), M._start = 0, m || nc(c) || nc(h)) {
          if (d = T.length, D = m && Wg(m), Ji(m)) for (N in m) ~s_.indexOf(N) && (B || (B = {}), B[N] = m[N]);
          for (P = 0; P < d; P++) R = Rc(i, o_), R.stagger = 0, v && (R.yoyoEase = v), B && Bo(R, B), w = T[P], R.duration = +Wa(c, vr(a), P, w, T), R.delay = (+Wa(h, vr(a), P, w, T) || 0) - a._delay, !m && d === 1 && R.delay && (a._delay = h = R.delay, a._start += h, R.delay = 0), M.to(w, R, D ? D(P, w, T) : 0), M._ease = Pt.none;
          M.duration() ? c = h = 0 : a.timeline = 0;
        } else if (y) {
          Va(gi(M.vars.defaults, {
            ease: "none"
          })), M._ease = Ls(y.ease || i.ease || "none");
          var Z = 0, G, Q, ue;
          if (zn(y)) y.forEach(function(te) {
            return M.to(T, te, ">");
          }), M.duration();
          else {
            R = {};
            for (N in y) N === "ease" || N === "easeEach" || gw(N, y[N], R, y.easeEach);
            for (N in R) for (G = R[N].sort(function(te, he) {
              return te.t - he.t;
            }), Z = 0, P = 0; P < G.length; P++) Q = G[P], ue = {
              ease: Q.e,
              duration: (Q.t - (P ? G[P - 1].t : 0)) / 100 * c
            }, ue[N] = Q.v, M.to(T, ue, Z), Z += ue.duration;
            M.duration() < c && M.to({}, {
              duration: c - M.duration()
            });
          }
        }
        c || a.duration(c = M.duration());
      } else a.timeline = 0;
      return _ === true && !Yf && (Kr = vr(a), nn.killTweensOf(T), Kr = 0), Xi(E, vr(a), r), i.reversed && a.reverse(), i.paused && a.paused(true), (f || !c && !y && a._start === yn(E._time) && ei(f) && YE(vr(a)) && E.data !== "nested") && (a._tTime = -1e-8, a.render(Math.max(0, -h) || 0)), x && zg(vr(a), x), a;
    }
    var t = e.prototype;
    return t.render = function(i, r, o) {
      var a = this._time, l = this._tDur, c = this._dur, h = i < 0, f = i > l - Bn && !h ? l : i < Bn ? 0 : i, m, _, y, g, x, v, E, T, M;
      if (!c) $E(this, i, r, o);
      else if (f !== this._tTime || !i || o || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== h || this._lazy) {
        if (m = f, T = this.timeline, this._repeat) {
          if (g = c + this._rDelay, this._repeat < -1 && h) return this.totalTime(g * 100 + i, r, o);
          if (m = yn(f % g), f === l ? (y = this._repeat, m = c) : (x = yn(f / g), y = ~~x, y && y === x ? (m = c, y--) : m > c && (m = c)), v = this._yoyo && y & 1, v && (M = this._yEase, m = c - m), x = zo(this._tTime, g), m === a && !o && this._initted && y === x) return this._tTime = f, this;
          y !== x && (T && this._yEase && t_(T, v), this.vars.repeatRefresh && !v && !this._lock && m !== g && this._initted && (this._lock = o = 1, this.render(yn(g * y), true).invalidate()._lock = 0));
        }
        if (!this._initted) {
          if (Hg(this, h ? i : m, o, r, f)) return this._tTime = 0, this;
          if (a !== this._time && !(o && this.vars.repeatRefresh && y !== x)) return this;
          if (c !== this._dur) return this.render(i, r, o);
        }
        if (this._tTime = f, this._time = m, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = E = (M || this._ease)(m / c), this._from && (this.ratio = E = 1 - E), m && !a && !r && !y && (di(this, "onStart"), this._tTime !== f)) return this;
        for (_ = this._pt; _; ) _.r(E, _.d), _ = _._next;
        T && T.render(i < 0 ? i : T._dur * T._ease(m / this._dur), r, o) || this._startAt && (this._zTime = i), this._onUpdate && !r && (h && of(this, i, r, o), di(this, "onUpdate")), this._repeat && y !== x && this.vars.onRepeat && !r && this.parent && di(this, "onRepeat"), (f === this._tDur || !f) && this._tTime === f && (h && !this._onUpdate && of(this, i, true, true), (i || !c) && (f === this._tDur && this._ts > 0 || !f && this._ts < 0) && ns(this, 1), !r && !(h && !a) && (f || a || v) && (di(this, f === l ? "onComplete" : "onReverseComplete", true), this._prom && !(f < l && this.timeScale() > 0) && this._prom()));
      }
      return this;
    }, t.targets = function() {
      return this._targets;
    }, t.invalidate = function(i) {
      return (!i || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(i), s.prototype.invalidate.call(this, i);
    }, t.resetTo = function(i, r, o, a, l) {
      rl || hi.wake(), this._ts || this.play();
      var c = Math.min(this._dur, (this._dp._time - this._start) * this._ts), h;
      return this._initted || nd(this, c), h = this._ease(c / this._dur), pw(this, i, r, o, a, h, c, l) ? this.resetTo(i, r, o, a, 1) : (Xc(this, 0), this.parent || kg(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0));
    }, t.kill = function(i, r) {
      if (r === void 0 && (r = "all"), !i && (!r || r === "all")) return this._lazy = this._pt = 0, this.parent ? Ua(this) : this.scrollTrigger && this.scrollTrigger.kill(!!In), this;
      if (this.timeline) {
        var o = this.timeline.totalDuration();
        return this.timeline.killTweensOf(i, r, Kr && Kr.vars.overwrite !== true)._first || Ua(this), this.parent && o !== this.timeline.totalDuration() && Ho(this, this._dur * this.timeline._tDur / o, 0, 1), this;
      }
      var a = this._targets, l = i ? Ei(i) : a, c = this._ptLookup, h = this._pt, f, m, _, y, g, x, v;
      if ((!r || r === "all") && XE(a, l)) return r === "all" && (this._pt = 0), Ua(this);
      for (f = this._op = this._op || [], r !== "all" && (Rn(r) && (g = {}, ti(r, function(E) {
        return g[E] = 1;
      }), r = g), r = mw(a, r)), v = a.length; v--; ) if (~l.indexOf(a[v])) {
        m = c[v], r === "all" ? (f[v] = r, y = m, _ = {}) : (_ = f[v] = f[v] || {}, y = r);
        for (g in y) x = m && m[g], x && ((!("kill" in x.d) || x.d.kill(g) === true) && Gc(this, x, "_pt"), delete m[g]), _ !== "all" && (_[g] = 1);
      }
      return this._initted && !this._pt && h && Ua(this), this;
    }, e.to = function(i, r) {
      return new e(i, r, arguments[2]);
    }, e.from = function(i, r) {
      return Ga(1, arguments);
    }, e.delayedCall = function(i, r, o, a) {
      return new e(r, 0, {
        immediateRender: false,
        lazy: false,
        overwrite: false,
        delay: i,
        onComplete: r,
        onReverseComplete: r,
        onCompleteParams: o,
        onReverseCompleteParams: o,
        callbackScope: a
      });
    }, e.fromTo = function(i, r, o) {
      return Ga(2, arguments);
    }, e.set = function(i, r) {
      return r.duration = 0, r.repeatDelay || (r.repeat = 0), new e(i, r);
    }, e.killTweensOf = function(i, r, o) {
      return nn.killTweensOf(i, r, o);
    }, e;
  }(sl);
  gi(vn.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
  });
  ti("staggerTo,staggerFrom,staggerFromTo", function(s) {
    vn[s] = function() {
      var e = new qn(), t = lf.call(arguments, 0);
      return t.splice(s === "staggerFromTo" ? 5 : 4, 0, 0), e[s].apply(e, t);
    };
  });
  var id = function(e, t, n) {
    return e[t] = n;
  }, a_ = function(e, t, n) {
    return e[t](n);
  }, _w = function(e, t, n, i) {
    return e[t](i.fp, n);
  }, vw = function(e, t, n) {
    return e.setAttribute(t, n);
  }, rd = function(e, t) {
    return ln(e[t]) ? a_ : jf(e[t]) && e.setAttribute ? vw : id;
  }, l_ = function(e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t);
  }, yw = function(e, t) {
    return t.set(t.t, t.p, !!(t.s + t.c * e), t);
  }, c_ = function(e, t) {
    var n = t._pt, i = "";
    if (!e && t.b) i = t.b;
    else if (e === 1 && t.e) i = t.e;
    else {
      for (; n; ) i = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round((n.s + n.c * e) * 1e4) / 1e4) + i, n = n._next;
      i += t.c;
    }
    t.set(t.t, t.p, i, t);
  }, sd = function(e, t) {
    for (var n = t._pt; n; ) n.r(e, n.d), n = n._next;
  }, xw = function(e, t, n, i) {
    for (var r = this._pt, o; r; ) o = r._next, r.p === i && r.modifier(e, t, n), r = o;
  }, bw = function(e) {
    for (var t = this._pt, n, i; t; ) i = t._next, t.p === e && !t.op || t.op === e ? Gc(this, t, "_pt") : t.dep || (n = 1), t = i;
    return !n;
  }, Sw = function(e, t, n, i) {
    i.mSet(e, t, i.m.call(i.tween, n, i.mt), i);
  }, u_ = function(e) {
    for (var t = e._pt, n, i, r, o; t; ) {
      for (n = t._next, i = r; i && i.pr > t.pr; ) i = i._next;
      (t._prev = i ? i._prev : o) ? t._prev._next = t : r = t, (t._next = i) ? i._prev = t : o = t, t = n;
    }
    e._pt = r;
  }, ni = function() {
    function s(t, n, i, r, o, a, l, c, h) {
      this.t = n, this.s = r, this.c = o, this.p = i, this.r = a || l_, this.d = l || this, this.set = c || id, this.pr = h || 0, this._next = t, t && (t._prev = this);
    }
    var e = s.prototype;
    return e.modifier = function(n, i, r) {
      this.mSet = this.mSet || this.set, this.set = Sw, this.m = n, this.mt = r, this.tween = i;
    }, s;
  }();
  ti(Qf + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(s) {
    return Jf[s] = 1;
  });
  mi.TweenMax = mi.TweenLite = vn;
  mi.TimelineLite = mi.TimelineMax = qn;
  nn = new qn({
    sortChildren: false,
    defaults: ko,
    autoRemoveChildren: true,
    id: "root",
    smoothChildTiming: true
  });
  pi.stringFilter = Qg;
  var Is = [], mc = {}, Mw = [], om = 0, Tw = 0, Ju = function(e) {
    return (mc[e] || Mw).map(function(t) {
      return t();
    });
  }, ff = function() {
    var e = Date.now(), t = [];
    e - om > 2 && (Ju("matchMediaInit"), Is.forEach(function(n) {
      var i = n.queries, r = n.conditions, o, a, l, c;
      for (a in i) o = Vi.matchMedia(i[a]).matches, o && (l = 1), o !== r[a] && (r[a] = o, c = 1);
      c && (n.revert(), l && t.push(n));
    }), Ju("matchMediaRevert"), t.forEach(function(n) {
      return n.onMatch(n, function(i) {
        return n.add(null, i);
      });
    }), om = e, Ju("matchMedia"));
  }, h_ = function() {
    function s(t, n) {
      this.selector = n && cf(n), this.data = [], this._r = [], this.isReverted = false, this.id = Tw++, t && this.add(t);
    }
    var e = s.prototype;
    return e.add = function(n, i, r) {
      ln(n) && (r = i, i = n, n = ln);
      var o = this, a = function() {
        var c = en, h = o.selector, f;
        return c && c !== o && c.data.push(o), r && (o.selector = cf(r)), en = o, f = i.apply(o, arguments), ln(f) && o._r.push(f), en = c, o.selector = h, o.isReverted = false, f;
      };
      return o.last = a, n === ln ? a(o, function(l) {
        return o.add(null, l);
      }) : n ? o[n] = a : a;
    }, e.ignore = function(n) {
      var i = en;
      en = null, n(this), en = i;
    }, e.getTweens = function() {
      var n = [];
      return this.data.forEach(function(i) {
        return i instanceof s ? n.push.apply(n, i.getTweens()) : i instanceof vn && !(i.parent && i.parent.data === "nested") && n.push(i);
      }), n;
    }, e.clear = function() {
      this._r.length = this.data.length = 0;
    }, e.kill = function(n, i) {
      var r = this;
      if (n ? function() {
        for (var a = r.getTweens(), l = r.data.length, c; l--; ) c = r.data[l], c.data === "isFlip" && (c.revert(), c.getChildren(true, true, false).forEach(function(h) {
          return a.splice(a.indexOf(h), 1);
        }));
        for (a.map(function(h) {
          return {
            g: h._dur || h._delay || h._sat && !h._sat.vars.immediateRender ? h.globalTime(0) : -1 / 0,
            t: h
          };
        }).sort(function(h, f) {
          return f.g - h.g || -1 / 0;
        }).forEach(function(h) {
          return h.t.revert(n);
        }), l = r.data.length; l--; ) c = r.data[l], c instanceof qn ? c.data !== "nested" && (c.scrollTrigger && c.scrollTrigger.revert(), c.kill()) : !(c instanceof vn) && c.revert && c.revert(n);
        r._r.forEach(function(h) {
          return h(n, r);
        }), r.isReverted = true;
      }() : this.data.forEach(function(a) {
        return a.kill && a.kill();
      }), this.clear(), i) for (var o = Is.length; o--; ) Is[o].id === this.id && Is.splice(o, 1);
    }, e.revert = function(n) {
      this.kill(n || {});
    }, s;
  }(), Ew = function() {
    function s(t) {
      this.contexts = [], this.scope = t, en && en.data.push(this);
    }
    var e = s.prototype;
    return e.add = function(n, i, r) {
      Ji(n) || (n = {
        matches: n
      });
      var o = new h_(0, r || this.scope), a = o.conditions = {}, l, c, h;
      en && !o.selector && (o.selector = en.selector), this.contexts.push(o), i = o.add("onMatch", i), o.queries = n;
      for (c in n) c === "all" ? h = 1 : (l = Vi.matchMedia(n[c]), l && (Is.indexOf(o) < 0 && Is.push(o), (a[c] = l.matches) && (h = 1), l.addListener ? l.addListener(ff) : l.addEventListener("change", ff)));
      return h && i(o, function(f) {
        return o.add(null, f);
      }), this;
    }, e.revert = function(n) {
      this.kill(n || {});
    }, e.kill = function(n) {
      this.contexts.forEach(function(i) {
        return i.kill(n, true);
      });
    }, s;
  }(), Dc = {
    registerPlugin: function() {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
      t.forEach(function(i) {
        return Kg(i);
      });
    },
    timeline: function(e) {
      return new qn(e);
    },
    getTweensOf: function(e, t) {
      return nn.getTweensOf(e, t);
    },
    getProperty: function(e, t, n, i) {
      Rn(e) && (e = Ei(e)[0]);
      var r = Ps(e || {}).get, o = n ? Fg : Og;
      return n === "native" && (n = ""), e && (t ? o((ui[t] && ui[t].get || r)(e, t, n, i)) : function(a, l, c) {
        return o((ui[a] && ui[a].get || r)(e, a, l, c));
      });
    },
    quickSetter: function(e, t, n) {
      if (e = Ei(e), e.length > 1) {
        var i = e.map(function(h) {
          return ri.quickSetter(h, t, n);
        }), r = i.length;
        return function(h) {
          for (var f = r; f--; ) i[f](h);
        };
      }
      e = e[0] || {};
      var o = ui[t], a = Ps(e), l = a.harness && (a.harness.aliases || {})[t] || t, c = o ? function(h) {
        var f = new o();
        vo._pt = 0, f.init(e, n ? h + n : h, vo, 0, [
          e
        ]), f.render(1, f), vo._pt && sd(1, vo);
      } : a.set(e, l);
      return o ? c : function(h) {
        return c(e, l, n ? h + n : h, a, 1);
      };
    },
    quickTo: function(e, t, n) {
      var i, r = ri.to(e, gi((i = {}, i[t] = "+=0.1", i.paused = true, i.stagger = 0, i), n || {})), o = function(l, c, h) {
        return r.resetTo(t, l, c, h);
      };
      return o.tween = r, o;
    },
    isTweening: function(e) {
      return nn.getTweensOf(e, true).length > 0;
    },
    defaults: function(e) {
      return e && e.ease && (e.ease = Ls(e.ease, ko.ease)), tm(ko, e || {});
    },
    config: function(e) {
      return tm(pi, e || {});
    },
    registerEffect: function(e) {
      var t = e.name, n = e.effect, i = e.plugins, r = e.defaults, o = e.extendTimeline;
      (i || "").split(",").forEach(function(a) {
        return a && !ui[a] && !mi[a] && tl(t + " effect requires " + a + " plugin.");
      }), ju[t] = function(a, l, c) {
        return n(Ei(a), gi(l || {}, r), c);
      }, o && (qn.prototype[t] = function(a, l, c) {
        return this.add(ju[t](a, Ji(l) ? l : (c = l) && {}, this), c);
      });
    },
    registerEase: function(e, t) {
      Pt[e] = Ls(t);
    },
    parseEase: function(e, t) {
      return arguments.length ? Ls(e, t) : Pt;
    },
    getById: function(e) {
      return nn.getById(e);
    },
    exportRoot: function(e, t) {
      e === void 0 && (e = {});
      var n = new qn(e), i, r;
      for (n.smoothChildTiming = ei(e.smoothChildTiming), nn.remove(n), n._dp = 0, n._time = n._tTime = nn._time, i = nn._first; i; ) r = i._next, (t || !(!i._dur && i instanceof vn && i.vars.onComplete === i._targets[0])) && Xi(n, i, i._start - i._delay), i = r;
      return Xi(nn, n, 0), n;
    },
    context: function(e, t) {
      return e ? new h_(e, t) : en;
    },
    matchMedia: function(e) {
      return new Ew(e);
    },
    matchMediaRefresh: function() {
      return Is.forEach(function(e) {
        var t = e.conditions, n, i;
        for (i in t) t[i] && (t[i] = false, n = 1);
        n && e.revert();
      }) || ff();
    },
    addEventListener: function(e, t) {
      var n = mc[e] || (mc[e] = []);
      ~n.indexOf(t) || n.push(t);
    },
    removeEventListener: function(e, t) {
      var n = mc[e], i = n && n.indexOf(t);
      i >= 0 && n.splice(i, 1);
    },
    utils: {
      wrap: iw,
      wrapYoyo: rw,
      distribute: Wg,
      random: qg,
      snap: Xg,
      normalize: nw,
      getUnit: Fn,
      clamp: JE,
      splitColor: Zg,
      toArray: Ei,
      selector: cf,
      mapRange: jg,
      pipe: ew,
      unitize: tw,
      interpolate: sw,
      shuffle: Gg
    },
    install: Dg,
    effects: ju,
    ticker: hi,
    updateRoot: qn.updateRoot,
    plugins: ui,
    globalTimeline: nn,
    core: {
      PropTween: ni,
      globals: Lg,
      Tween: vn,
      Timeline: qn,
      Animation: sl,
      getCache: Ps,
      _removeLinkedListItem: Gc,
      reverting: function() {
        return In;
      },
      context: function(e) {
        return e && en && (en.data.push(e), e._ctx = en), en;
      },
      suppressOverwrites: function(e) {
        return Yf = e;
      }
    }
  };
  ti("to,from,fromTo,delayedCall,set,killTweensOf", function(s) {
    return Dc[s] = vn[s];
  });
  hi.add(qn.updateRoot);
  vo = Dc.to({}, {
    duration: 0
  });
  var ww = function(e, t) {
    for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t; ) n = n._next;
    return n;
  }, Aw = function(e, t) {
    var n = e._targets, i, r, o;
    for (i in t) for (r = n.length; r--; ) o = e._ptLookup[r][i], o && (o = o.d) && (o._pt && (o = ww(o, i)), o && o.modifier && o.modifier(t[i], e, n[r], i));
  }, Qu = function(e, t) {
    return {
      name: e,
      rawVars: 1,
      init: function(i, r, o) {
        o._onInit = function(a) {
          var l, c;
          if (Rn(r) && (l = {}, ti(r, function(h) {
            return l[h] = 1;
          }), r = l), t) {
            l = {};
            for (c in r) l[c] = t(r[c]);
            r = l;
          }
          Aw(a, r);
        };
      }
    };
  }, ri = Dc.registerPlugin({
    name: "attr",
    init: function(e, t, n, i, r) {
      var o, a, l;
      this.tween = n;
      for (o in t) l = e.getAttribute(o) || "", a = this.add(e, "setAttribute", (l || 0) + "", t[o], i, r, 0, 0, o), a.op = o, a.b = l, this._props.push(o);
    },
    render: function(e, t) {
      for (var n = t._pt; n; ) In ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d), n = n._next;
    }
  }, {
    name: "endArray",
    init: function(e, t) {
      for (var n = t.length; n--; ) this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1);
    }
  }, Qu("roundProps", uf), Qu("modifiers"), Qu("snap", Xg)) || Dc;
  vn.version = qn.version = ri.version = "3.12.7";
  Pg = 1;
  $f() && Vo();
  Pt.Power0;
  Pt.Power1;
  Pt.Power2;
  Pt.Power3;
  Pt.Power4;
  Pt.Linear;
  Pt.Quad;
  Pt.Cubic;
  Pt.Quart;
  Pt.Quint;
  Pt.Strong;
  Pt.Elastic;
  Pt.Back;
  Pt.SteppedEase;
  Pt.Bounce;
  Pt.Sine;
  Pt.Expo;
  Pt.Circ;
  var am, Zr, Eo, od, Rs, lm, ad, Cw = function() {
    return typeof window < "u";
  }, Cr = {}, Ss = 180 / Math.PI, wo = Math.PI / 180, co = Math.atan2, cm = 1e8, ld = /([A-Z])/g, Rw = /(left|right|width|margin|padding|x)/i, Pw = /[\s,\(]\S/, Yi = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
  }, df = function(e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
  }, Dw = function(e, t) {
    return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
  }, Lw = function(e, t) {
    return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t);
  }, Iw = function(e, t) {
    var n = t.s + t.c * e;
    t.set(t.t, t.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + t.u, t);
  }, f_ = function(e, t) {
    return t.set(t.t, t.p, e ? t.e : t.b, t);
  }, d_ = function(e, t) {
    return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t);
  }, Nw = function(e, t, n) {
    return e.style[t] = n;
  }, Uw = function(e, t, n) {
    return e.style.setProperty(t, n);
  }, Ow = function(e, t, n) {
    return e._gsap[t] = n;
  }, Fw = function(e, t, n) {
    return e._gsap.scaleX = e._gsap.scaleY = n;
  }, kw = function(e, t, n, i, r) {
    var o = e._gsap;
    o.scaleX = o.scaleY = n, o.renderTransform(r, o);
  }, Bw = function(e, t, n, i, r) {
    var o = e._gsap;
    o[t] = n, o.renderTransform(r, o);
  }, sn = "transform", ii = sn + "Origin", zw = function s(e, t) {
    var n = this, i = this.target, r = i.style, o = i._gsap;
    if (e in Cr && r) {
      if (this.tfm = this.tfm || {}, e !== "transform") e = Yi[e] || e, ~e.indexOf(",") ? e.split(",").forEach(function(a) {
        return n.tfm[a] = yr(i, a);
      }) : this.tfm[e] = o.x ? o[e] : yr(i, e), e === ii && (this.tfm.zOrigin = o.zOrigin);
      else return Yi.transform.split(",").forEach(function(a) {
        return s.call(n, a, t);
      });
      if (this.props.indexOf(sn) >= 0) return;
      o.svg && (this.svgo = i.getAttribute("data-svg-origin"), this.props.push(ii, t, "")), e = sn;
    }
    (r || t) && this.props.push(e, t, r[e]);
  }, p_ = function(e) {
    e.translate && (e.removeProperty("translate"), e.removeProperty("scale"), e.removeProperty("rotate"));
  }, Hw = function() {
    var e = this.props, t = this.target, n = t.style, i = t._gsap, r, o;
    for (r = 0; r < e.length; r += 3) e[r + 1] ? e[r + 1] === 2 ? t[e[r]](e[r + 2]) : t[e[r]] = e[r + 2] : e[r + 2] ? n[e[r]] = e[r + 2] : n.removeProperty(e[r].substr(0, 2) === "--" ? e[r] : e[r].replace(ld, "-$1").toLowerCase());
    if (this.tfm) {
      for (o in this.tfm) i[o] = this.tfm[o];
      i.svg && (i.renderTransform(), t.setAttribute("data-svg-origin", this.svgo || "")), r = ad(), (!r || !r.isStart) && !n[sn] && (p_(n), i.zOrigin && n[ii] && (n[ii] += " " + i.zOrigin + "px", i.zOrigin = 0, i.renderTransform()), i.uncache = 1);
    }
  }, m_ = function(e, t) {
    var n = {
      target: e,
      props: [],
      revert: Hw,
      save: zw
    };
    return e._gsap || ri.core.getCache(e), t && e.style && e.nodeType && t.split(",").forEach(function(i) {
      return n.save(i);
    }), n;
  }, g_, pf = function(e, t) {
    var n = Zr.createElementNS ? Zr.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : Zr.createElement(e);
    return n && n.style ? n : Zr.createElement(e);
  }, Ki = function s(e, t, n) {
    var i = getComputedStyle(e);
    return i[t] || i.getPropertyValue(t.replace(ld, "-$1").toLowerCase()) || i.getPropertyValue(t) || !n && s(e, Go(t) || t, 1) || "";
  }, um = "O,Moz,ms,Ms,Webkit".split(","), Go = function(e, t, n) {
    var i = t || Rs, r = i.style, o = 5;
    if (e in r && !n) return e;
    for (e = e.charAt(0).toUpperCase() + e.substr(1); o-- && !(um[o] + e in r); ) ;
    return o < 0 ? null : (o === 3 ? "ms" : o >= 0 ? um[o] : "") + e;
  }, mf = function() {
    Cw() && window.document && (am = window, Zr = am.document, Eo = Zr.documentElement, Rs = pf("div") || {
      style: {}
    }, pf("div"), sn = Go(sn), ii = sn + "Origin", Rs.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", g_ = !!Go("perspective"), ad = ri.core.reverting, od = 1);
  }, hm = function(e) {
    var t = e.ownerSVGElement, n = pf("svg", t && t.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), i = e.cloneNode(true), r;
    i.style.display = "block", n.appendChild(i), Eo.appendChild(n);
    try {
      r = i.getBBox();
    } catch {
    }
    return n.removeChild(i), Eo.removeChild(n), r;
  }, fm = function(e, t) {
    for (var n = t.length; n--; ) if (e.hasAttribute(t[n])) return e.getAttribute(t[n]);
  }, __ = function(e) {
    var t, n;
    try {
      t = e.getBBox();
    } catch {
      t = hm(e), n = 1;
    }
    return t && (t.width || t.height) || n || (t = hm(e)), t && !t.width && !t.x && !t.y ? {
      x: +fm(e, [
        "x",
        "cx",
        "x1"
      ]) || 0,
      y: +fm(e, [
        "y",
        "cy",
        "y1"
      ]) || 0,
      width: 0,
      height: 0
    } : t;
  }, v_ = function(e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && __(e));
  }, Fs = function(e, t) {
    if (t) {
      var n = e.style, i;
      t in Cr && t !== ii && (t = sn), n.removeProperty ? (i = t.substr(0, 2), (i === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t), n.removeProperty(i === "--" ? t : t.replace(ld, "-$1").toLowerCase())) : n.removeAttribute(t);
    }
  }, Jr = function(e, t, n, i, r, o) {
    var a = new ni(e._pt, t, n, 0, 1, o ? d_ : f_);
    return e._pt = a, a.b = i, a.e = r, e._props.push(n), a;
  }, dm = {
    deg: 1,
    rad: 1,
    turn: 1
  }, Vw = {
    grid: 1,
    flex: 1
  }, is = function s(e, t, n, i) {
    var r = parseFloat(n) || 0, o = (n + "").trim().substr((r + "").length) || "px", a = Rs.style, l = Rw.test(t), c = e.tagName.toLowerCase() === "svg", h = (c ? "client" : "offset") + (l ? "Width" : "Height"), f = 100, m = i === "px", _ = i === "%", y, g, x, v;
    if (i === o || !r || dm[i] || dm[o]) return r;
    if (o !== "px" && !m && (r = s(e, t, n, "px")), v = e.getCTM && v_(e), (_ || o === "%") && (Cr[t] || ~t.indexOf("adius"))) return y = v ? e.getBBox()[l ? "width" : "height"] : e[h], cn(_ ? r / y * f : r / 100 * y);
    if (a[l ? "width" : "height"] = f + (m ? o : i), g = i !== "rem" && ~t.indexOf("adius") || i === "em" && e.appendChild && !c ? e : e.parentNode, v && (g = (e.ownerSVGElement || {}).parentNode), (!g || g === Zr || !g.appendChild) && (g = Zr.body), x = g._gsap, x && _ && x.width && l && x.time === hi.time && !x.uncache) return cn(r / x.width * f);
    if (_ && (t === "height" || t === "width")) {
      var E = e.style[t];
      e.style[t] = f + i, y = e[h], E ? e.style[t] = E : Fs(e, t);
    } else (_ || o === "%") && !Vw[Ki(g, "display")] && (a.position = Ki(e, "position")), g === e && (a.position = "static"), g.appendChild(Rs), y = Rs[h], g.removeChild(Rs), a.position = "absolute";
    return l && _ && (x = Ps(g), x.time = hi.time, x.width = g[h]), cn(m ? y * r / f : y && r ? f / y * r : 0);
  }, yr = function(e, t, n, i) {
    var r;
    return od || mf(), t in Yi && t !== "transform" && (t = Yi[t], ~t.indexOf(",") && (t = t.split(",")[0])), Cr[t] && t !== "transform" ? (r = al(e, i), r = t !== "transformOrigin" ? r[t] : r.svg ? r.origin : Ic(Ki(e, ii)) + " " + r.zOrigin + "px") : (r = e.style[t], (!r || r === "auto" || i || ~(r + "").indexOf("calc(")) && (r = Lc[t] && Lc[t](e, t, n) || Ki(e, t) || Ng(e, t) || (t === "opacity" ? 1 : 0))), n && !~(r + "").trim().indexOf(" ") ? is(e, t, r, n) + n : r;
  }, Gw = function(e, t, n, i) {
    if (!n || n === "none") {
      var r = Go(t, e, 1), o = r && Ki(e, r, 1);
      o && o !== n ? (t = r, n = o) : t === "borderColor" && (n = Ki(e, "borderTopColor"));
    }
    var a = new ni(this._pt, e.style, t, 0, 1, c_), l = 0, c = 0, h, f, m, _, y, g, x, v, E, T, M, P;
    if (a.b = n, a.e = i, n += "", i += "", i === "auto" && (g = e.style[t], e.style[t] = i, i = Ki(e, t) || i, g ? e.style[t] = g : Fs(e, t)), h = [
      n,
      i
    ], Qg(h), n = h[0], i = h[1], m = n.match(_o) || [], P = i.match(_o) || [], P.length) {
      for (; f = _o.exec(i); ) x = f[0], E = i.substring(l, f.index), y ? y = (y + 1) % 5 : (E.substr(-5) === "rgba(" || E.substr(-5) === "hsla(") && (y = 1), x !== (g = m[c++] || "") && (_ = parseFloat(g) || 0, M = g.substr((_ + "").length), x.charAt(1) === "=" && (x = To(_, x) + M), v = parseFloat(x), T = x.substr((v + "").length), l = _o.lastIndex - T.length, T || (T = T || pi.units[t] || M, l === i.length && (i += T, a.e += T)), M !== T && (_ = is(e, t, g, T) || 0), a._pt = {
        _next: a._pt,
        p: E || c === 1 ? E : ",",
        s: _,
        c: v - _,
        m: y && y < 4 || t === "zIndex" ? Math.round : 0
      });
      a.c = l < i.length ? i.substring(l, i.length) : "";
    } else a.r = t === "display" && i === "none" ? d_ : f_;
    return Cg.test(i) && (a.e = 0), this._pt = a, a;
  }, pm = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
  }, Ww = function(e) {
    var t = e.split(" "), n = t[0], i = t[1] || "50%";
    return (n === "top" || n === "bottom" || i === "left" || i === "right") && (e = n, n = i, i = e), t[0] = pm[n] || n, t[1] = pm[i] || i, t.join(" ");
  }, Xw = function(e, t) {
    if (t.tween && t.tween._time === t.tween._dur) {
      var n = t.t, i = n.style, r = t.u, o = n._gsap, a, l, c;
      if (r === "all" || r === true) i.cssText = "", l = 1;
      else for (r = r.split(","), c = r.length; --c > -1; ) a = r[c], Cr[a] && (l = 1, a = a === "transformOrigin" ? ii : sn), Fs(n, a);
      l && (Fs(n, sn), o && (o.svg && n.removeAttribute("transform"), i.scale = i.rotate = i.translate = "none", al(n, 1), o.uncache = 1, p_(i)));
    }
  }, Lc = {
    clearProps: function(e, t, n, i, r) {
      if (r.data !== "isFromStart") {
        var o = e._pt = new ni(e._pt, t, n, 0, 0, Xw);
        return o.u = i, o.pr = -10, o.tween = r, e._props.push(n), 1;
      }
    }
  }, ol = [
    1,
    0,
    0,
    1,
    0,
    0
  ], y_ = {}, x_ = function(e) {
    return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e;
  }, mm = function(e) {
    var t = Ki(e, sn);
    return x_(t) ? ol : t.substr(7).match(Ag).map(cn);
  }, cd = function(e, t) {
    var n = e._gsap || Ps(e), i = e.style, r = mm(e), o, a, l, c;
    return n.svg && e.getAttribute("transform") ? (l = e.transform.baseVal.consolidate().matrix, r = [
      l.a,
      l.b,
      l.c,
      l.d,
      l.e,
      l.f
    ], r.join(",") === "1,0,0,1,0,0" ? ol : r) : (r === ol && !e.offsetParent && e !== Eo && !n.svg && (l = i.display, i.display = "block", o = e.parentNode, (!o || !e.offsetParent && !e.getBoundingClientRect().width) && (c = 1, a = e.nextElementSibling, Eo.appendChild(e)), r = mm(e), l ? i.display = l : Fs(e, "display"), c && (a ? o.insertBefore(e, a) : o ? o.appendChild(e) : Eo.removeChild(e))), t && r.length > 6 ? [
      r[0],
      r[1],
      r[4],
      r[5],
      r[12],
      r[13]
    ] : r);
  }, gf = function(e, t, n, i, r, o) {
    var a = e._gsap, l = r || cd(e, true), c = a.xOrigin || 0, h = a.yOrigin || 0, f = a.xOffset || 0, m = a.yOffset || 0, _ = l[0], y = l[1], g = l[2], x = l[3], v = l[4], E = l[5], T = t.split(" "), M = parseFloat(T[0]) || 0, P = parseFloat(T[1]) || 0, R, d, N, w;
    n ? l !== ol && (d = _ * x - y * g) && (N = M * (x / d) + P * (-g / d) + (g * E - x * v) / d, w = M * (-y / d) + P * (_ / d) - (_ * E - y * v) / d, M = N, P = w) : (R = __(e), M = R.x + (~T[0].indexOf("%") ? M / 100 * R.width : M), P = R.y + (~(T[1] || T[0]).indexOf("%") ? P / 100 * R.height : P)), i || i !== false && a.smooth ? (v = M - c, E = P - h, a.xOffset = f + (v * _ + E * g) - v, a.yOffset = m + (v * y + E * x) - E) : a.xOffset = a.yOffset = 0, a.xOrigin = M, a.yOrigin = P, a.smooth = !!i, a.origin = t, a.originIsAbsolute = !!n, e.style[ii] = "0px 0px", o && (Jr(o, a, "xOrigin", c, M), Jr(o, a, "yOrigin", h, P), Jr(o, a, "xOffset", f, a.xOffset), Jr(o, a, "yOffset", m, a.yOffset)), e.setAttribute("data-svg-origin", M + " " + P);
  }, al = function(e, t) {
    var n = e._gsap || new i_(e);
    if ("x" in n && !t && !n.uncache) return n;
    var i = e.style, r = n.scaleX < 0, o = "px", a = "deg", l = getComputedStyle(e), c = Ki(e, ii) || "0", h, f, m, _, y, g, x, v, E, T, M, P, R, d, N, w, D, B, Z, G, Q, ue, te, he, ie, Me, Ce, Le, Je, dt, ce, ve;
    return h = f = m = g = x = v = E = T = M = 0, _ = y = 1, n.svg = !!(e.getCTM && v_(e)), l.translate && ((l.translate !== "none" || l.scale !== "none" || l.rotate !== "none") && (i[sn] = (l.translate !== "none" ? "translate3d(" + (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") + (l.scale !== "none" ? "scale(" + l.scale.split(" ").join(",") + ") " : "") + (l[sn] !== "none" ? l[sn] : "")), i.scale = i.rotate = i.translate = "none"), d = cd(e, n.svg), n.svg && (n.uncache ? (ie = e.getBBox(), c = n.xOrigin - ie.x + "px " + (n.yOrigin - ie.y) + "px", he = "") : he = !t && e.getAttribute("data-svg-origin"), gf(e, he || c, !!he || n.originIsAbsolute, n.smooth !== false, d)), P = n.xOrigin || 0, R = n.yOrigin || 0, d !== ol && (B = d[0], Z = d[1], G = d[2], Q = d[3], h = ue = d[4], f = te = d[5], d.length === 6 ? (_ = Math.sqrt(B * B + Z * Z), y = Math.sqrt(Q * Q + G * G), g = B || Z ? co(Z, B) * Ss : 0, E = G || Q ? co(G, Q) * Ss + g : 0, E && (y *= Math.abs(Math.cos(E * wo))), n.svg && (h -= P - (P * B + R * G), f -= R - (P * Z + R * Q))) : (ve = d[6], dt = d[7], Ce = d[8], Le = d[9], Je = d[10], ce = d[11], h = d[12], f = d[13], m = d[14], N = co(ve, Je), x = N * Ss, N && (w = Math.cos(-N), D = Math.sin(-N), he = ue * w + Ce * D, ie = te * w + Le * D, Me = ve * w + Je * D, Ce = ue * -D + Ce * w, Le = te * -D + Le * w, Je = ve * -D + Je * w, ce = dt * -D + ce * w, ue = he, te = ie, ve = Me), N = co(-G, Je), v = N * Ss, N && (w = Math.cos(-N), D = Math.sin(-N), he = B * w - Ce * D, ie = Z * w - Le * D, Me = G * w - Je * D, ce = Q * D + ce * w, B = he, Z = ie, G = Me), N = co(Z, B), g = N * Ss, N && (w = Math.cos(N), D = Math.sin(N), he = B * w + Z * D, ie = ue * w + te * D, Z = Z * w - B * D, te = te * w - ue * D, B = he, ue = ie), x && Math.abs(x) + Math.abs(g) > 359.9 && (x = g = 0, v = 180 - v), _ = cn(Math.sqrt(B * B + Z * Z + G * G)), y = cn(Math.sqrt(te * te + ve * ve)), N = co(ue, te), E = Math.abs(N) > 2e-4 ? N * Ss : 0, M = ce ? 1 / (ce < 0 ? -ce : ce) : 0), n.svg && (he = e.getAttribute("transform"), n.forceCSS = e.setAttribute("transform", "") || !x_(Ki(e, sn)), he && e.setAttribute("transform", he))), Math.abs(E) > 90 && Math.abs(E) < 270 && (r ? (_ *= -1, E += g <= 0 ? 180 : -180, g += g <= 0 ? 180 : -180) : (y *= -1, E += E <= 0 ? 180 : -180)), t = t || n.uncache, n.x = h - ((n.xPercent = h && (!t && n.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-h) ? -50 : 0))) ? e.offsetWidth * n.xPercent / 100 : 0) + o, n.y = f - ((n.yPercent = f && (!t && n.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-f) ? -50 : 0))) ? e.offsetHeight * n.yPercent / 100 : 0) + o, n.z = m + o, n.scaleX = cn(_), n.scaleY = cn(y), n.rotation = cn(g) + a, n.rotationX = cn(x) + a, n.rotationY = cn(v) + a, n.skewX = E + a, n.skewY = T + a, n.transformPerspective = M + o, (n.zOrigin = parseFloat(c.split(" ")[2]) || !t && n.zOrigin || 0) && (i[ii] = Ic(c)), n.xOffset = n.yOffset = 0, n.force3D = pi.force3D, n.renderTransform = n.svg ? Yw : g_ ? b_ : qw, n.uncache = 0, n;
  }, Ic = function(e) {
    return (e = e.split(" "))[0] + " " + e[1];
  }, eh = function(e, t, n) {
    var i = Fn(t);
    return cn(parseFloat(t) + parseFloat(is(e, "x", n + "px", i))) + i;
  }, qw = function(e, t) {
    t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, b_(e, t);
  }, vs = "0deg", Ca = "0px", ys = ") ", b_ = function(e, t) {
    var n = t || this, i = n.xPercent, r = n.yPercent, o = n.x, a = n.y, l = n.z, c = n.rotation, h = n.rotationY, f = n.rotationX, m = n.skewX, _ = n.skewY, y = n.scaleX, g = n.scaleY, x = n.transformPerspective, v = n.force3D, E = n.target, T = n.zOrigin, M = "", P = v === "auto" && e && e !== 1 || v === true;
    if (T && (f !== vs || h !== vs)) {
      var R = parseFloat(h) * wo, d = Math.sin(R), N = Math.cos(R), w;
      R = parseFloat(f) * wo, w = Math.cos(R), o = eh(E, o, d * w * -T), a = eh(E, a, -Math.sin(R) * -T), l = eh(E, l, N * w * -T + T);
    }
    x !== Ca && (M += "perspective(" + x + ys), (i || r) && (M += "translate(" + i + "%, " + r + "%) "), (P || o !== Ca || a !== Ca || l !== Ca) && (M += l !== Ca || P ? "translate3d(" + o + ", " + a + ", " + l + ") " : "translate(" + o + ", " + a + ys), c !== vs && (M += "rotate(" + c + ys), h !== vs && (M += "rotateY(" + h + ys), f !== vs && (M += "rotateX(" + f + ys), (m !== vs || _ !== vs) && (M += "skew(" + m + ", " + _ + ys), (y !== 1 || g !== 1) && (M += "scale(" + y + ", " + g + ys), E.style[sn] = M || "translate(0, 0)";
  }, Yw = function(e, t) {
    var n = t || this, i = n.xPercent, r = n.yPercent, o = n.x, a = n.y, l = n.rotation, c = n.skewX, h = n.skewY, f = n.scaleX, m = n.scaleY, _ = n.target, y = n.xOrigin, g = n.yOrigin, x = n.xOffset, v = n.yOffset, E = n.forceCSS, T = parseFloat(o), M = parseFloat(a), P, R, d, N, w;
    l = parseFloat(l), c = parseFloat(c), h = parseFloat(h), h && (h = parseFloat(h), c += h, l += h), l || c ? (l *= wo, c *= wo, P = Math.cos(l) * f, R = Math.sin(l) * f, d = Math.sin(l - c) * -m, N = Math.cos(l - c) * m, c && (h *= wo, w = Math.tan(c - h), w = Math.sqrt(1 + w * w), d *= w, N *= w, h && (w = Math.tan(h), w = Math.sqrt(1 + w * w), P *= w, R *= w)), P = cn(P), R = cn(R), d = cn(d), N = cn(N)) : (P = f, N = m, R = d = 0), (T && !~(o + "").indexOf("px") || M && !~(a + "").indexOf("px")) && (T = is(_, "x", o, "px"), M = is(_, "y", a, "px")), (y || g || x || v) && (T = cn(T + y - (y * P + g * d) + x), M = cn(M + g - (y * R + g * N) + v)), (i || r) && (w = _.getBBox(), T = cn(T + i / 100 * w.width), M = cn(M + r / 100 * w.height)), w = "matrix(" + P + "," + R + "," + d + "," + N + "," + T + "," + M + ")", _.setAttribute("transform", w), E && (_.style[sn] = w);
  }, jw = function(e, t, n, i, r) {
    var o = 360, a = Rn(r), l = parseFloat(r) * (a && ~r.indexOf("rad") ? Ss : 1), c = l - i, h = i + c + "deg", f, m;
    return a && (f = r.split("_")[1], f === "short" && (c %= o, c !== c % (o / 2) && (c += c < 0 ? o : -360)), f === "cw" && c < 0 ? c = (c + o * cm) % o - ~~(c / o) * o : f === "ccw" && c > 0 && (c = (c - o * cm) % o - ~~(c / o) * o)), e._pt = m = new ni(e._pt, t, n, i, c, Dw), m.e = h, m.u = "deg", e._props.push(n), m;
  }, gm = function(e, t) {
    for (var n in t) e[n] = t[n];
    return e;
  }, $w = function(e, t, n) {
    var i = gm({}, n._gsap), r = "perspective,force3D,transformOrigin,svgOrigin", o = n.style, a, l, c, h, f, m, _, y;
    i.svg ? (c = n.getAttribute("transform"), n.setAttribute("transform", ""), o[sn] = t, a = al(n, 1), Fs(n, sn), n.setAttribute("transform", c)) : (c = getComputedStyle(n)[sn], o[sn] = t, a = al(n, 1), o[sn] = c);
    for (l in Cr) c = i[l], h = a[l], c !== h && r.indexOf(l) < 0 && (_ = Fn(c), y = Fn(h), f = _ !== y ? is(n, l, c, y) : parseFloat(c), m = parseFloat(h), e._pt = new ni(e._pt, a, l, f, m - f, df), e._pt.u = y || 0, e._props.push(l));
    gm(a, i);
  };
  ti("padding,margin,Width,Radius", function(s, e) {
    var t = "Top", n = "Right", i = "Bottom", r = "Left", o = (e < 3 ? [
      t,
      n,
      i,
      r
    ] : [
      t + r,
      t + n,
      i + n,
      i + r
    ]).map(function(a) {
      return e < 2 ? s + a : "border" + a + s;
    });
    Lc[e > 1 ? "border" + s : s] = function(a, l, c, h, f) {
      var m, _;
      if (arguments.length < 4) return m = o.map(function(y) {
        return yr(a, y, c);
      }), _ = m.join(" "), _.split(m[0]).length === 5 ? m[0] : _;
      m = (h + "").split(" "), _ = {}, o.forEach(function(y, g) {
        return _[y] = m[g] = m[g] || m[(g - 1) / 2 | 0];
      }), a.init(l, _, f);
    };
  });
  var S_ = {
    name: "css",
    register: mf,
    targetTest: function(e) {
      return e.style && e.nodeType;
    },
    init: function(e, t, n, i, r) {
      var o = this._props, a = e.style, l = n.vars.startAt, c, h, f, m, _, y, g, x, v, E, T, M, P, R, d, N;
      od || mf(), this.styles = this.styles || m_(e), N = this.styles.props, this.tween = n;
      for (g in t) if (g !== "autoRound" && (h = t[g], !(ui[g] && r_(g, t, n, i, e, r)))) {
        if (_ = typeof h, y = Lc[g], _ === "function" && (h = h.call(n, i, e, r), _ = typeof h), _ === "string" && ~h.indexOf("random(") && (h = il(h)), y) y(this, e, g, h, n) && (d = 1);
        else if (g.substr(0, 2) === "--") c = (getComputedStyle(e).getPropertyValue(g) + "").trim(), h += "", ts.lastIndex = 0, ts.test(c) || (x = Fn(c), v = Fn(h)), v ? x !== v && (c = is(e, g, c, v) + v) : x && (h += x), this.add(a, "setProperty", c, h, i, r, 0, 0, g), o.push(g), N.push(g, 0, a[g]);
        else if (_ !== "undefined") {
          if (l && g in l ? (c = typeof l[g] == "function" ? l[g].call(n, i, e, r) : l[g], Rn(c) && ~c.indexOf("random(") && (c = il(c)), Fn(c + "") || c === "auto" || (c += pi.units[g] || Fn(yr(e, g)) || ""), (c + "").charAt(1) === "=" && (c = yr(e, g))) : c = yr(e, g), m = parseFloat(c), E = _ === "string" && h.charAt(1) === "=" && h.substr(0, 2), E && (h = h.substr(2)), f = parseFloat(h), g in Yi && (g === "autoAlpha" && (m === 1 && yr(e, "visibility") === "hidden" && f && (m = 0), N.push("visibility", 0, a.visibility), Jr(this, a, "visibility", m ? "inherit" : "hidden", f ? "inherit" : "hidden", !f)), g !== "scale" && g !== "transform" && (g = Yi[g], ~g.indexOf(",") && (g = g.split(",")[0]))), T = g in Cr, T) {
            if (this.styles.save(g), M || (P = e._gsap, P.renderTransform && !t.parseTransform || al(e, t.parseTransform), R = t.smoothOrigin !== false && P.smooth, M = this._pt = new ni(this._pt, a, sn, 0, 1, P.renderTransform, P, 0, -1), M.dep = 1), g === "scale") this._pt = new ni(this._pt, P, "scaleY", P.scaleY, (E ? To(P.scaleY, E + f) : f) - P.scaleY || 0, df), this._pt.u = 0, o.push("scaleY", g), g += "X";
            else if (g === "transformOrigin") {
              N.push(ii, 0, a[ii]), h = Ww(h), P.svg ? gf(e, h, 0, R, 0, this) : (v = parseFloat(h.split(" ")[2]) || 0, v !== P.zOrigin && Jr(this, P, "zOrigin", P.zOrigin, v), Jr(this, a, g, Ic(c), Ic(h)));
              continue;
            } else if (g === "svgOrigin") {
              gf(e, h, 1, R, 0, this);
              continue;
            } else if (g in y_) {
              jw(this, P, g, m, E ? To(m, E + h) : h);
              continue;
            } else if (g === "smoothOrigin") {
              Jr(this, P, "smooth", P.smooth, h);
              continue;
            } else if (g === "force3D") {
              P[g] = h;
              continue;
            } else if (g === "transform") {
              $w(this, h, e);
              continue;
            }
          } else g in a || (g = Go(g) || g);
          if (T || (f || f === 0) && (m || m === 0) && !Pw.test(h) && g in a) x = (c + "").substr((m + "").length), f || (f = 0), v = Fn(h) || (g in pi.units ? pi.units[g] : x), x !== v && (m = is(e, g, c, v)), this._pt = new ni(this._pt, T ? P : a, g, m, (E ? To(m, E + f) : f) - m, !T && (v === "px" || g === "zIndex") && t.autoRound !== false ? Iw : df), this._pt.u = v || 0, x !== v && v !== "%" && (this._pt.b = c, this._pt.r = Lw);
          else if (g in a) Gw.call(this, e, g, c, E ? E + h : h);
          else if (g in e) this.add(e, g, c || e[g], E ? E + h : h, i, r);
          else if (g !== "parseTransform") {
            Zf(g, h);
            continue;
          }
          T || (g in a ? N.push(g, 0, a[g]) : typeof e[g] == "function" ? N.push(g, 2, e[g]()) : N.push(g, 1, c || e[g])), o.push(g);
        }
      }
      d && u_(this);
    },
    render: function(e, t) {
      if (t.tween._time || !ad()) for (var n = t._pt; n; ) n.r(e, n.d), n = n._next;
      else t.styles.revert();
    },
    get: yr,
    aliases: Yi,
    getSetter: function(e, t, n) {
      var i = Yi[t];
      return i && i.indexOf(",") < 0 && (t = i), t in Cr && t !== ii && (e._gsap.x || yr(e, "x")) ? n && lm === n ? t === "scale" ? Fw : Ow : (lm = n || {}) && (t === "scale" ? kw : Bw) : e.style && !jf(e.style[t]) ? Nw : ~t.indexOf("-") ? Uw : rd(e, t);
    },
    core: {
      _removeProperty: Fs,
      _getMatrix: cd
    }
  };
  ri.utils.checkPrefix = Go;
  ri.core.getStyleSaver = m_;
  (function(s, e, t, n) {
    var i = ti(s + "," + e + "," + t, function(r) {
      Cr[r] = 1;
    });
    ti(e, function(r) {
      pi.units[r] = "deg", y_[r] = 1;
    }), Yi[i[13]] = s + "," + e, ti(n, function(r) {
      var o = r.split(":");
      Yi[o[1]] = i[o[0]];
    });
  })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
  ti("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(s) {
    pi.units[s] = "px";
  });
  ri.registerPlugin(S_);
  un = ri.registerPlugin(S_) || ri;
  un.core.Tween;
  const th = /* @__PURE__ */ new Map(), ud = [], Wo = new zs(), gc = new Se();
  let mn = null;
  const nh = new Se(), Vs = [];
  async function Nc(s) {
    return await (await fetch(s)).text();
  }
  async function _f(s, e, t, n = 1.5, i) {
    return new Promise((r, o) => {
      new Xf().load("/res/font/GenosThin_Regular.json", async (l) => {
        try {
          const c = new qf(s, {
            font: l,
            size: n,
            depth: 0.05,
            curveSegments: 12,
            bevelEnabled: true,
            bevelThickness: 0.03,
            bevelSize: 0.02,
            bevelOffset: 0,
            bevelSegments: 5
          }), h = await Nc("/res/shaders/textVertexShader.glsl"), f = await Nc("/res/shaders/textFragmentShader.glsl"), m = new kn({
            uniforms: {
              textColor: {
                value: new it(249 / 255, 159 / 255, 0 / 255)
              },
              opacity: {
                value: 1
              }
            },
            vertexShader: h,
            fragmentShader: f,
            transparent: true
          }), _ = new hn(c, m);
          _.position.set(e.x, e.y, e.z), _.rotation.set(t.x, t.y, t.z), i.add(_), r(_);
        } catch (c) {
          o(c);
        }
      }, void 0, o);
    });
  }
  function qc(s, e, t, n, i, r, o, a) {
    if (th.has(s)) {
      const c = th.get(s);
      return c.position.set(t.x, t.y, t.z), c.scale.set(n, n, n), c.rotation.set(i.x, i.y, i.z), o.add(c), _m(c, r), a && a(c), c;
    }
    new JT().load(e, (c) => {
      const h = c.scene;
      h.position.set(t.x, t.y, t.z), h.scale.set(n, n, n), h.rotation.set(i.x, i.y, i.z), h.traverse((f) => {
        f.isMesh && f.geometry.computeBoundingSphere();
      }), th.set(s, h), o.add(h), _m(h, r), a && a(h);
    }, void 0, (c) => {
      console.error(`Error loading model ${s}:`, c);
    });
  }
  function _m(s, e) {
    (e == null ? void 0 : e.position) && un.to(s.position, {
      x: e.position.x,
      y: e.position.y,
      z: e.position.z,
      duration: e.position.duration || 3,
      ease: e.position.ease || "power2.out"
    }), (e == null ? void 0 : e.rotation) && un.to(s.rotation, {
      x: s.rotation.x + (e.rotation.x || 0),
      y: s.rotation.y + (e.rotation.y || 0),
      z: s.rotation.z + (e.rotation.z || 0),
      duration: e.rotation.duration || 45,
      ease: e.rotation.ease || "linear",
      repeat: e.rotation.repeat ?? -1
    });
  }
  function Kw(s, e, t, n) {
    const i = new jr();
    i.position.set(e.x, e.y, e.z), i.rotation.set(t.x, t.y, t.z);
    const r = 1.2, o = 0;
    s.forEach((a, l) => {
      const c = {
        x: 0,
        y: o - l * r,
        z: 0
      }, h = M_(a.text, c, n, a.onClick);
      i.add(h);
    }), n.add(i);
  }
  function M_(s, e, t, n, i = 0.5) {
    const r = new Xf(), o = new hn();
    return r.load("/res/font/GenosThin_Regular.json", (a) => {
      const l = new qf(s, {
        font: a,
        size: i,
        depth: 0.05,
        curveSegments: 12,
        bevelEnabled: true,
        bevelThickness: 0.03,
        bevelSize: 0.02,
        bevelOffset: 0,
        bevelSegments: 5
      }), c = new Yo({
        color: 16777215,
        transparent: true,
        opacity: 1,
        emissive: 0,
        metalness: 0,
        roughness: 1
      });
      o.geometry = l, o.material = c, o.position.set(e.x + 1, e.y - 1.25, e.z), o.userData.onClick = n, o.userData.originalColor = c.color.getHex(), ud.push(o), un.to(c, {
        opacity: 1,
        duration: 2,
        delay: Math.abs(e.y) * 0.15,
        ease: "power2.out"
      });
    }), o;
  }
  function Zw(s, e, t) {
    const n = t.domElement.getBoundingClientRect();
    gc.x = (s.clientX - n.left) / n.width * 2 - 1, gc.y = -((s.clientY - n.top) / n.height) * 2 + 1, Wo.setFromCamera(gc, e);
    const i = Wo.intersectObjects(ud);
    if (i.length > 0) {
      const r = i[0].object;
      mn !== r && (mn && (un.to(mn.material.color, {
        r: (mn.userData.originalColor >> 16 & 255) / 255,
        g: (mn.userData.originalColor >> 8 & 255) / 255,
        b: (mn.userData.originalColor & 255) / 255,
        duration: 0.3
      }), un.to(mn.scale, {
        x: 1,
        y: 1,
        z: 1,
        duration: 0.3
      })), mn = r, document.body.style.cursor = "pointer", mn.userData.originalColorStored || (mn.userData.originalColor = mn.material.color.getHex(), mn.userData.originalColorStored = true), un.to(mn.material.color, {
        r: 1,
        g: 0.5,
        b: 0,
        duration: 0.3
      }));
    } else mn && (un.to(mn.material.color, {
      r: (mn.userData.originalColor >> 16 & 255) / 255,
      g: (mn.userData.originalColor >> 8 & 255) / 255,
      b: (mn.userData.originalColor & 255) / 255,
      duration: 0.3
    }), un.to(mn.scale, {
      x: 1,
      y: 1,
      z: 1,
      duration: 0.3
    }), mn = null), document.body.style.cursor = "default";
  }
  function Jw(s, e) {
    Wo.setFromCamera(gc, e);
    const t = Wo.intersectObjects(ud);
    if (t.length > 0) {
      const n = t[0].object;
      n.userData.onClick && n.userData.onClick();
    }
  }
  function Qw(s, e, t) {
    window.addEventListener("mousemove", (n) => Zw(n, s, t)), window.addEventListener("click", (n) => Jw(n, s));
  }
  function Uc(s, e) {
    s.traverse((t) => {
      t.isMesh && (t.userData.onClick = e, Vs.push(t));
    });
  }
  function e1(s, e) {
    window.addEventListener("click", (t) => {
      const n = e.domElement.getBoundingClientRect();
      nh.x = (t.clientX - n.left) / n.width * 2 - 1, nh.y = -((t.clientY - n.top) / n.height) * 2 + 1, Wo.setFromCamera(nh, s);
      const i = Wo.intersectObjects(Vs, true);
      if (i.length > 0) {
        const r = i[0].object;
        r.userData.onClick && r.userData.onClick();
      }
    });
  }
  async function Zo(s, e, t, n = 0.7, i, r) {
    return new Promise((o, a) => {
      new Xf().load("/res/font/Roboto_Regular.json", async (c) => {
        try {
          const h = new qf(s, {
            font: c,
            size: n,
            depth: 0.05,
            curveSegments: 12,
            bevelEnabled: true,
            bevelThickness: 0.03,
            bevelSize: 0.02,
            bevelOffset: 0,
            bevelSegments: 5
          });
          h.computeBoundingBox(), h.center();
          const f = await Nc("/res/shaders/textVertexShader.glsl"), m = await Nc("/res/shaders/textFragmentShader.glsl"), _ = new kn({
            uniforms: {
              textColor: {
                value: new it(249 / 255, 159 / 255, 0 / 255)
              }
            },
            vertexShader: f,
            fragmentShader: m
          }), y = new hn(h, _);
          y.position.set(e.x, e.y, e.z + 0.02), y.rotation.set(t.x, t.y, t.z), i.add(y);
          const g = h.boundingBox.getSize(new V()), x = 0.3, v = new ks(g.x + x, g.y + x, 0.2), E = new Yo({
            color: 0,
            transparent: true,
            opacity: 0.05,
            emissive: new it(0),
            emissiveIntensity: 1
          }), T = new hn(v, E);
          T.position.set(e.x, e.y, e.z), T.rotation.set(t.x, t.y, t.z), T.name = `button-${s.replace(/\s+/g, "-")}`, r && Uc(T, r), i.add(T), o({
            textMesh: y,
            buttonMesh: T
          });
        } catch (h) {
          a(h);
        }
      }, void 0, a);
    });
  }
  function hd(s, e = {}) {
    if (!s || !s.material || !("emissive" in s.material)) return;
    const { color: t = "#ff9900", intensity: n = 1.5 } = e;
    s.material.emissive = new it(t), s.material.emissiveIntensity = n, s.material.needsUpdate = true;
  }
  const T_ = {
    name: "CopyShader",
    uniforms: {
      tDiffuse: {
        value: null
      },
      opacity: {
        value: 1
      }
    },
    vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
    fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
  };
  class pl {
    constructor() {
      this.isPass = true, this.enabled = true, this.needsSwap = true, this.clear = false, this.renderToScreen = false;
    }
    setSize() {
    }
    render() {
      console.error("THREE.Pass: .render() must be implemented in derived pass.");
    }
    dispose() {
    }
  }
  const t1 = new Hc(-1, 1, 1, -1, 0, 1);
  class n1 extends si {
    constructor() {
      super(), this.setAttribute("position", new Ln([
        -1,
        3,
        0,
        -1,
        -1,
        0,
        3,
        -1,
        0
      ], 3)), this.setAttribute("uv", new Ln([
        0,
        2,
        0,
        0,
        2,
        0
      ], 2));
    }
  }
  const i1 = new n1();
  class E_ {
    constructor(e) {
      this._mesh = new hn(i1, e);
    }
    dispose() {
      this._mesh.geometry.dispose();
    }
    render(e) {
      e.render(this._mesh, t1);
    }
    get material() {
      return this._mesh.material;
    }
    set material(e) {
      this._mesh.material = e;
    }
  }
  class r1 extends pl {
    constructor(e, t) {
      super(), this.textureID = t !== void 0 ? t : "tDiffuse", e instanceof kn ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = Tc.clone(e.uniforms), this.material = new kn({
        name: e.name !== void 0 ? e.name : "unspecified",
        defines: Object.assign({}, e.defines),
        uniforms: this.uniforms,
        vertexShader: e.vertexShader,
        fragmentShader: e.fragmentShader
      })), this.fsQuad = new E_(this.material);
    }
    render(e, t, n) {
      this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
    }
    dispose() {
      this.material.dispose(), this.fsQuad.dispose();
    }
  }
  class vm extends pl {
    constructor(e, t) {
      super(), this.scene = e, this.camera = t, this.clear = true, this.needsSwap = false, this.inverse = false;
    }
    render(e, t, n) {
      const i = e.getContext(), r = e.state;
      r.buffers.color.setMask(false), r.buffers.depth.setMask(false), r.buffers.color.setLocked(true), r.buffers.depth.setLocked(true);
      let o, a;
      this.inverse ? (o = 0, a = 1) : (o = 1, a = 0), r.buffers.stencil.setTest(true), r.buffers.stencil.setOp(i.REPLACE, i.REPLACE, i.REPLACE), r.buffers.stencil.setFunc(i.ALWAYS, o, 4294967295), r.buffers.stencil.setClear(a), r.buffers.stencil.setLocked(true), e.setRenderTarget(n), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(t), this.clear && e.clear(), e.render(this.scene, this.camera), r.buffers.color.setLocked(false), r.buffers.depth.setLocked(false), r.buffers.color.setMask(true), r.buffers.depth.setMask(true), r.buffers.stencil.setLocked(false), r.buffers.stencil.setFunc(i.EQUAL, 1, 4294967295), r.buffers.stencil.setOp(i.KEEP, i.KEEP, i.KEEP), r.buffers.stencil.setLocked(true);
    }
  }
  class s1 extends pl {
    constructor() {
      super(), this.needsSwap = false;
    }
    render(e) {
      e.state.buffers.stencil.setLocked(false), e.state.buffers.stencil.setTest(false);
    }
  }
  class o1 {
    constructor(e, t) {
      if (this.renderer = e, this._pixelRatio = e.getPixelRatio(), t === void 0) {
        const n = e.getSize(new Se());
        this._width = n.width, this._height = n.height, t = new Ui(this._width * this._pixelRatio, this._height * this._pixelRatio, {
          type: Mr
        }), t.texture.name = "EffectComposer.rt1";
      } else this._width = t.width, this._height = t.height;
      this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = true, this.passes = [], this.copyPass = new r1(T_), this.copyPass.material.blending = Sr, this.clock = new sx();
    }
    swapBuffers() {
      const e = this.readBuffer;
      this.readBuffer = this.writeBuffer, this.writeBuffer = e;
    }
    addPass(e) {
      this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    insertPass(e, t) {
      this.passes.splice(t, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    removePass(e) {
      const t = this.passes.indexOf(e);
      t !== -1 && this.passes.splice(t, 1);
    }
    isLastEnabledPass(e) {
      for (let t = e + 1; t < this.passes.length; t++) if (this.passes[t].enabled) return false;
      return true;
    }
    render(e) {
      e === void 0 && (e = this.clock.getDelta());
      const t = this.renderer.getRenderTarget();
      let n = false;
      for (let i = 0, r = this.passes.length; i < r; i++) {
        const o = this.passes[i];
        if (o.enabled !== false) {
          if (o.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i), o.render(this.renderer, this.writeBuffer, this.readBuffer, e, n), o.needsSwap) {
            if (n) {
              const a = this.renderer.getContext(), l = this.renderer.state.buffers.stencil;
              l.setFunc(a.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), l.setFunc(a.EQUAL, 1, 4294967295);
            }
            this.swapBuffers();
          }
          vm !== void 0 && (o instanceof vm ? n = true : o instanceof s1 && (n = false));
        }
      }
      this.renderer.setRenderTarget(t);
    }
    reset(e) {
      if (e === void 0) {
        const t = this.renderer.getSize(new Se());
        this._pixelRatio = this.renderer.getPixelRatio(), this._width = t.width, this._height = t.height, e = this.renderTarget1.clone(), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
      }
      this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
    }
    setSize(e, t) {
      this._width = e, this._height = t;
      const n = this._width * this._pixelRatio, i = this._height * this._pixelRatio;
      this.renderTarget1.setSize(n, i), this.renderTarget2.setSize(n, i);
      for (let r = 0; r < this.passes.length; r++) this.passes[r].setSize(n, i);
    }
    setPixelRatio(e) {
      this._pixelRatio = e, this.setSize(this._width, this._height);
    }
    dispose() {
      this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
    }
  }
  class a1 extends pl {
    constructor(e, t, n = null, i = null, r = null) {
      super(), this.scene = e, this.camera = t, this.overrideMaterial = n, this.clearColor = i, this.clearAlpha = r, this.clear = true, this.clearDepth = false, this.needsSwap = false, this._oldClearColor = new it();
    }
    render(e, t, n) {
      const i = e.autoClear;
      e.autoClear = false;
      let r, o;
      this.overrideMaterial !== null && (o = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor !== null && (e.getClearColor(this._oldClearColor), e.setClearColor(this.clearColor, e.getClearAlpha())), this.clearAlpha !== null && (r = e.getClearAlpha(), e.setClearAlpha(this.clearAlpha)), this.clearDepth == true && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : n), this.clear === true && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor !== null && e.setClearColor(this._oldClearColor), this.clearAlpha !== null && e.setClearAlpha(r), this.overrideMaterial !== null && (this.scene.overrideMaterial = o), e.autoClear = i;
    }
  }
  const l1 = {
    uniforms: {
      tDiffuse: {
        value: null
      },
      luminosityThreshold: {
        value: 1
      },
      smoothWidth: {
        value: 1
      },
      defaultColor: {
        value: new it(0)
      },
      defaultOpacity: {
        value: 0
      }
    },
    vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
    fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			float v = luminance( texel.xyz );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`
  };
  class Xo extends pl {
    constructor(e, t, n, i) {
      super(), this.strength = t !== void 0 ? t : 1, this.radius = n, this.threshold = i, this.resolution = e !== void 0 ? new Se(e.x, e.y) : new Se(256, 256), this.clearColor = new it(0, 0, 0), this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5;
      let r = Math.round(this.resolution.x / 2), o = Math.round(this.resolution.y / 2);
      this.renderTargetBright = new Ui(r, o, {
        type: Mr
      }), this.renderTargetBright.texture.name = "UnrealBloomPass.bright", this.renderTargetBright.texture.generateMipmaps = false;
      for (let f = 0; f < this.nMips; f++) {
        const m = new Ui(r, o, {
          type: Mr
        });
        m.texture.name = "UnrealBloomPass.h" + f, m.texture.generateMipmaps = false, this.renderTargetsHorizontal.push(m);
        const _ = new Ui(r, o, {
          type: Mr
        });
        _.texture.name = "UnrealBloomPass.v" + f, _.texture.generateMipmaps = false, this.renderTargetsVertical.push(_), r = Math.round(r / 2), o = Math.round(o / 2);
      }
      const a = l1;
      this.highPassUniforms = Tc.clone(a.uniforms), this.highPassUniforms.luminosityThreshold.value = i, this.highPassUniforms.smoothWidth.value = 0.01, this.materialHighPassFilter = new kn({
        uniforms: this.highPassUniforms,
        vertexShader: a.vertexShader,
        fragmentShader: a.fragmentShader
      }), this.separableBlurMaterials = [];
      const l = [
        3,
        5,
        7,
        9,
        11
      ];
      r = Math.round(this.resolution.x / 2), o = Math.round(this.resolution.y / 2);
      for (let f = 0; f < this.nMips; f++) this.separableBlurMaterials.push(this.getSeparableBlurMaterial(l[f])), this.separableBlurMaterials[f].uniforms.invSize.value = new Se(1 / r, 1 / o), r = Math.round(r / 2), o = Math.round(o / 2);
      this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = t, this.compositeMaterial.uniforms.bloomRadius.value = 0.1;
      const c = [
        1,
        0.8,
        0.6,
        0.4,
        0.2
      ];
      this.compositeMaterial.uniforms.bloomFactors.value = c, this.bloomTintColors = [
        new V(1, 1, 1),
        new V(1, 1, 1),
        new V(1, 1, 1),
        new V(1, 1, 1),
        new V(1, 1, 1)
      ], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors;
      const h = T_;
      this.copyUniforms = Tc.clone(h.uniforms), this.blendMaterial = new kn({
        uniforms: this.copyUniforms,
        vertexShader: h.vertexShader,
        fragmentShader: h.fragmentShader,
        blending: xc,
        depthTest: false,
        depthWrite: false,
        transparent: true
      }), this.enabled = true, this.needsSwap = false, this._oldClearColor = new it(), this.oldClearAlpha = 1, this.basic = new qi(), this.fsQuad = new E_(null);
    }
    dispose() {
      for (let e = 0; e < this.renderTargetsHorizontal.length; e++) this.renderTargetsHorizontal[e].dispose();
      for (let e = 0; e < this.renderTargetsVertical.length; e++) this.renderTargetsVertical[e].dispose();
      this.renderTargetBright.dispose();
      for (let e = 0; e < this.separableBlurMaterials.length; e++) this.separableBlurMaterials[e].dispose();
      this.compositeMaterial.dispose(), this.blendMaterial.dispose(), this.basic.dispose(), this.fsQuad.dispose();
    }
    setSize(e, t) {
      let n = Math.round(e / 2), i = Math.round(t / 2);
      this.renderTargetBright.setSize(n, i);
      for (let r = 0; r < this.nMips; r++) this.renderTargetsHorizontal[r].setSize(n, i), this.renderTargetsVertical[r].setSize(n, i), this.separableBlurMaterials[r].uniforms.invSize.value = new Se(1 / n, 1 / i), n = Math.round(n / 2), i = Math.round(i / 2);
    }
    render(e, t, n, i, r) {
      e.getClearColor(this._oldClearColor), this.oldClearAlpha = e.getClearAlpha();
      const o = e.autoClear;
      e.autoClear = false, e.setClearColor(this.clearColor, 0), r && e.state.buffers.stencil.setTest(false), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = n.texture, e.setRenderTarget(null), e.clear(), this.fsQuad.render(e)), this.highPassUniforms.tDiffuse.value = n.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, e.setRenderTarget(this.renderTargetBright), e.clear(), this.fsQuad.render(e);
      let a = this.renderTargetBright;
      for (let l = 0; l < this.nMips; l++) this.fsQuad.material = this.separableBlurMaterials[l], this.separableBlurMaterials[l].uniforms.colorTexture.value = a.texture, this.separableBlurMaterials[l].uniforms.direction.value = Xo.BlurDirectionX, e.setRenderTarget(this.renderTargetsHorizontal[l]), e.clear(), this.fsQuad.render(e), this.separableBlurMaterials[l].uniforms.colorTexture.value = this.renderTargetsHorizontal[l].texture, this.separableBlurMaterials[l].uniforms.direction.value = Xo.BlurDirectionY, e.setRenderTarget(this.renderTargetsVertical[l]), e.clear(), this.fsQuad.render(e), a = this.renderTargetsVertical[l];
      this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, e.setRenderTarget(this.renderTargetsHorizontal[0]), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.blendMaterial, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, r && e.state.buffers.stencil.setTest(true), this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(n), this.fsQuad.render(e)), e.setClearColor(this._oldClearColor, this.oldClearAlpha), e.autoClear = o;
    }
    getSeparableBlurMaterial(e) {
      const t = [];
      for (let n = 0; n < e; n++) t.push(0.39894 * Math.exp(-0.5 * n * n / (e * e)) / e);
      return new kn({
        defines: {
          KERNEL_RADIUS: e
        },
        uniforms: {
          colorTexture: {
            value: null
          },
          invSize: {
            value: new Se(0.5, 0.5)
          },
          direction: {
            value: new Se(0.5, 0.5)
          },
          gaussianCoefficients: {
            value: t
          }
        },
        vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
        fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 invSize;
				uniform vec2 direction;
				uniform float gaussianCoefficients[KERNEL_RADIUS];

				void main() {
					float weightSum = gaussianCoefficients[0];
					vec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianCoefficients[i];
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`
      });
    }
    getCompositeMaterial(e) {
      return new kn({
        defines: {
          NUM_MIPS: e
        },
        uniforms: {
          blurTexture1: {
            value: null
          },
          blurTexture2: {
            value: null
          },
          blurTexture3: {
            value: null
          },
          blurTexture4: {
            value: null
          },
          blurTexture5: {
            value: null
          },
          bloomStrength: {
            value: 1
          },
          bloomFactors: {
            value: null
          },
          bloomTintColors: {
            value: null
          },
          bloomRadius: {
            value: 0
          }
        },
        vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
        fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`
      });
    }
  }
  Xo.BlurDirectionX = new Se(1, 0);
  Xo.BlurDirectionY = new Se(0, 1);
  function c1(s, e = {
    density: 1
  }) {
    const t = new si(), n = [], i = 4e3, r = 6e3, o = Math.floor(5e3 * e.density);
    for (let c = 0; c < o; c++) {
      let h, f, m, _;
      do
        h = (Math.random() - 0.5) * r * 2, f = (Math.random() - 0.5) * r * 2, m = (Math.random() - 0.5) * r * 2, _ = Math.sqrt(h * h + f * f + m * m);
      while (_ < i);
      n.push(h, f, m);
    }
    t.setAttribute("position", new Ln(n, 3));
    const a = new Nf({
      color: 16777164,
      size: 3,
      sizeAttenuation: true,
      transparent: true,
      opacity: 1,
      blending: xc
    }), l = new rg(t, a);
    s.add(l);
  }
  function u1(s, e, t, n = 2) {
    const i = new kf(6, 32, 32), r = new Yo({
      emissive: new it(16777164),
      emissiveIntensity: 3,
      roughness: 0.1
    }), o = new hn(i, r);
    o.position.set(-100, 250, -500), s.add(o);
    const a = new Hf(16755200, 10, 500);
    a.position.copy(o.position), s.add(a);
    const l = new o1(e);
    l.addPass(new a1(s, t));
    const c = new Xo(new Se(window.innerWidth, window.innerHeight), n, 0.4, 1.2);
    return l.addPass(c), l;
  }
  let Bt = null, Hi = null, li = null;
  function h1() {
    if (Bt) {
      Bt.style.display = "flex";
      return;
    }
    console.log("Creating Name viewport"), Bt = document.createElement("div"), Bt.id = "name-viewport-container", Bt.style.position = "fixed", Bt.style.top = "50%", Bt.style.left = "50%", Bt.style.transform = "translate(-50%, -50%)", Bt.style.width = "80%", Bt.style.maxWidth = "1200px", Bt.style.height = "80vh", Bt.style.backgroundColor = "rgba(0, 0, 0, 0.9)", Bt.style.border = "0.5px solid #FFFF", Bt.style.borderRadius = "20px", Bt.style.boxShadow = "0 0 30px rgba(0, 123, 255, 0.5)", Bt.style.zIndex = "1000", Bt.style.display = "flex", Bt.style.flexDirection = "column", Bt.style.overflow = "hidden";
    const s = document.createElement("div");
    s.style.display = "flex", s.style.justifyContent = "space-between", s.style.alignItems = "center", s.style.padding = "1px 2px", s.style.backgroundColor = "rgba(0, 0, 0, 0.3)", s.style.color = "white", s.style.borderTopLeftRadius = "20px", s.style.borderTopRightRadius = "20px";
    const e = document.createElement("h2");
    e.style.fontSize = "1.2rem", li = document.createElement("button"), li.textContent = "\u2715", li.style.background = "none", li.style.border = "none", li.style.color = "white", li.style.fontSize = "1.5rem", li.style.cursor = "pointer", li.style.padding = "0 5px", li.style.lineHeight = "1", s.appendChild(li), Bt.appendChild(s), Hi = document.createElement("iframe"), Hi.src = "/public/psycheName/public/name/psycheName.html", Hi.style.width = "100%", Hi.style.height = "100%", Hi.style.border = "none", Hi.style.backgroundColor = "#222", Hi.onerror = () => {
      console.error("Failed to load iframe content");
    }, Hi.onload = () => {
      console.log("Iframe loaded successfully");
    }, Bt.appendChild(Hi), document.body.appendChild(Bt), un.from(Bt, {
      opacity: 0,
      scale: 0.8,
      duration: 0.4,
      ease: "power2.out"
    }), li.addEventListener("click", fd), document.addEventListener("keydown", w_);
  }
  function fd() {
    Bt && un.to(Bt, {
      opacity: 0,
      scale: 0.8,
      duration: 0.3,
      ease: "power2.in",
      onComplete: () => {
        Bt.style.display = "none", Bt.style.opacity = 1, Bt.style.transform = "translate(-50%, -50%) scale(1)";
      }
    });
  }
  function w_(s) {
    s.key === "Escape" && fd();
  }
  function f1() {
    Bt && (li.removeEventListener("click", fd), document.removeEventListener("keydown", w_), document.body.removeChild(Bt), Bt = null, Hi = null, li = null);
  }
  function Jo(s, e = {}) {
    const { backgroundColor: t = "rgba(0, 0, 0, 0.125)", borderColor: n = "#ffffcc", borderWidth: i = "2px", borderRadius: r = "10px", boxShadow: o = "0 0 25px rgba(255, 255, 204, 0.6)", zIndex: a = "900" } = e;
    s.style.position = "fixed", s.style.top = "50%", s.style.left = "50%", s.style.transform = "translate(-50%, -50%)", s.style.backgroundColor = t, s.style.border = `${i} solid ${n}`, s.style.borderRadius = r, s.style.boxShadow = o, s.style.zIndex = a, s.style.display = "flex", s.style.flexDirection = "column", s.style.overflow = "hidden";
  }
  function Qo(s, e = {}) {
    const { backgroundColor: t = "rgba(26, 26, 58, 0.125)", gradientStart: n = "rgba(26, 26, 58, 0.125)", gradientEnd: i = "rgba(58, 58, 106, 0.125)", textColor: r = "white", padding: o = "10px 15px" } = e;
    s.style.display = "flex", s.style.justifyContent = "space-between", s.style.alignItems = "center", s.style.padding = o, s.style.backgroundColor = t, s.style.backgroundImage = `linear-gradient(to right, ${n}, ${i})`, s.style.color = r, s.style.borderTopLeftRadius = "8px", s.style.borderTopRightRadius = "8px";
  }
  function ea(s, e = {}) {
    const { fontSize: t = "1.2rem", textShadow: n = "0 0 5px rgba(255, 255, 204, 0.7)", letterSpacing: i = "0.5px" } = e;
    s.style.margin = "0", s.style.fontSize = t, s.style.textShadow = n, s.style.letterSpacing = i;
  }
  function ta(s, e = {}) {
    const { color: t = "white", fontSize: n = "1.5rem" } = e;
    s.style.background = "none", s.style.border = "none", s.style.color = t, s.style.fontSize = n, s.style.cursor = "pointer", s.style.padding = "0 5px", s.style.lineHeight = "1";
  }
  function d1(s, e = {}) {
    const { color: t = "white", fontSize: n = "1.2rem" } = e;
    s.style.background = "none", s.style.border = "none", s.style.color = t, s.style.fontSize = n, s.style.cursor = "pointer", s.style.padding = "0 5px", s.style.lineHeight = "1", s.style.marginRight = "5px";
  }
  function na(s, e = {}) {
    const { backgroundColor: t = "rgba(0, 0, 0, 0.1)" } = e;
    s.style.width = "100%", s.style.height = "100%", s.style.border = "none", s.style.backgroundColor = t, s.style.overflow = "auto", s.scrolling = "yes";
  }
  function ia(s) {
    const e = s.createElement("style");
    e.textContent = `
        /* Hide scrollbars for WebKit browsers */
        iframe::-webkit-scrollbar,
        *::-webkit-scrollbar {
            width: 0 !important;
            height: 0 !important;
            display: none !important;
        }
        
        /* Hide scrollbars for Firefox */
        iframe,
        * {
            scrollbar-width: none !important;
            -ms-overflow-style: none !important;
        }
        
        /* Allow scrolling but hide scrollbars */
        iframe {
            overflow: auto !important;
        }
    `, s.head.appendChild(e);
  }
  function ra(s) {
    try {
      const e = s.contentDocument || s.contentWindow.document, t = e.createElement("style");
      t.textContent = `
            /* Hide all scrollbars in the iframe content */
            ::-webkit-scrollbar { 
                width: 0 !important; 
                height: 0 !important; 
                display: none !important; 
            }
            * { 
                scrollbar-width: none !important; 
                -ms-overflow-style: none !important;
            }
            html, body {
                overflow: auto !important;
                scrollbar-width: none !important;
                -ms-overflow-style: none !important;
            }
            
            /* Ensure content is scrollable */
            body {
                overflow-y: auto !important;
                overflow-x: auto !important;
            }
        `, e.head.appendChild(t);
    } catch (e) {
      console.error("Could not modify iframe content due to cross-origin restrictions:", e);
    }
  }
  function sa(s) {
    const e = document.createElement("div");
    e.style.position = "absolute", e.style.top = "0", e.style.left = "0", e.style.width = "100%", e.style.height = "100%", e.style.pointerEvents = "none", e.style.background = "radial-gradient(circle at 50% 50%, rgba(255, 255, 204, 0.03) 0%, transparent 80%)", e.style.borderRadius = "10px", e.style.zIndex = "1", s.appendChild(e);
  }
  function oa(s, e = 20) {
    const t = document.createElement("div");
    t.style.position = "absolute", t.style.top = "0", t.style.left = "0", t.style.width = "100%", t.style.height = "100%", t.style.overflow = "hidden", t.style.pointerEvents = "none", t.style.zIndex = "0", t.style.borderRadius = "10px", s.appendChild(t);
    for (let n = 0; n < e; n++) {
      const i = document.createElement("div"), r = Math.random() * 2 + 1, o = Math.random() * 100, a = Math.random() * 100, l = Math.random() * 0.5 + 0.1, c = Math.random() * 3 + 2, h = Math.random() * 2;
      i.style.position = "absolute", i.style.width = `${r}px`, i.style.height = `${r}px`, i.style.borderRadius = "50%", i.style.backgroundColor = "#ffffcc", i.style.left = `${o}%`, i.style.top = `${a}%`, i.style.opacity = `${l}`, t.appendChild(i), un.to(i, {
        opacity: 0.1,
        duration: c,
        repeat: -1,
        yoyo: true,
        ease: "sine.inOut",
        delay: h
      });
    }
    return t;
  }
  function aa(s, e, t) {
    const n = un.timeline();
    return n.from(s, {
      opacity: 0,
      scale: 0.7,
      duration: 0.6,
      ease: "power2.out"
    }), n.from(e, {
      y: -50,
      opacity: 0,
      duration: 0.4,
      ease: "back.out(1.7)"
    }, "-=0.3"), n.from(t, {
      opacity: 0,
      y: 30,
      duration: 0.5,
      ease: "power2.out"
    }, "-=0.2"), n;
  }
  function la(s, e = {}) {
    const { color: t = "rgba(255, 255, 204, 0.7)", intensity: n = "30px", duration: i = 2 } = e;
    return un.to(s, {
      boxShadow: `0 0 ${n} ${t}`,
      repeat: -1,
      yoyo: true,
      duration: i,
      ease: "sine.inOut"
    });
  }
  function os(s, e) {
    const t = un.timeline({
      onComplete: e
    });
    return t.to(s, {
      boxShadow: "0 0 40px rgba(255, 255, 204, 0.9)",
      duration: 0.3,
      ease: "power1.in"
    }), t.to(s, {
      opacity: 0,
      scale: 0.7,
      duration: 0.5,
      ease: "power2.in"
    }, "-=0.1"), t;
  }
  ml = function() {
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", ml);
      return;
    }
    const s = document.querySelectorAll("button"), e = Array.from(s).filter((t) => t.textContent === "\u21A9" || t.innerHTML === "\u21A9");
    console.log("Found return buttons:", e.length), e.forEach((t) => {
      const n = t.cloneNode(true);
      t.parentNode.replaceChild(n, t), n.addEventListener("click", function(i) {
        i.preventDefault(), i.stopPropagation();
        let r = n.closest('[id$="-viewport-container"]');
        if (!r) {
          console.error("No viewport found for return button");
          return;
        }
        console.log("Found viewport for return button:", r.id);
        const o = r.querySelector("iframe");
        if (!o) {
          console.error("No iframe found in viewport");
          return;
        }
        const a = r.querySelector("h2");
        a && (a.textContent = "Psyche Mission Games"), o.src = "./games/games.html", console.log("Loading games HTML in viewport:", r.id);
      });
    });
  };
  ml();
  document.addEventListener("DOMContentLoaded", ml);
  setInterval(ml, 1e3);
  let Ot = null, gr = null, Es = null, Xa = null;
  function A_() {
    const s = window.innerWidth, e = window.innerHeight, t = window.devicePixelRatio || 1;
    console.log(`Screen size: ${s}x${e}, Pixel ratio: ${t}`);
    let n, i, r;
    return s === 2388 && e === 1668 || e === 2388 && s === 1668 ? (console.log('iPad Pro 11" detected'), n = "90%", r = "2000px", i = "90vh") : s >= 2e3 ? (n = "85%", r = "2400px", i = "85vh") : s >= 1600 ? (n = "88%", r = "1900px", i = "88vh") : s >= 1200 ? (n = "90%", r = "1500px", i = "90vh") : s >= 992 ? (n = "92%", r = "1150px", i = "92vh") : s >= 768 ? (n = "95%", r = "950px", i = "95vh") : (n = "98%", r = "100%", i = "98vh"), {
      width: n,
      maxWidth: r,
      height: i
    };
  }
  function qa() {
    if (!Ot) return;
    const { width: s, maxWidth: e, height: t } = A_();
    Ot.style.width = s, Ot.style.maxWidth = e, Ot.style.height = t, console.log(`Viewport resized to: width=${s}, maxWidth=${e}, height=${t}`);
  }
  function p1() {
    if (Ot) {
      Ot.style.display = "flex", qa();
      return;
    }
    console.log("Creating games viewport"), Ot = document.createElement("div"), Ot.id = "games-viewport-container", Jo(Ot, {
      backgroundColor: "rgba(0, 0, 0, 0.05)",
      borderColor: "rgba(122, 95, 62, 0.3)",
      boxShadow: "0 0 15px rgba(122, 95, 62, 0.3)"
    });
    const { width: s, maxWidth: e, height: t } = A_();
    Ot.style.width = s, Ot.style.maxWidth = e, Ot.style.height = t;
    const n = document.createElement("div");
    Qo(n, {
      backgroundColor: "rgba(10, 10, 20, 0.2)",
      gradientStart: "rgba(10, 10, 20, 0.2)",
      gradientEnd: "rgba(20, 20, 40, 0.2)"
    });
    const i = document.createElement("h2");
    i.textContent = "Psyche Mission Games", ea(i);
    const r = document.createElement("div");
    r.style.display = "flex", r.style.alignItems = "center";
    const o = document.createElement("button");
    o.textContent = "\u21A9", d1(o), Es = document.createElement("button"), Es.textContent = "\u2715", ta(Es), r.appendChild(o), r.appendChild(Es), n.appendChild(i), n.appendChild(r), Ot.appendChild(n), gr = document.createElement("iframe"), gr.src = "/public/games/games.html", na(gr, {
      backgroundColor: "rgba(0, 0, 0, 0.0)"
    }), ia(document), gr.onerror = () => {
      console.error("Failed to load games iframe content");
    }, gr.onload = () => {
      console.log("Games iframe loaded successfully"), ra(gr);
    }, Ot.appendChild(gr), document.body.appendChild(Ot), sa(Ot), oa(Ot), aa(Ot, n, gr), la(Ot), Es.addEventListener("click", Oc), o.addEventListener("click", Oc), document.addEventListener("keydown", C_), window.addEventListener("resize", qa), Xa = new ResizeObserver((a) => {
      console.log("ResizeObserver detected size change"), qa();
    }), Xa.observe(document.body);
  }
  function Oc() {
    Ot && os(Ot, () => {
      Ot.style.display = "none", Ot.style.opacity = 1, Ot.style.transform = "translate(-50%, -50%) scale(1)", document.body.classList.add("overlay-open");
    });
  }
  function C_(s) {
    s.key === "Escape" && Oc();
  }
  function m1() {
    Ot && (Es.removeEventListener("click", Oc), document.removeEventListener("keydown", C_), window.removeEventListener("resize", qa), Xa && (Xa.disconnect(), Xa = null), document.body.removeChild(Ot), Ot = null, gr = null, Es = null);
  }
  window.setGamesViewportSize = function(s, e) {
    if (!Ot) {
      console.warn("Games viewport is not currently active");
      return;
    }
    return console.log(`Manually setting viewport size to ${s}x${e}`), Ot.style.width = `${s}px`, Ot.style.maxWidth = `${s}px`, Ot.style.height = `${e}px`, Ot.style.transform = "translate(-50%, -50%)", `Viewport size set to ${s}x${e}`;
  };
  window.resetGamesViewportSize = function() {
    if (!Ot) {
      console.warn("Games viewport is not currently active");
      return;
    }
    return qa(), "Viewport size reset to responsive mode";
  };
  let ws, ym, vf, Ns = 1, ll = false, yf = 0;
  const xm = {
    2: f1,
    6: m1
  };
  let ih = Ns;
  function g1(s) {
    yf = s.touches[0].clientY;
  }
  function _1(s) {
    const e = s.touches[0].clientY, t = yf - e;
    yf = e, P_({
      deltaY: t
    }), s.preventDefault();
  }
  function v1(s, e, t) {
    ws = s, ym = t, vf = e, window.addEventListener("wheel", P_, {
      passive: false
    }), window.addEventListener("touchstart", g1, {
      passive: false
    }), window.addEventListener("touchmove", _1, {
      passive: false
    }), window.addEventListener("keydown", y1, {
      passive: false
    }), window.addEventListener("resize", () => R_(ws, ym));
  }
  function R_(s, e) {
    if (!s || !e) {
      console.error("onResize called without a valid camera or renderer.");
      return;
    }
    const t = Math.max(window.innerWidth, 768), n = t / window.innerHeight;
    if (s.aspect = n, s.updateProjectionMatrix(), e.setSize(t, window.innerHeight), e.setPixelRatio(Math.min(window.devicePixelRatio, 2)), t < 1300) {
      const i = (1300 - t) * 0.048;
      s.fov = Math.min(75 + i, 100);
    } else s.fov = 75;
    s.updateProjectionMatrix();
  }
  function P_(s) {
    if (ll) return;
    const e = s.deltaY > 0 ? 1 : -1;
    let t = Ns + e;
    console.log("Swipe Direction: ", e), t > 8 ? t = 1 : t < 1 && (t = 8), ll = true, cl(t);
  }
  function cl(s, e = null) {
    if (s < 0 || s >= vf.length) return;
    xm[ih] && xm[ih](), Ns = s, ih = s, Ns = s;
    const t = vf[s].position;
    un.to(ws.position, {
      x: t.x,
      y: t.y,
      z: t.z,
      duration: 2,
      ease: "power4.inOut",
      onUpdate: () => {
      },
      onComplete: () => {
        s !== 6 && new V(ws.position.x, ws.position.y, ws.position.z - 1), ll = false, console.log("Moved to Section:", Ns);
        const i = new V();
        ws.getWorldDirection(i), console.log("Camera is now looking in direction:", i);
      }
    });
  }
  function gl() {
    return Ns;
  }
  function y1(s) {
    if (ll) return;
    let e = 0;
    switch (s.key) {
      case "ArrowUp":
      case "ArrowLeft":
        e = -1;
        break;
      case "ArrowDown":
      case "ArrowRight":
        e = 1;
        break;
      default:
        return;
    }
    let t = Ns + e;
    t > 8 ? t = 1 : t < 1 && (t = 8), ll = true, cl(t), s.preventDefault();
  }
  const x1 = "modulepreload", b1 = function(s) {
    return "/" + s;
  }, bm = {}, rh = function(e, t, n) {
    let i = Promise.resolve();
    if (t && t.length > 0) {
      document.getElementsByTagName("link");
      const o = document.querySelector("meta[property=csp-nonce]"), a = (o == null ? void 0 : o.nonce) || (o == null ? void 0 : o.getAttribute("nonce"));
      i = Promise.allSettled(t.map((l) => {
        if (l = b1(l), l in bm) return;
        bm[l] = true;
        const c = l.endsWith(".css"), h = c ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${l}"]${h}`)) return;
        const f = document.createElement("link");
        if (f.rel = c ? "stylesheet" : x1, c || (f.as = "script"), f.crossOrigin = "", f.href = l, a && f.setAttribute("nonce", a), document.head.appendChild(f), c) return new Promise((m, _) => {
          f.addEventListener("load", m), f.addEventListener("error", () => _(new Error(`Unable to preload CSS for ${l}`)));
        });
      }));
    }
    function r(o) {
      const a = new Event("vite:preloadError", {
        cancelable: true
      });
      if (a.payload = o, window.dispatchEvent(a), !a.defaultPrevented) throw o;
    }
    return i.then((o) => {
      for (const a of o || []) a.status === "rejected" && r(a.reason);
      return e().catch(r);
    });
  };
  function S1() {
    const s = document.getElementById("mouse-scroll-indicator");
    s.style.display = "block";
    const e = document.querySelector(".mouse-scroll-indicator");
    if (!e) return;
    const t = window.innerWidth, n = window.innerHeight, i = Math.min(t, n) / 300;
    document.documentElement.style.setProperty("--dynamic-scale", i);
    const r = document.createElement("div");
    r.id = "scroll-text", r.textContent = "SCROLL UP OR DOWN TO EXPLORE", document.body.appendChild(r), setTimeout(() => {
      e.classList.add("moved"), r.classList.add("fade-out");
    }, 3e3), setTimeout(() => {
      r.remove();
    }, 4500);
  }
  function M1(s) {
    const e = document.getElementById("cn-icon-wrapper"), t = document.getElementById("cn-wrapper"), n = document.getElementById("cn-overlay"), i = document.createElement("ul");
    i.style.listStyle = "none", i.style.padding = "0";
    let r = false, o = false, a = null, l = null;
    i.innerHTML = "", s.forEach((_, y) => {
      const g = document.createElement("li"), x = document.createElement("div");
      x.textContent = _.name;
      const v = document.createElement("span");
      if (v.textContent = "\u25BA", v.style.cursor = "pointer", v.style.marginLeft = "15px", g.style.cursor = "pointer", g.style.padding = "10px", g.style.color = "black", g.style.borderBottom = "1px solid rgba(255,255,255,0.3)", g.textContent = _.name, g.addEventListener("click", () => {
        cl(y, _.position), h();
      }), _.subsections && _.subsections.length > 0) {
        g.appendChild(v);
        const E = document.createElement("ul");
        E.style.listStyle = "none", E.style.marginLeft = "5px", E.style.display = "none", _.subsections.forEach((T) => {
          const M = document.createElement("li");
          M.textContent = T.name, M.style.cursor = "pointer", M.addEventListener("click", (P) => {
            P.stopPropagation(), cl(y, T.position), h();
          }), E.appendChild(M);
        }), v.addEventListener("click", (T) => {
          T.stopPropagation(), E.style.display === "none" ? (E.style.display = "block", v.classList.toggle("arrow-rotated")) : (E.style.display = "none", v.classList.toggle("arrow-rotated"));
        }), g.appendChild(E);
      }
      if (i.appendChild(g), _.name === "Games Section") {
        const E = document.createElement("ul");
        E.className = "submenu", E.style.listStyle = "none", E.style.padding = "0", E.style.marginLeft = "20px", E.style.display = "block", E.style.backgroundColor = "rgba(0, 0, 0, 0.8)", E.style.borderRadius = "5px", E.style.overflow = "hidden", [
          {
            name: "PsycheJR",
            path: "../PsycheJR/kids.html"
          },
          {
            name: "Escape Velocity",
            path: "../escapeVelocity/escape-velocity.html"
          },
          {
            name: "SpacePic",
            path: "../spacepic/photo.html"
          }
        ].forEach((P) => {
          const R = document.createElement("li");
          R.textContent = P.name, R.style.cursor = "pointer", R.style.padding = "8px 15px", R.style.color = "#00aaff", R.style.borderBottom = "1px solid rgba(255,255,255,0.1)", R.style.fontSize = "0.9em", R.addEventListener("mouseover", () => {
            R.style.backgroundColor = "rgba(0, 170, 255, 0.2)", R.style.opacity = "1", R.style.color = "black";
          }), R.addEventListener("mouseout", () => {
            R.style.backgroundColor = "transparent", R.style.opacity = "1", R.style.color = "#00aaff";
          }), R.addEventListener("click", (d) => {
            d.stopPropagation(), P.name === "PsycheJR" ? rh(() => Promise.resolve().then(() => C1), void 0).then((N) => {
              N.showKidsViewport();
            }) : P.name === "Escape Velocity" ? rh(() => Promise.resolve().then(() => j1), void 0).then((N) => {
              N.showEscapeVelocityViewport();
            }) : P.name === "SpacePic" && rh(() => import("./viewportspacepic-CkW4kXd3.js"), []).then((N) => {
              N.showSpacePicViewport();
            }), document.body.classList.remove("overlay-open");
          }), E.appendChild(R);
        }), g.appendChild(E), g.addEventListener("click", (P) => {
          const R = E.style.display;
          document.querySelectorAll(".submenu").forEach((d) => {
            d.style.display = "none";
          }), E.style.display = R === "none" ? "block" : "none", P.stopPropagation();
        });
        const M = document.createElement("span");
        M.textContent = " \u25BC", M.style.fontSize = "0.8em", M.style.marginLeft = "5px", g.appendChild(M);
      }
    }), t.appendChild(i);
    function c() {
      clearTimeout(a), clearTimeout(l), r = true, o = true, t.classList.remove("closing"), t.classList.add("opened-nav"), n.classList.add("active"), e.classList.add("active"), e.style.transition = "transform 0.5s ease-in-out", e.style.transform = "rotate(360deg)";
    }
    function h() {
      r && (r = false, o = false, t.classList.add("closing"), a = setTimeout(() => {
        t.classList.remove("opened-nav"), t.classList.remove("closing");
      }, 300), n.classList.remove("active"), e.classList.remove("active"), e.style.transition = "transform 0.5s ease-in-out", e.style.transform = "rotate(0deg)");
    }
    function f() {
      r ? h() : c();
    }
    function m() {
      o || (l = setTimeout(() => {
        h();
      }, 250));
    }
    e.addEventListener("mouseenter", () => {
      o || c();
    }), t.addEventListener("mouseenter", () => {
      o || c();
    }), e.addEventListener("mouseleave", m), t.addEventListener("mouseleave", m), e.addEventListener("click", f), n.addEventListener("click", h), document.addEventListener("click", (_) => {
      !t.contains(_.target) && !e.contains(_.target) && h();
    });
  }
  function T1(s, e, t) {
    return new Promise((n) => {
      var _a;
      const i = (_a = t[0]) == null ? void 0 : _a.position, r = {
        x: i.x - 12,
        y: i.y + 6,
        z: i.z - 13
      };
      console.log("TMP", r);
      const o = {
        x: 0,
        y: 0.1,
        z: 0
      };
      _f("REFERENCES", r, o, 1, s), Kw([
        {
          text: "Development Team",
          onClick: () => console.log("DevTeam Clicked")
        },
        {
          text: "Sponsor",
          onClick: () => console.log("Sponsor Clicked")
        },
        {
          text: "Code",
          onClick: () => console.log("Explore Clicked")
        },
        {
          text: "Images",
          onClick: () => console.log("Surface Clicked")
        }
      ], r, o, s), n();
    });
  }
  let Sm = null;
  const E1 = {};
  function w1(s, e, t) {
    var _a;
    const n = (_a = t[1]) == null ? void 0 : _a.position;
    if (!n) return console.error("Section 1 position not found."), Promise.reject("Section 1 position not found.");
    const i = {
      x: n.x - 12,
      y: n.y + 3,
      z: n.z - 13
    }, r = {
      x: 0,
      y: Math.PI / 12,
      z: 0
    }, o = {
      x: n.x - 11,
      y: n.y - 2,
      z: n.z - 13
    }, a = {
      x: 0,
      y: Math.PI / 12,
      z: 0
    };
    return new Promise(async (l, c) => {
      _f("YEAR ON PSYCHE", i, r, 1.5, s);
      const f = await _f(`16 Psyche is a giant asteroid in our solar system!
    Explore this site to learn about 16 Psyche,
     its origin, orbit, and what makes it unique!
`, o, a, 0.5, s);
      f.material.uniforms.opacity.value = 0, un.to(f.material.uniforms.opacity, {
        value: 1,
        duration: 2.5,
        delay: 4
      }), qc("asteroid", "/res/models/psyche_new.glb", {
        x: 80,
        y: 60,
        z: 20
      }, 6, {
        x: 0,
        y: 0,
        z: 0
      }, {
        position: {
          x: 20,
          y: 16,
          z: -45,
          duration: 3,
          ease: "power2.out"
        },
        rotation: {
          y: -6.28319,
          z: 6.28319,
          duration: 45,
          ease: "linear",
          repeat: -1
        }
      }, s, (m) => {
        Sm = m, Uc(Sm, () => {
          console.log("asteroid clicked"), cl(2, E1);
        }), l();
      }), setTimeout(() => c("Model load timeout"), 1e4);
    }).then(() => {
      console.log("section 1 loaded");
    }).catch((l) => {
      console.error("Error loading Section 1:", l);
    });
  }
  function A1(s, e, t, n) {
    var _a;
    const i = (_a = t[2]) == null ? void 0 : _a.position;
    if (!i) return console.error("Section 2 position not found."), Promise.reject("Section 2 position not found.");
    const r = {
      x: i.x,
      y: i.y + 6,
      z: i.z - 12
    }, o = {
      x: 0.2,
      y: 0,
      z: 0
    };
    return new Promise((a, l) => {
      try {
        const { buttonMesh: c } = Zo("CLICK HERE TO LEARN HOW PSYCHE GOT ITS NAME!", r, o, 0.7, s, () => {
          console.log("Origin button clicked."), h1();
        }), h = new zs(), f = new Se();
        window.addEventListener("mousemove", (m) => {
          const _ = n.domElement.getBoundingClientRect();
          f.x = (m.clientX - _.left) / _.width * 2 - 1, f.y = -((m.clientY - _.top) / _.height) * 2 + 1, h.setFromCamera(f, e);
          const y = h.intersectObjects(Vs);
          n.domElement.style.cursor = y.length > 0 ? "pointer" : "default";
        }), a();
      } catch (c) {
        l(c);
      }
    });
  }
  let Rt = null, Sn = null, As = null, Ya = null;
  function D_() {
    const s = window.innerWidth, e = window.innerHeight, t = window.devicePixelRatio || 1;
    console.log(`Screen size: ${s}x${e}, Pixel ratio: ${t}`);
    let n, i, r;
    return s === 2388 && e === 1668 || e === 2388 && s === 1668 ? (console.log('iPad Pro 11" detected'), n = "90%", r = "2000px", i = "90vh") : s >= 2e3 ? (n = "85%", r = "2400px", i = "85vh") : s >= 1600 ? (n = "88%", r = "1900px", i = "88vh") : s >= 1200 ? (n = "90%", r = "1500px", i = "90vh") : s >= 992 ? (n = "92%", r = "1150px", i = "92vh") : s >= 768 ? (n = "95%", r = "950px", i = "95vh") : (n = "98%", r = "100%", i = "98vh"), {
      width: n,
      maxWidth: r,
      height: i
    };
  }
  function Cs() {
    if (!Rt) return;
    const { width: s, maxWidth: e, height: t } = D_();
    if (Rt.style.width = s, Rt.style.maxWidth = e, Rt.style.height = t, console.log(`Viewport resized to: width=${s}, maxWidth=${e}, height=${t}`), Sn && Sn.contentDocument) try {
      const n = Sn.contentDocument || Sn.contentWindow.document;
      if (n.getElementById("container1")) {
        const r = Math.min(1, window.innerWidth / 1920);
        let o = n.getElementById("responsive-scaling");
        o || (o = n.createElement("style"), o.id = "responsive-scaling", n.head.appendChild(o)), o.textContent = `
                    #container1 {
                        transform: scale(${r});
                        transform-origin: center top;
                        width: calc(100% / ${r});
                        margin-left: auto;
                        margin-right: auto;
                    }
                    
                    #astronautCar {
                        max-width: 100%;
                        height: auto;
                    }
                `, console.log(`Applied responsive scaling: ${r}`);
      }
    } catch (n) {
      console.error("Could not modify iframe content:", n);
    }
  }
  function L_() {
    if (Rt) {
      Rt.style.display = "flex", Cs();
      return;
    }
    console.log("Creating kids viewport"), Rt = document.createElement("div"), Rt.id = "kids-viewport-container", Jo(Rt);
    const { width: s, maxWidth: e, height: t } = D_();
    Rt.style.width = s, Rt.style.maxWidth = e, Rt.style.height = t;
    const n = document.createElement("div");
    Qo(n);
    const i = document.createElement("h2");
    i.textContent = "Psyche Jr - Kids Space Explorer", ea(i), As = document.createElement("button"), As.textContent = "\u2715", ta(As), n.appendChild(i), n.appendChild(As), Rt.appendChild(n), Sn = document.createElement("iframe"), Sn.src = "/public/PsycheJR/kids.html", na(Sn), ia(document), Sn.onerror = () => {
      console.error("Failed to load kids iframe content");
    }, Sn.onload = () => {
      console.log("Kids iframe loaded successfully"), ra(Sn), Cs();
      try {
        const r = Sn.contentDocument || Sn.contentWindow.document;
        new MutationObserver(() => {
          Cs();
        }).observe(r.body, {
          childList: true,
          subtree: true
        });
      } catch (r) {
        console.error("Could not set up MutationObserver:", r);
      }
    }, Rt.appendChild(Sn), document.body.appendChild(Rt), sa(Rt), oa(Rt), aa(Rt, n, Sn), la(Rt), As.addEventListener("click", () => {
      os(Rt, dd);
    }), document.addEventListener("keydown", N_), window.addEventListener("resize", Cs), Ya = new ResizeObserver((r) => {
      console.log("ResizeObserver detected size change"), Cs();
    }), Ya.observe(document.body);
  }
  function I_() {
    Rt && os(Rt, () => {
      Rt.style.display = "none", Rt.style.opacity = 1, Rt.style.transform = "translate(-50%, -50%) scale(1)";
    });
  }
  function N_(s) {
    s.key === "Escape" && os(Rt, dd);
  }
  function dd() {
    Rt && (As.removeEventListener("click", I_), document.removeEventListener("keydown", N_), window.removeEventListener("resize", Cs), Ya && (Ya.disconnect(), Ya = null), document.body.removeChild(Rt), Rt = null, Sn = null, As = null);
  }
  window.setKidsViewportSize = function(s, e) {
    if (!Rt) {
      console.warn("Kids viewport is not currently active");
      return;
    }
    if (console.log(`Manually setting viewport size to ${s}x${e}`), Rt.style.width = `${s}px`, Rt.style.maxWidth = `${s}px`, Rt.style.height = `${e}px`, Rt.style.transform = "translate(-50%, -50%)", Sn && Sn.contentDocument) try {
      const n = (Sn.contentDocument || Sn.contentWindow.document).getElementById("container1");
      if (n) {
        const i = Math.min(1, s / 1920);
        n.style.transform = `scale(${i})`, n.style.transformOrigin = "center top", n.style.width = `calc(100% / ${i})`, console.log(`Applied manual scaling: ${i}`);
      }
    } catch (t) {
      console.error("Could not modify iframe content:", t);
    }
    return `Viewport size set to ${s}x${e}`;
  };
  window.resetKidsViewportSize = function() {
    if (!Rt) {
      console.warn("Kids viewport is not currently active");
      return;
    }
    return Cs(), "Viewport size reset to responsive mode";
  };
  const C1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    destroyKidsViewport: dd,
    hideKidsViewport: I_,
    showKidsViewport: L_
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function R1() {
    const s = window.innerWidth;
    let e, t, n, i = 1, r = 1;
    return s >= 2e3 ? (i = 1.3, r = 1.3, e = 50) : s >= 1600 ? (i = 1.2, r = 1.2, e = 45) : s >= 1200 ? (i = 1.1, r = 1.1, e = 42) : s >= 992 ? (i = 1, r = 1) : s >= 768 ? (i = 0.9, r = 0.9, e = 38) : (i = 0.8, r = 0.8, e = 35), {
      posX: e,
      posY: t,
      posZ: n,
      buttonScale: i,
      labelScale: r
    };
  }
  function P1(s, e, t, n) {
    return new Promise((i, r) => {
      var _a;
      const o = (_a = t[3]) == null ? void 0 : _a.position;
      if (!o) {
        console.error("Section 3 position not found."), r("Section 3 position not found.");
        return;
      }
      const { buttonScale: a } = R1(), l = {
        x: o.x,
        y: o.y + 2,
        z: o.z - 12
      }, c = {
        x: 0.2,
        y: 0,
        z: 0
      };
      try {
        Zo("Explore the Psyche Jr Kids Experience", l, c, a, s, () => {
          L_(), console.log("Psyche Jr button clicked.");
        }).then(({ textMesh: h, buttonMesh: f }) => {
          const m = f.material.emissive.clone(), _ = f.material.emissiveIntensity, y = new zs(), g = new Se();
          window.addEventListener("mousemove", (x) => {
            const v = n.domElement.getBoundingClientRect();
            g.x = (x.clientX - v.left) / v.width * 2 - 1, g.y = -((x.clientY - v.top) / v.height) * 2 + 1, y.setFromCamera(g, e), y.intersectObjects([
              f
            ]).length > 0 ? (hd(f, {
              color: "#ff9900",
              intensity: 2
            }), n.domElement.style.cursor = "pointer") : (f.material.emissive = m, f.material.emissiveIntensity = _, f.material.needsUpdate = true, n.domElement.style.cursor = "default");
          });
        }), i();
      } catch (h) {
        console.error("Error setting up Section 3:", h), r(h);
      }
    });
  }
  function D1(s, e) {
    const n = gl() === 3;
    for (let i = 0; i < e.children.length; i++) {
      const r = e.children[i];
      r.userData && r.userData.section3Element && (r.visible = n);
    }
  }
  let gn = null, Gr = null, Ra = null, uo = null, ic = null, fo = null;
  function L1() {
    if (gn) {
      gn.style.display = "flex";
      return;
    }
    console.log("Creating Year viewport"), gn = document.createElement("div"), gn.id = "year-viewport-container", Jo(gn, {
      backgroundColor: "rgba(0, 0, 0, 0.9)",
      borderColor: "rgb(255, 255, 255)",
      boxShadow: "0 0 20px rgba(255, 255, 204, 0.6)"
    }), gn.style.width = "80%", gn.style.maxWidth = "1440px", gn.style.height = "95vh", uo = document.createElement("div"), Qo(uo, {
      backgroundColor: "#f9a000",
      gradientStart: "#f9a000",
      gradientEnd: "#f9a000"
    }), ic = document.createElement("h2"), ic.textContent = "Compare Earth and Psyche", ea(ic), Ra = document.createElement("button"), Ra.textContent = "\u2715", ta(Ra), uo.appendChild(ic), uo.appendChild(Ra), gn.appendChild(uo), Gr = document.createElement("iframe"), Gr.src = "./year/year.html", na(Gr, {
      backgroundColor: "#222"
    }), Gr.onerror = () => {
      console.error("Failed to load iframe content");
    }, Gr.onload = () => {
      console.log("Iframe loaded successfully"), ra(Gr);
    }, gn.appendChild(Gr), document.body.appendChild(gn), sa(gn), oa(gn, 15), aa(gn, uo, Gr), fo = la(gn, {
      color: "rgba(255, 255, 255, 0.6)",
      intensity: "25px"
    }), ia(document), Ra.addEventListener("click", U_), document.addEventListener("keydown", I1);
  }
  function U_() {
    gn && (fo && fo.kill(), os(gn, () => {
      gn.style.display = "none", gn.style.opacity = 1, gn.style.transform = "translate(-50%, -50%) scale(1)", document.body.classList.add("overlay-open"), fo && (fo.restart(), fo.pause());
    }).play());
  }
  function I1(s) {
    s.key === "Escape" && U_();
  }
  function N1(s, e, t, n) {
    var _a;
    const i = (_a = t[4]) == null ? void 0 : _a.position;
    if (!i) return console.error("Section 4 position not found."), Promise.reject("Section 4 position not found.");
    const r = {
      x: i.x,
      y: i.y + 2,
      z: i.z - 12
    }, o = {
      x: 0.2,
      y: 0,
      z: 0
    };
    return new Promise((a, l) => {
      try {
        const { buttonMesh: c } = Zo(`Explore the Cosmic Comparison
between Earth and Psyche`, r, o, 0.7, s, () => {
          L1(), console.log("Cosmic Comparison button clicked.");
        }), h = new zs(), f = new Se();
        window.addEventListener("mousemove", (m) => {
          const _ = n.domElement.getBoundingClientRect();
          f.x = (m.clientX - _.left) / _.width * 2 - 1, f.y = -((m.clientY - _.top) / _.height) * 2 + 1, h.setFromCamera(f, e);
          const y = h.intersectObjects(Vs);
          n.domElement.style.cursor = y.length > 0 ? "pointer" : "default";
        }), a();
      } catch (c) {
        l(c);
      }
    });
  }
  function U1(s, e) {
    const n = gl() === 4;
    for (let i = 0; i < e.children.length; i++) {
      const r = e.children[i];
      r.userData && r.userData.section4Element && (r.visible = n);
    }
  }
  let Ht = null, Wr = null, Pa = null, Mm = null;
  function O_() {
    const s = window.innerWidth, e = window.innerHeight, t = window.devicePixelRatio || 1;
    console.log(`Screen size: ${s}x${e}, Pixel ratio: ${t}`);
    let n, i, r;
    return s === 2388 && e === 1668 || e === 2388 && s === 1668 ? (console.log('iPad Pro 11" detected'), n = "90%", r = "2000px", i = "90vh") : s >= 2e3 ? (n = "85%", r = "2400px", i = "85vh") : s >= 1600 ? (n = "88%", r = "1900px", i = "88vh") : s >= 1200 ? (n = "90%", r = "1500px", i = "90vh") : s >= 992 ? (n = "92%", r = "1150px", i = "92vh") : s >= 768 ? (n = "95%", r = "950px", i = "95vh") : (n = "98%", r = "100%", i = "98vh"), {
      width: n,
      maxWidth: r,
      height: i
    };
  }
  function _c() {
    if (!Ht) return;
    const { width: s, maxWidth: e, height: t } = O_();
    Ht.style.width = s, Ht.style.maxWidth = e, Ht.style.height = t, console.log(`Viewport resized to: width=${s}, maxWidth=${e}, height=${t}`);
  }
  function O1() {
    if (Ht) {
      Ht.style.display = "flex", _c();
      return;
    }
    console.log("Creating website viewport"), Ht = document.createElement("div"), Ht.id = "website-viewport-container", Jo(Ht, {
      backgroundColor: "rgba(0, 0, 0, 0.05)",
      borderColor: "rgba(122, 95, 62, 0.3)",
      boxShadow: "0 0 15px rgba(122, 95, 62, 0.3)"
    });
    const { width: s, maxWidth: e, height: t } = O_();
    Ht.style.width = s, Ht.style.maxWidth = e, Ht.style.height = t;
    const n = document.createElement("div");
    Qo(n, {
      backgroundColor: "rgba(10, 10, 20, 0.2)",
      gradientStart: "rgba(10, 10, 20, 0.2)",
      gradientEnd: "rgba(20, 20, 40, 0.2)"
    });
    const i = document.createElement("h2");
    i.textContent = "Psyche Mission Website", ea(i);
    const r = document.createElement("div");
    r.style.display = "flex", r.style.alignItems = "center", Pa = document.createElement("button"), Pa.textContent = "\u2715", ta(Pa), r.appendChild(Pa), n.appendChild(i), n.appendChild(r), Ht.appendChild(n), Wr = document.createElement("iframe"), Wr.src = "/website/index.html", na(Wr, {
      backgroundColor: "rgba(0, 0, 0, 0.0)"
    }), ia(document), Wr.onerror = () => {
      console.error("Failed to load website iframe content");
    }, Wr.onload = () => {
      console.log("Website iframe loaded successfully"), ra(Wr);
    }, Ht.appendChild(Wr), document.body.appendChild(Ht), sa(Ht), oa(Ht), aa(Ht, n, Wr), la(Ht), Pa.addEventListener("click", F_), document.addEventListener("keydown", F1), window.addEventListener("resize", _c), Mm = new ResizeObserver((o) => {
      console.log("ResizeObserver detected size change"), _c();
    }), Mm.observe(document.body);
  }
  function F_() {
    Ht && os(Ht, () => {
      Ht.style.display = "none", Ht.style.opacity = 1, Ht.style.transform = "translate(-50%, -50%) scale(1)", document.body.classList.add("overlay-open");
    });
  }
  function F1(s) {
    s.key === "Escape" && F_();
  }
  window.setWebsiteViewportSize = function(s, e) {
    if (!Ht) {
      console.warn("Website viewport is not currently active");
      return;
    }
    return console.log(`Manually setting viewport size to ${s}x${e}`), Ht.style.width = `${s}px`, Ht.style.maxWidth = `${s}px`, Ht.style.height = `${e}px`, Ht.style.transform = "translate(-50%, -50%)", `Viewport size set to ${s}x${e}`;
  };
  window.resetWebsiteViewportSize = function() {
    if (!Ht) {
      console.warn("Website viewport is not currently active");
      return;
    }
    return _c(), "Viewport size reset to responsive mode";
  };
  function k1(s, e, t, n) {
    var _a;
    const i = (_a = t[5]) == null ? void 0 : _a.position;
    if (!i) return console.error("Section 5 position not found."), Promise.reject("Section 5 position not found.");
    const r = {
      x: i.x,
      y: i.y + 2,
      z: i.z - 12
    }, o = {
      x: i.x,
      y: i.y - 3,
      z: i.z - 20
    }, a = {
      x: 0.2,
      y: 0,
      z: 0
    }, l = {
      x: 0.2,
      y: 0,
      z: 0
    };
    return new Promise((c, h) => {
      try {
        qc("probe", "/res/models/nasaLogo.glb", o, 0.7, l, null, s, () => {
          console.log("loaded model");
        });
        const { buttonMesh: f } = Zo("Explore the Mission Website", r, a, 0.7, s, () => {
          O1(), console.log("Psyche Jr button clicked.");
        }), m = new zs(), _ = new Se();
        window.addEventListener("mousemove", (y) => {
          const g = n.domElement.getBoundingClientRect();
          _.x = (y.clientX - g.left) / g.width * 2 - 1, _.y = -((y.clientY - g.top) / g.height) * 2 + 1, m.setFromCamera(_, e);
          const x = m.intersectObjects(Vs);
          n.domElement.style.cursor = x.length > 0 ? "pointer" : "default";
        }), c();
      } catch (f) {
        console.error("Error loading Section 5:", f), h(f);
      }
    });
  }
  let B1 = false;
  function z1(s, e, t, n) {
    return new Promise((i, r) => {
      var _a;
      const o = (_a = t[6]) == null ? void 0 : _a.position;
      if (!o) return console.error("Section 6 position not found."), r("Section 6 position not found.");
      const a = {
        x: o.x,
        y: o.y + 2,
        z: o.z - 12
      }, l = {
        x: o.x,
        y: o.y - 5,
        z: o.z - 12
      }, c = {
        x: 0.2,
        y: 0,
        z: 0
      }, h = {
        x: 0.2,
        y: 0.5,
        z: 0
      };
      try {
        qc("controller", "/res/models/arcade_controller.glb", l, 2, h, null, s, () => {
          console.log("loaded model");
        });
        const { buttonMesh: f } = Zo("Try some Psyche inspired games!", a, c, 0.7, s, () => {
          p1(), console.log("Games button clicked.");
        });
        hd(f, {
          color: "#ff9900",
          intensity: 2
        });
        const m = new zs(), _ = new Se();
        window.addEventListener("mousemove", (y) => {
          const g = n.domElement.getBoundingClientRect();
          _.x = (y.clientX - g.left) / g.width * 2 - 1, _.y = -((y.clientY - g.top) / g.height) * 2 + 1, m.setFromCamera(_, e);
          const x = m.intersectObjects(Vs);
          n.domElement.style.cursor = x.length > 0 ? "pointer" : "default";
        }), B1 = true, i();
      } catch (f) {
        r(f);
      }
    });
  }
  let Vt = null, _n = null, Da = null, Tm = null;
  function k_() {
    const s = window.innerWidth, e = window.innerHeight, t = window.devicePixelRatio || 1;
    console.log(`Screen size: ${s}x${e}, Pixel ratio: ${t}`);
    let n, i, r;
    return s === 2388 && e === 1668 || e === 2388 && s === 1668 ? (console.log('iPad Pro 11" detected'), n = "90%", r = "2000px", i = "90vh") : s >= 2e3 ? (n = "85%", r = "2400px", i = "85vh") : s >= 1600 ? (n = "88%", r = "1900px", i = "88vh") : s >= 1200 ? (n = "90%", r = "1500px", i = "90vh") : s >= 992 ? (n = "92%", r = "1150px", i = "92vh") : s >= 768 ? (n = "95%", r = "950px", i = "95vh") : (n = "98%", r = "100%", i = "98vh"), {
      width: n,
      maxWidth: r,
      height: i
    };
  }
  function po() {
    if (!Vt) return;
    const { width: s, maxWidth: e, height: t } = k_();
    if (Vt.style.width = s, Vt.style.maxWidth = e, Vt.style.height = t, console.log(`Viewport resized to: width=${s}, maxWidth=${e}, height=${t}`), _n && _n.contentDocument) try {
      const n = _n.contentDocument || _n.contentWindow.document;
      if (n.getElementById("psyche-container")) {
        const r = parseInt(s) || window.innerWidth * (parseInt(s) / 100), o = Math.min(1, r / 1920);
        let a = n.getElementById("responsive-scaling");
        a || (a = n.createElement("style"), a.id = "responsive-scaling", n.head.appendChild(a)), a.textContent = `
                    /* Responsive scaling for surface2 content */
                    #psyche-container {
                        width: 100% !important;
                        height: ${Math.max(300, 50 * o)}vh !important;
                        max-width: 100% !important;
                    }
                    
                    #header-h1 {
                        font-size: ${Math.max(40, 90 * o)}px !important;
                    }
                    
                    #materials, #features, #dimensions, #comparable, #explore {
                        width: 90% !important;
                    }
                    
                    #inner-materials h1, #inner-features h1, #inner-dimensions h1, 
                    #inner-comparable h1, #inner-explore h1 {
                        font-size: ${Math.max(30, 60 * o)}px !important;
                    }
                    
                    #inner-materials p, #inner-features p, #inner-dimensions p, 
                    #inner-comparable p, #inner-explore p {
                        font-size: ${Math.max(18, 40 * o)}px !important;
                    }
                    
                    #comparable h3 {
                        font-size: ${Math.max(25, 50 * o)}px !important;
                    }
                    
                    #comparable h4 {
                        font-size: ${Math.max(20, 40 * o)}px !important;
                    }
                    
                    /* Ensure content is scrollable */
                    body {
                        overflow-y: auto !important;
                    }
                `, console.log(`Applied responsive scaling: ${o}`), _n.contentWindow.updatePsycheModelSize && setTimeout(() => {
          _n.contentWindow.updatePsycheModelSize(), console.log("Triggered 3D model resize");
        }, 100);
      }
    } catch (n) {
      console.error("Could not modify iframe content:", n);
    }
  }
  function H1() {
    if (Vt) {
      Vt.style.display = "flex", po();
      return;
    }
    console.log("Creating surface2 viewport"), Vt = document.createElement("div"), Vt.id = "surface2-viewport-container", Jo(Vt, {
      backgroundColor: "rgba(0, 0, 0, 0.05)",
      borderColor: "rgba(122, 95, 62, 0.3)",
      boxShadow: "0 0 15px rgba(122, 95, 62, 0.3)"
    });
    const { width: s, maxWidth: e, height: t } = k_();
    Vt.style.width = s, Vt.style.maxWidth = e, Vt.style.height = t;
    const n = document.createElement("div");
    Qo(n, {
      backgroundColor: "rgba(10, 10, 20, 0.2)",
      gradientStart: "rgba(10, 10, 20, 0.2)",
      gradientEnd: "rgba(20, 20, 40, 0.2)"
    });
    const i = document.createElement("h2");
    i.textContent = "The Surface of Psyche", ea(i), Da = document.createElement("button"), Da.textContent = "\u2715", ta(Da), n.appendChild(i), n.appendChild(Da), Vt.appendChild(n), _n = document.createElement("iframe"), _n.src = "/public/PsycheJR/surface2.html", na(_n, {
      backgroundColor: "rgba(0, 0, 0, 0.0)"
    }), ia(document), _n.onerror = () => {
      console.error("Failed to load surface2 iframe content");
    }, _n.onload = () => {
      console.log("Surface2 iframe loaded successfully"), ra(_n), po();
      try {
        const r = _n.contentDocument || _n.contentWindow.document, o = new MutationObserver(() => {
          po();
        });
        o.observe(r.body, {
          childList: true,
          subtree: true
        });
        const a = r.getElementById("psyche-container");
        if (a) {
          o.observe(a, {
            childList: true,
            subtree: true,
            attributes: true
          });
          const l = new Event("resize");
          window.dispatchEvent(l);
        }
      } catch (r) {
        console.error("Could not set up MutationObserver:", r);
      }
    }, Vt.appendChild(_n), document.body.appendChild(Vt), sa(Vt), oa(Vt), aa(Vt, n, _n), la(Vt), Da.addEventListener("click", B_), document.addEventListener("keydown", V1), window.addEventListener("resize", po), Tm = new ResizeObserver((r) => {
      console.log("ResizeObserver detected size change"), po();
    }), Tm.observe(document.body);
  }
  function B_() {
    Vt && os(Vt, () => {
      Vt.style.display = "none", Vt.style.opacity = 1, Vt.style.transform = "translate(-50%, -50%) scale(1)", document.body.classList.add("overlay-open");
    });
  }
  function V1(s) {
    s.key === "Escape" && B_();
  }
  window.setSurface2ViewportSize = function(s, e) {
    if (!Vt) {
      console.warn("Surface2 viewport is not currently active");
      return;
    }
    if (console.log(`Manually setting viewport size to ${s}x${e}`), Vt.style.width = `${s}px`, Vt.style.maxWidth = `${s}px`, Vt.style.height = `${e}px`, Vt.style.transform = "translate(-50%, -50%)", _n && _n.contentDocument) try {
      const t = _n.contentDocument || _n.contentWindow.document;
      if (t.getElementById("psyche-container")) {
        const i = Math.min(1, s / 1920);
        let r = t.getElementById("responsive-scaling");
        r || (r = t.createElement("style"), r.id = "responsive-scaling", t.head.appendChild(r)), r.textContent = `
                    /* Responsive scaling for surface2 content */
                    #psyche-container {
                        width: 100% !important;
                        height: ${Math.max(300, 50 * i)}vh !important;
                        max-width: 100% !important;
                    }
                    
                    #header-h1 {
                        font-size: ${Math.max(40, 90 * i)}px !important;
                    }
                    
                    #materials, #features, #dimensions, #comparable, #explore {
                        width: 90% !important;
                    }
                    
                    #inner-materials h1, #inner-features h1, #inner-dimensions h1, 
                    #inner-comparable h1, #inner-explore h1 {
                        font-size: ${Math.max(30, 60 * i)}px !important;
                    }
                    
                    #inner-materials p, #inner-features p, #inner-dimensions p, 
                    #inner-comparable p, #inner-explore p {
                        font-size: ${Math.max(18, 40 * i)}px !important;
                    }
                    
                    #comparable h3 {
                        font-size: ${Math.max(25, 50 * i)}px !important;
                    }
                    
                    #comparable h4 {
                        font-size: ${Math.max(20, 40 * i)}px !important;
                    }
                `, console.log(`Applied manual scaling: ${i}`);
        const o = new Event("resize");
        window.dispatchEvent(o);
      }
    } catch (t) {
      console.error("Could not modify iframe content:", t);
    }
    return `Viewport size set to ${s}x${e}`;
  };
  window.resetSurface2ViewportSize = function() {
    if (!Vt) {
      console.warn("Surface2 viewport is not currently active");
      return;
    }
    return po(), "Viewport size reset to responsive mode";
  };
  function G1(s, e, t) {
    return new Promise((n, i) => {
      var _a;
      const r = (_a = t[7]) == null ? void 0 : _a.position;
      if (!r) {
        console.error("Error: Section 7 position not found."), i("Section 7 position not found.");
        return;
      }
      const o = {
        x: r.x + 5,
        y: r.y + 10,
        z: r.z - 20
      };
      s.add(M_("Surface of Psyche", o, s, H1, 1.5)), n();
    });
  }
  let Gt = null, Xr = null, La = null, Em = null;
  function z_() {
    const s = window.innerWidth, e = window.innerHeight, t = window.devicePixelRatio || 1;
    console.log(`Screen size: ${s}x${e}, Pixel ratio: ${t}`);
    let n, i, r;
    return s === 2388 && e === 1668 || e === 2388 && s === 1668 ? (console.log('iPad Pro 11" detected'), n = "90%", r = "2000px", i = "90vh") : s >= 2e3 ? (n = "85%", r = "2400px", i = "85vh") : s >= 1600 ? (n = "88%", r = "1900px", i = "88vh") : s >= 1200 ? (n = "90%", r = "1500px", i = "90vh") : s >= 992 ? (n = "92%", r = "1150px", i = "92vh") : s >= 768 ? (n = "95%", r = "950px", i = "95vh") : (n = "98%", r = "100%", i = "98vh"), {
      width: n,
      maxWidth: r,
      height: i
    };
  }
  function vc() {
    if (!Gt) return;
    const { width: s, maxWidth: e, height: t } = z_();
    Gt.style.width = s, Gt.style.maxWidth = e, Gt.style.height = t, console.log(`Viewport resized to: width=${s}, maxWidth=${e}, height=${t}`);
  }
  function W1() {
    if (Gt) {
      Gt.style.display = "flex", vc();
      return;
    }
    console.log("Creating location2 viewport"), Gt = document.createElement("div"), Gt.id = "location2-viewport-container", Jo(Gt, {
      backgroundColor: "rgba(0, 0, 0, 0.05)",
      borderColor: "rgba(122, 95, 62, 0.3)",
      boxShadow: "0 0 15px rgba(122, 95, 62, 0.3)"
    });
    const { width: s, maxWidth: e, height: t } = z_();
    Gt.style.width = s, Gt.style.maxWidth = e, Gt.style.height = t;
    const n = document.createElement("div");
    Qo(n, {
      backgroundColor: "rgba(10, 10, 20, 0.2)",
      gradientStart: "rgba(10, 10, 20, 0.2)",
      gradientEnd: "rgba(20, 20, 40, 0.2)"
    });
    const i = document.createElement("h2");
    i.textContent = "Psyche's Location in Space", ea(i), La = document.createElement("button"), La.textContent = "\u2715", ta(La), n.appendChild(i), n.appendChild(La), Gt.appendChild(n), Xr = document.createElement("iframe"), Xr.src = "/public/PsycheJR/location2.html", na(Xr, {
      backgroundColor: "rgba(0, 0, 0, 0.0)"
    }), ia(document), Xr.onerror = () => {
      console.error("Failed to load location2 iframe content");
    }, Xr.onload = () => {
      console.log("Location2 iframe loaded successfully"), ra(Xr);
    }, Gt.appendChild(Xr), document.body.appendChild(Gt), sa(Gt), oa(Gt), aa(Gt, n, Xr), la(Gt), La.addEventListener("click", H_), document.addEventListener("keydown", X1), window.addEventListener("resize", vc), Em = new ResizeObserver((r) => {
      console.log("ResizeObserver detected size change"), vc();
    }), Em.observe(document.body);
  }
  function H_() {
    Gt && os(Gt, () => {
      Gt.style.display = "none", Gt.style.opacity = 1, Gt.style.transform = "translate(-50%, -50%) scale(1)", document.body.classList.add("overlay-open");
    });
  }
  function X1(s) {
    s.key === "Escape" && H_();
  }
  window.setLocation2ViewportSize = function(s, e) {
    if (!Gt) {
      console.warn("Location2 viewport is not currently active");
      return;
    }
    return console.log(`Manually setting viewport size to ${s}x${e}`), Gt.style.width = `${s}px`, Gt.style.maxWidth = `${s}px`, Gt.style.height = `${e}px`, Gt.style.transform = "translate(-50%, -50%)", `Viewport size set to ${s}x${e}`;
  };
  window.resetLocation2ViewportSize = function() {
    if (!Gt) {
      console.warn("Location2 viewport is not currently active");
      return;
    }
    return vc(), "Viewport size reset to responsive mode";
  };
  function q1(s, e, t, n) {
    var _a;
    const i = (_a = t[8]) == null ? void 0 : _a.position;
    if (!i) return console.error("Section 8 position not found."), Promise.reject("Section 8 position not found.");
    const r = {
      x: i.x,
      y: i.y + 2,
      z: i.z - 12
    }, o = {
      x: i.x,
      y: i.y - 3,
      z: i.z - 12
    };
    console.log("map pin location: ", o);
    const a = {
      x: 0.2,
      y: 0,
      z: 0
    }, l = {
      x: -0.02,
      y: 0.5,
      z: 0
    };
    return new Promise((c, h) => {
      try {
        qc("controller", "/res/models/navigation_pin.glb", o, 1, l, {
          rotation: {
            x: 0,
            y: -40,
            z: 0,
            duration: 45,
            ease: "linear",
            repeat: -1
          }
        }, s, () => {
          console.log("loaded model");
        });
        const { buttonMesh: f } = Zo("Explore Psyche's Location!", r, a, 0.7, s, () => {
          W1(), console.log("Location button clicked.");
        });
        hd(f, {
          color: "#ff9900",
          intensity: 2
        });
        const m = new zs(), _ = new Se();
        window.addEventListener("mousemove", (y) => {
          const g = n.domElement.getBoundingClientRect();
          _.x = (y.clientX - g.left) / g.width * 2 - 1, _.y = -((y.clientY - g.top) / g.height) * 2 + 1, m.setFromCamera(_, e);
          const x = m.intersectObjects(Vs);
          n.domElement.style.cursor = x.length > 0 ? "pointer" : "default";
        }), c();
      } catch (f) {
        h(f);
      }
    });
  }
  const wm = [];
  function Y1(s, e) {
    if (wm.length === 0) return;
    const n = gl() === 8;
    wm.forEach((i) => {
      i.visible !== n && (i.visible = n);
    });
  }
  let jt = null, bi = null, ci = null;
  function Fc() {
    if (jt) {
      jt.style.display = "flex";
      return;
    }
    console.log("Creating escape velocity viewport"), jt = document.createElement("div"), jt.id = "escape-velocity-viewport-container", jt.style.position = "fixed", jt.style.top = "50%", jt.style.left = "50%", jt.style.transform = "translate(-50%, -50%)", jt.style.width = "80%", jt.style.maxWidth = "1440px", jt.style.height = "80vh", jt.style.backgroundColor = "rgba(0, 0, 0, 0.9)", jt.style.border = "2px solid #007bff", jt.style.borderRadius = "10px", jt.style.boxShadow = "0 0 20px rgba(0, 123, 255, 0.5)", jt.style.zIndex = "900", jt.style.display = "flex", jt.style.flexDirection = "column", jt.style.overflow = "hidden";
    const s = document.createElement("div");
    s.style.display = "flex", s.style.justifyContent = "space-between", s.style.alignItems = "center", s.style.padding = "10px 15px", s.style.backgroundColor = "#007bff", s.style.color = "white", s.style.borderTopLeftRadius = "8px", s.style.borderTopRightRadius = "8px";
    const e = document.createElement("h2");
    e.textContent = "Escape Velocity Game", e.style.margin = "0", e.style.fontSize = "1.2rem";
    const t = document.createElement("div");
    t.style.display = "flex", t.style.alignItems = "center", t.style.gap = "10px";
    const n = document.createElement("button");
    n.textContent = "\u21A9", n.style.background = "none", n.style.border = "none", n.style.color = "white", n.style.fontSize = "1.2rem", n.style.cursor = "pointer", n.style.padding = "0 5px", n.style.lineHeight = "1", n.style.marginRight = "5px", ci = document.createElement("button"), ci.textContent = "\u2715", ci.style.background = "none", ci.style.border = "none", ci.style.color = "white", ci.style.fontSize = "1.5rem", ci.style.cursor = "pointer", ci.style.padding = "0 5px", ci.style.lineHeight = "1", t.appendChild(n), t.appendChild(ci), s.appendChild(e), s.appendChild(t), jt.appendChild(s), bi = document.createElement("iframe"), bi.src = "./escapeVelocity/escape-velocity.html", bi.style.width = "100%", bi.style.height = "100%", bi.style.border = "none", bi.style.backgroundColor = "#222", bi.onerror = () => {
      console.error("Failed to load iframe content");
    }, bi.onload = () => {
      console.log("Iframe loaded successfully");
    }, jt.appendChild(bi), document.body.appendChild(jt);
    const i = un.timeline();
    i.from(jt, {
      opacity: 0,
      scale: 0.8,
      duration: 0.4,
      ease: "power2.out"
    }), i.from(s, {
      y: -50,
      duration: 0.3,
      ease: "back.out(1.7)"
    }, "-=0.2"), i.from(bi, {
      opacity: 0,
      y: 20,
      duration: 0.3,
      ease: "power2.out"
    }, "-=0.1"), ci.addEventListener("click", _l), n.addEventListener("click", function(r) {
      r.preventDefault(), r.stopPropagation(), e.textContent = "Psyche Mission Games", bi.src = "./games/games.html", console.log("Loading games HTML in escape velocity viewport");
    }), document.addEventListener("keydown", V_), setTimeout(ml, 100);
  }
  function _l() {
    jt && un.to(jt, {
      opacity: 0,
      scale: 0.8,
      duration: 0.3,
      ease: "power2.in",
      onComplete: () => {
        G_(), document.body.classList.add("overlay-open");
      }
    });
  }
  function V_(s) {
    s.key === "Escape" && _l();
  }
  function G_() {
    jt && (ci.removeEventListener("click", _l), document.removeEventListener("keydown", V_), document.body.removeChild(jt), jt = null, bi = null, ci = null);
  }
  const j1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    destroyEscapeVelocityViewport: G_,
    hideEscapeVelocityViewport: _l,
    showEscapeVelocityViewport: Fc
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  let Am = [], rc = false;
  function $1(s, e, t, n) {
    return new Promise((i, r) => {
      try {
        const o = new ks(40, 20, 5), a = new qi({
          color: 31743,
          transparent: false
        }), l = new hn(o, a);
        l.position.set(200, 300, -110), l.userData.section9Element = true, s.add(l);
        const c = [];
        c.push(l);
        const h = document.createElement("canvas");
        h.width = 256, h.height = 128;
        const f = h.getContext("2d");
        f.fillStyle = "#007bff", f.fillRect(0, 0, h.width, h.height), f.font = "bold 24px Arial", f.fillStyle = "white", f.textAlign = "center", f.textBaseline = "middle", f.fillText("Escape Velocity", h.width / 2, h.height / 2);
        const m = new ry(h), _ = new qi({
          map: m,
          transparent: true
        }), y = new hl(50, 25), g = new hn(y, _);
        g.position.set(200, 300, -107), g.userData.section9Element = true, s.add(g), c.push(g);
        const x = new Hf(16777215, 2, 200);
        x.position.set(200, 300, -100), x.userData.section9Element = true, s.add(x), c.push(x);
        const v = new gg(16777215, 0.5);
        v.userData.section9Element = true, s.add(v), c.push(v), Uc(l, () => {
          Fc();
        }), Uc(g, () => {
          Fc();
        });
        let E = false;
        l.userData.onPointerOver = () => {
          E || (un.to(l.material.color, {
            r: 0,
            g: 0.337,
            b: 0.702,
            duration: 0.3
          }), E = true);
        }, l.userData.onPointerOut = () => {
          E && (un.to(l.material.color, {
            r: 0,
            g: 0.482,
            b: 1,
            duration: 0.3
          }), E = false);
        }, c.forEach((T) => {
          T.visible = false;
        }), i();
      } catch (o) {
        r(o);
      }
    });
  }
  function K1(s, e) {
    if (Am.length === 0) return;
    const n = gl() === 9;
    Am.forEach((i) => {
      i.visible !== n && (i.visible = n);
    }), n && !rc ? setTimeout(() => {
      Fc(), rc = true;
    }, 500) : !n && rc && (_l(), rc = false);
  }
  var sh = {
    exports: {}
  };
  var Cm;
  function Z1() {
    return Cm || (Cm = 1, function(s, e) {
      (function(t, n) {
        s.exports = n();
      })(window, function() {
        return function(t) {
          var n = {};
          function i(r) {
            if (n[r]) return n[r].exports;
            var o = n[r] = {
              i: r,
              l: false,
              exports: {}
            };
            return t[r].call(o.exports, o, o.exports, i), o.l = true, o.exports;
          }
          return i.m = t, i.c = n, i.d = function(r, o, a) {
            i.o(r, o) || Object.defineProperty(r, o, {
              enumerable: true,
              get: a
            });
          }, i.r = function(r) {
            typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(r, Symbol.toStringTag, {
              value: "Module"
            }), Object.defineProperty(r, "__esModule", {
              value: true
            });
          }, i.t = function(r, o) {
            if (1 & o && (r = i(r)), 8 & o || 4 & o && typeof r == "object" && r && r.__esModule) return r;
            var a = /* @__PURE__ */ Object.create(null);
            if (i.r(a), Object.defineProperty(a, "default", {
              enumerable: true,
              value: r
            }), 2 & o && typeof r != "string") for (var l in r) i.d(a, l, (function(c) {
              return r[c];
            }).bind(null, l));
            return a;
          }, i.n = function(r) {
            var o = r && r.__esModule ? function() {
              return r.default;
            } : function() {
              return r;
            };
            return i.d(o, "a", o), o;
          }, i.o = function(r, o) {
            return Object.prototype.hasOwnProperty.call(r, o);
          }, i.p = "", i(i.s = 4);
        }([
          function(t, n, i) {
            Object.defineProperty(n, "__esModule", {
              value: true
            });
            var r = function() {
              function o(a, l, c) {
                a === void 0 && (a = null), l === void 0 && (l = null), c === void 0 && (c = "en-US"), this.dateInstance = typeof l == "object" && l !== null ? l.parse(a instanceof o ? a.clone().toJSDate() : a) : typeof l == "string" ? o.parseDateTime(a, l, c) : a ? o.parseDateTime(a) : o.parseDateTime(/* @__PURE__ */ new Date()), this.lang = c;
              }
              return o.parseDateTime = function(a, l, c) {
                if (l === void 0 && (l = "YYYY-MM-DD"), c === void 0 && (c = "en-US"), !a) return /* @__PURE__ */ new Date(NaN);
                if (a instanceof Date) return new Date(a);
                if (a instanceof o) return a.clone().toJSDate();
                if (/^-?\d{10,}$/.test(a)) return o.getDateZeroTime(new Date(Number(a)));
                if (typeof a == "string") {
                  for (var h = [], f = null; (f = o.regex.exec(l)) != null; ) f[1] !== "\\" && h.push(f);
                  if (h.length) {
                    var m = {
                      year: null,
                      month: null,
                      shortMonth: null,
                      longMonth: null,
                      day: null,
                      value: ""
                    };
                    h[0].index > 0 && (m.value += ".*?");
                    for (var _ = 0, y = Object.entries(h); _ < y.length; _++) {
                      var g = y[_], x = g[0], v = g[1], E = Number(x), T = o.formatPatterns(v[0], c), M = T.group, P = T.pattern;
                      m[M] = E + 1, m.value += P, m.value += ".*?";
                    }
                    var R = new RegExp("^" + m.value + "$");
                    if (R.test(a)) {
                      var d = R.exec(a), N = Number(d[m.year]), w = null;
                      m.month ? w = Number(d[m.month]) - 1 : m.shortMonth ? w = o.shortMonths(c).indexOf(d[m.shortMonth]) : m.longMonth && (w = o.longMonths(c).indexOf(d[m.longMonth]));
                      var D = Number(d[m.day]) || 1;
                      return new Date(N, w, D, 0, 0, 0, 0);
                    }
                  }
                }
                return o.getDateZeroTime(new Date(a));
              }, o.convertArray = function(a, l) {
                return a.map(function(c) {
                  return c instanceof Array ? c.map(function(h) {
                    return new o(h, l);
                  }) : new o(c, l);
                });
              }, o.getDateZeroTime = function(a) {
                return new Date(a.getFullYear(), a.getMonth(), a.getDate(), 0, 0, 0, 0);
              }, o.shortMonths = function(a) {
                return o.MONTH_JS.map(function(l) {
                  return new Date(2019, l).toLocaleString(a, {
                    month: "short"
                  });
                });
              }, o.longMonths = function(a) {
                return o.MONTH_JS.map(function(l) {
                  return new Date(2019, l).toLocaleString(a, {
                    month: "long"
                  });
                });
              }, o.formatPatterns = function(a, l) {
                switch (a) {
                  case "YY":
                  case "YYYY":
                    return {
                      group: "year",
                      pattern: "(\\d{" + a.length + "})"
                    };
                  case "M":
                    return {
                      group: "month",
                      pattern: "(\\d{1,2})"
                    };
                  case "MM":
                    return {
                      group: "month",
                      pattern: "(\\d{2})"
                    };
                  case "MMM":
                    return {
                      group: "shortMonth",
                      pattern: "(" + o.shortMonths(l).join("|") + ")"
                    };
                  case "MMMM":
                    return {
                      group: "longMonth",
                      pattern: "(" + o.longMonths(l).join("|") + ")"
                    };
                  case "D":
                    return {
                      group: "day",
                      pattern: "(\\d{1,2})"
                    };
                  case "DD":
                    return {
                      group: "day",
                      pattern: "(\\d{2})"
                    };
                }
              }, o.prototype.toJSDate = function() {
                return this.dateInstance;
              }, o.prototype.toLocaleString = function(a, l) {
                return this.dateInstance.toLocaleString(a, l);
              }, o.prototype.toDateString = function() {
                return this.dateInstance.toDateString();
              }, o.prototype.getSeconds = function() {
                return this.dateInstance.getSeconds();
              }, o.prototype.getDay = function() {
                return this.dateInstance.getDay();
              }, o.prototype.getTime = function() {
                return this.dateInstance.getTime();
              }, o.prototype.getDate = function() {
                return this.dateInstance.getDate();
              }, o.prototype.getMonth = function() {
                return this.dateInstance.getMonth();
              }, o.prototype.getFullYear = function() {
                return this.dateInstance.getFullYear();
              }, o.prototype.setMonth = function(a) {
                return this.dateInstance.setMonth(a);
              }, o.prototype.setHours = function(a, l, c, h) {
                a === void 0 && (a = 0), l === void 0 && (l = 0), c === void 0 && (c = 0), h === void 0 && (h = 0), this.dateInstance.setHours(a, l, c, h);
              }, o.prototype.setSeconds = function(a) {
                return this.dateInstance.setSeconds(a);
              }, o.prototype.setDate = function(a) {
                return this.dateInstance.setDate(a);
              }, o.prototype.setFullYear = function(a) {
                return this.dateInstance.setFullYear(a);
              }, o.prototype.getWeek = function(a) {
                var l = new Date(this.timestamp()), c = (this.getDay() + (7 - a)) % 7;
                l.setDate(l.getDate() - c);
                var h = l.getTime();
                return l.setMonth(0, 1), l.getDay() !== a && l.setMonth(0, 1 + (4 - l.getDay() + 7) % 7), 1 + Math.ceil((h - l.getTime()) / 6048e5);
              }, o.prototype.clone = function() {
                return new o(this.toJSDate());
              }, o.prototype.isBetween = function(a, l, c) {
                switch (c === void 0 && (c = "()"), c) {
                  default:
                  case "()":
                    return this.timestamp() > a.getTime() && this.timestamp() < l.getTime();
                  case "[)":
                    return this.timestamp() >= a.getTime() && this.timestamp() < l.getTime();
                  case "(]":
                    return this.timestamp() > a.getTime() && this.timestamp() <= l.getTime();
                  case "[]":
                    return this.timestamp() >= a.getTime() && this.timestamp() <= l.getTime();
                }
              }, o.prototype.isBefore = function(a, l) {
                switch (l === void 0 && (l = "seconds"), l) {
                  case "second":
                  case "seconds":
                    return a.getTime() > this.getTime();
                  case "day":
                  case "days":
                    return new Date(a.getFullYear(), a.getMonth(), a.getDate()).getTime() > new Date(this.getFullYear(), this.getMonth(), this.getDate()).getTime();
                  case "month":
                  case "months":
                    return new Date(a.getFullYear(), a.getMonth(), 1).getTime() > new Date(this.getFullYear(), this.getMonth(), 1).getTime();
                  case "year":
                  case "years":
                    return a.getFullYear() > this.getFullYear();
                }
                throw new Error("isBefore: Invalid unit!");
              }, o.prototype.isSameOrBefore = function(a, l) {
                switch (l === void 0 && (l = "seconds"), l) {
                  case "second":
                  case "seconds":
                    return a.getTime() >= this.getTime();
                  case "day":
                  case "days":
                    return new Date(a.getFullYear(), a.getMonth(), a.getDate()).getTime() >= new Date(this.getFullYear(), this.getMonth(), this.getDate()).getTime();
                  case "month":
                  case "months":
                    return new Date(a.getFullYear(), a.getMonth(), 1).getTime() >= new Date(this.getFullYear(), this.getMonth(), 1).getTime();
                }
                throw new Error("isSameOrBefore: Invalid unit!");
              }, o.prototype.isAfter = function(a, l) {
                switch (l === void 0 && (l = "seconds"), l) {
                  case "second":
                  case "seconds":
                    return this.getTime() > a.getTime();
                  case "day":
                  case "days":
                    return new Date(this.getFullYear(), this.getMonth(), this.getDate()).getTime() > new Date(a.getFullYear(), a.getMonth(), a.getDate()).getTime();
                  case "month":
                  case "months":
                    return new Date(this.getFullYear(), this.getMonth(), 1).getTime() > new Date(a.getFullYear(), a.getMonth(), 1).getTime();
                  case "year":
                  case "years":
                    return this.getFullYear() > a.getFullYear();
                }
                throw new Error("isAfter: Invalid unit!");
              }, o.prototype.isSameOrAfter = function(a, l) {
                switch (l === void 0 && (l = "seconds"), l) {
                  case "second":
                  case "seconds":
                    return this.getTime() >= a.getTime();
                  case "day":
                  case "days":
                    return new Date(this.getFullYear(), this.getMonth(), this.getDate()).getTime() >= new Date(a.getFullYear(), a.getMonth(), a.getDate()).getTime();
                  case "month":
                  case "months":
                    return new Date(this.getFullYear(), this.getMonth(), 1).getTime() >= new Date(a.getFullYear(), a.getMonth(), 1).getTime();
                }
                throw new Error("isSameOrAfter: Invalid unit!");
              }, o.prototype.isSame = function(a, l) {
                switch (l === void 0 && (l = "seconds"), l) {
                  case "second":
                  case "seconds":
                    return this.getTime() === a.getTime();
                  case "day":
                  case "days":
                    return new Date(this.getFullYear(), this.getMonth(), this.getDate()).getTime() === new Date(a.getFullYear(), a.getMonth(), a.getDate()).getTime();
                  case "month":
                  case "months":
                    return new Date(this.getFullYear(), this.getMonth(), 1).getTime() === new Date(a.getFullYear(), a.getMonth(), 1).getTime();
                }
                throw new Error("isSame: Invalid unit!");
              }, o.prototype.add = function(a, l) {
                switch (l === void 0 && (l = "seconds"), l) {
                  case "second":
                  case "seconds":
                    this.setSeconds(this.getSeconds() + a);
                    break;
                  case "day":
                  case "days":
                    this.setDate(this.getDate() + a);
                    break;
                  case "month":
                  case "months":
                    this.setMonth(this.getMonth() + a);
                }
                return this;
              }, o.prototype.subtract = function(a, l) {
                switch (l === void 0 && (l = "seconds"), l) {
                  case "second":
                  case "seconds":
                    this.setSeconds(this.getSeconds() - a);
                    break;
                  case "day":
                  case "days":
                    this.setDate(this.getDate() - a);
                    break;
                  case "month":
                  case "months":
                    this.setMonth(this.getMonth() - a);
                }
                return this;
              }, o.prototype.diff = function(a, l) {
                switch (l === void 0 && (l = "seconds"), l) {
                  default:
                  case "second":
                  case "seconds":
                    return this.getTime() - a.getTime();
                  case "day":
                  case "days":
                    return Math.round((this.timestamp() - a.getTime()) / 864e5);
                  case "month":
                  case "months":
                }
              }, o.prototype.format = function(a, l) {
                if (l === void 0 && (l = "en-US"), typeof a == "object") return a.output(this.clone().toJSDate());
                for (var c = "", h = [], f = null; (f = o.regex.exec(a)) != null; ) f[1] !== "\\" && h.push(f);
                if (h.length) {
                  h[0].index > 0 && (c += a.substring(0, h[0].index));
                  for (var m = 0, _ = Object.entries(h); m < _.length; m++) {
                    var y = _[m], g = y[0], x = y[1], v = Number(g);
                    c += this.formatTokens(x[0], l), h[v + 1] && (c += a.substring(x.index + x[0].length, h[v + 1].index)), v === h.length - 1 && (c += a.substring(x.index + x[0].length));
                  }
                }
                return c.replace(/\\/g, "");
              }, o.prototype.timestamp = function() {
                return new Date(this.getFullYear(), this.getMonth(), this.getDate(), 0, 0, 0, 0).getTime();
              }, o.prototype.formatTokens = function(a, l) {
                switch (a) {
                  case "YY":
                    return String(this.getFullYear()).slice(-2);
                  case "YYYY":
                    return String(this.getFullYear());
                  case "M":
                    return String(this.getMonth() + 1);
                  case "MM":
                    return ("0" + (this.getMonth() + 1)).slice(-2);
                  case "MMM":
                    return o.shortMonths(l)[this.getMonth()];
                  case "MMMM":
                    return o.longMonths(l)[this.getMonth()];
                  case "D":
                    return String(this.getDate());
                  case "DD":
                    return ("0" + this.getDate()).slice(-2);
                  default:
                    return "";
                }
              }, o.regex = /(\\)?(Y{2,4}|M{1,4}|D{1,2}|d{1,4})/g, o.MONTH_JS = [
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
              ], o;
            }();
            n.DateTime = r;
          },
          function(t, n, i) {
            var r, o = this && this.__extends || (r = function(_, y) {
              return (r = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function(g, x) {
                g.__proto__ = x;
              } || function(g, x) {
                for (var v in x) x.hasOwnProperty(v) && (g[v] = x[v]);
              })(_, y);
            }, function(_, y) {
              function g() {
                this.constructor = _;
              }
              r(_, y), _.prototype = y === null ? Object.create(y) : (g.prototype = y.prototype, new g());
            }), a = this && this.__spreadArrays || function() {
              for (var _ = 0, y = 0, g = arguments.length; y < g; y++) _ += arguments[y].length;
              var x = Array(_), v = 0;
              for (y = 0; y < g; y++) for (var E = arguments[y], T = 0, M = E.length; T < M; T++, v++) x[v] = E[T];
              return x;
            };
            Object.defineProperty(n, "__esModule", {
              value: true
            });
            var l = i(5), c = i(0), h = i(3), f = i(2), m = function(_) {
              function y(g) {
                var x = _.call(this, g) || this;
                return x.preventClick = false, x.bindEvents(), x;
              }
              return o(y, _), y.prototype.scrollToDate = function(g) {
                if (this.options.scrollToDate) {
                  var x = this.options.startDate instanceof c.DateTime ? this.options.startDate.clone() : null, v = this.options.endDate instanceof c.DateTime ? this.options.endDate.clone() : null;
                  !this.options.startDate || g && g !== this.options.element ? g && this.options.endDate && g === this.options.elementEnd && (v.setDate(1), this.options.numberOfMonths > 1 && v.isAfter(x) && v.setMonth(v.getMonth() - (this.options.numberOfMonths - 1)), this.calendars[0] = v.clone()) : (x.setDate(1), this.calendars[0] = x.clone());
                }
              }, y.prototype.bindEvents = function() {
                document.addEventListener("click", this.onClick.bind(this), true), this.ui = document.createElement("div"), this.ui.className = h.litepicker, this.ui.style.display = "none", this.ui.addEventListener("mouseenter", this.onMouseEnter.bind(this), true), this.ui.addEventListener("mouseleave", this.onMouseLeave.bind(this), false), this.options.autoRefresh ? (this.options.element instanceof HTMLElement && this.options.element.addEventListener("keyup", this.onInput.bind(this), true), this.options.elementEnd instanceof HTMLElement && this.options.elementEnd.addEventListener("keyup", this.onInput.bind(this), true)) : (this.options.element instanceof HTMLElement && this.options.element.addEventListener("change", this.onInput.bind(this), true), this.options.elementEnd instanceof HTMLElement && this.options.elementEnd.addEventListener("change", this.onInput.bind(this), true)), this.options.parentEl ? this.options.parentEl instanceof HTMLElement ? this.options.parentEl.appendChild(this.ui) : document.querySelector(this.options.parentEl).appendChild(this.ui) : this.options.inlineMode ? this.options.element instanceof HTMLInputElement ? this.options.element.parentNode.appendChild(this.ui) : this.options.element.appendChild(this.ui) : document.body.appendChild(this.ui), this.updateInput(), this.init(), typeof this.options.setup == "function" && this.options.setup.call(this, this), this.render(), this.options.inlineMode && this.show();
              }, y.prototype.updateInput = function() {
                if (this.options.element instanceof HTMLInputElement) {
                  var g = this.options.startDate, x = this.options.endDate;
                  if (this.options.singleMode && g) this.options.element.value = g.format(this.options.format, this.options.lang);
                  else if (!this.options.singleMode && g && x) {
                    var v = g.format(this.options.format, this.options.lang), E = x.format(this.options.format, this.options.lang);
                    this.options.elementEnd instanceof HTMLInputElement ? (this.options.element.value = v, this.options.elementEnd.value = E) : this.options.element.value = "" + v + this.options.delimiter + E;
                  }
                  g || x || (this.options.element.value = "", this.options.elementEnd instanceof HTMLInputElement && (this.options.elementEnd.value = ""));
                }
              }, y.prototype.isSamePicker = function(g) {
                return g.closest("." + h.litepicker) === this.ui;
              }, y.prototype.shouldShown = function(g) {
                return !g.disabled && (g === this.options.element || this.options.elementEnd && g === this.options.elementEnd);
              }, y.prototype.shouldResetDatePicked = function() {
                return this.options.singleMode || this.datePicked.length === 2;
              }, y.prototype.shouldSwapDatePicked = function() {
                return this.datePicked.length === 2 && this.datePicked[0].getTime() > this.datePicked[1].getTime();
              }, y.prototype.shouldCheckLockDays = function() {
                return this.options.disallowLockDaysInRange && this.datePicked.length === 2;
              }, y.prototype.onClick = function(g) {
                var x = g.target;
                if (g.target.shadowRoot && (x = g.composedPath()[0]), x && this.ui) if (this.shouldShown(x)) this.show(x);
                else if (x.closest("." + h.litepicker) || !this.isShowning()) {
                  if (this.isSamePicker(x)) if (this.emit("before:click", x), this.preventClick) this.preventClick = false;
                  else {
                    if (x.classList.contains(h.dayItem)) {
                      if (g.preventDefault(), x.classList.contains(h.isLocked)) return;
                      if (this.shouldResetDatePicked() && (this.datePicked.length = 0), this.datePicked[this.datePicked.length] = new c.DateTime(x.dataset.time), this.shouldSwapDatePicked()) {
                        var v = this.datePicked[1].clone();
                        this.datePicked[1] = this.datePicked[0].clone(), this.datePicked[0] = v.clone();
                      }
                      return this.shouldCheckLockDays() && f.rangeIsLocked(this.datePicked, this.options) && (this.emit("error:range", this.datePicked), this.datePicked.length = 0), this.render(), this.emit.apply(this, a([
                        "preselect"
                      ], a(this.datePicked).map(function(P) {
                        return P.clone();
                      }))), void (this.options.autoApply && (this.options.singleMode && this.datePicked.length ? (this.setDate(this.datePicked[0]), this.hide()) : this.options.singleMode || this.datePicked.length !== 2 || (this.setDateRange(this.datePicked[0], this.datePicked[1]), this.hide())));
                    }
                    if (x.classList.contains(h.buttonPreviousMonth)) {
                      g.preventDefault();
                      var E = 0, T = this.options.switchingMonths || this.options.numberOfMonths;
                      if (this.options.splitView) {
                        var M = x.closest("." + h.monthItem);
                        E = f.findNestedMonthItem(M), T = 1;
                      }
                      return this.calendars[E].setMonth(this.calendars[E].getMonth() - T), this.gotoDate(this.calendars[E], E), void this.emit("change:month", this.calendars[E], E);
                    }
                    if (x.classList.contains(h.buttonNextMonth)) return g.preventDefault(), E = 0, T = this.options.switchingMonths || this.options.numberOfMonths, this.options.splitView && (M = x.closest("." + h.monthItem), E = f.findNestedMonthItem(M), T = 1), this.calendars[E].setMonth(this.calendars[E].getMonth() + T), this.gotoDate(this.calendars[E], E), void this.emit("change:month", this.calendars[E], E);
                    x.classList.contains(h.buttonCancel) && (g.preventDefault(), this.hide(), this.emit("button:cancel")), x.classList.contains(h.buttonApply) && (g.preventDefault(), this.options.singleMode && this.datePicked.length ? this.setDate(this.datePicked[0]) : this.options.singleMode || this.datePicked.length !== 2 || this.setDateRange(this.datePicked[0], this.datePicked[1]), this.hide(), this.emit("button:apply", this.options.startDate, this.options.endDate));
                  }
                } else this.hide();
              }, y.prototype.showTooltip = function(g, x) {
                var v = this.ui.querySelector("." + h.containerTooltip);
                v.style.visibility = "visible", v.innerHTML = x;
                var E = this.ui.getBoundingClientRect(), T = v.getBoundingClientRect(), M = g.getBoundingClientRect(), P = M.top, R = M.left;
                if (this.options.inlineMode && this.options.parentEl) {
                  var d = this.ui.parentNode.getBoundingClientRect();
                  P -= d.top, R -= d.left;
                } else P -= E.top, R -= E.left;
                P -= T.height, R -= T.width / 2, R += M.width / 2, v.style.top = P + "px", v.style.left = R + "px", this.emit("tooltip", v, g);
              }, y.prototype.hideTooltip = function() {
                this.ui.querySelector("." + h.containerTooltip).style.visibility = "hidden";
              }, y.prototype.shouldAllowMouseEnter = function(g) {
                return !this.options.singleMode && !g.classList.contains(h.isLocked);
              }, y.prototype.shouldAllowRepick = function() {
                return this.options.elementEnd && this.options.allowRepick && this.options.startDate && this.options.endDate;
              }, y.prototype.isDayItem = function(g) {
                return g.classList.contains(h.dayItem);
              }, y.prototype.onMouseEnter = function(g) {
                var x = this, v = g.target;
                if (this.isDayItem(v) && this.shouldAllowMouseEnter(v)) {
                  if (this.shouldAllowRepick() && (this.triggerElement === this.options.element ? this.datePicked[0] = this.options.endDate.clone() : this.triggerElement === this.options.elementEnd && (this.datePicked[0] = this.options.startDate.clone())), this.datePicked.length !== 1) return;
                  var E = this.ui.querySelector("." + h.dayItem + '[data-time="' + this.datePicked[0].getTime() + '"]'), T = this.datePicked[0].clone(), M = new c.DateTime(v.dataset.time), P = false;
                  if (T.getTime() > M.getTime()) {
                    var R = T.clone();
                    T = M.clone(), M = R.clone(), P = true;
                  }
                  if (Array.prototype.slice.call(this.ui.querySelectorAll("." + h.dayItem)).forEach(function(G) {
                    var Q = new c.DateTime(G.dataset.time), ue = x.renderDay(Q);
                    Q.isBetween(T, M) && ue.classList.add(h.isInRange), G.className = ue.className;
                  }), v.classList.add(h.isEndDate), P ? (E && E.classList.add(h.isFlipped), v.classList.add(h.isFlipped)) : (E && E.classList.remove(h.isFlipped), v.classList.remove(h.isFlipped)), this.options.showTooltip) {
                    var d = M.diff(T, "day") + 1;
                    if (typeof this.options.tooltipNumber == "function" && (d = this.options.tooltipNumber.call(this, d)), d > 0) {
                      var N = this.pluralSelector(d), w = d + " " + (this.options.tooltipText[N] ? this.options.tooltipText[N] : "[" + N + "]");
                      this.showTooltip(v, w);
                      var D = window.navigator.userAgent, B = /(iphone|ipad)/i.test(D), Z = /OS 1([0-2])/i.test(D);
                      B && Z && v.dispatchEvent(new Event("click"));
                    } else this.hideTooltip();
                  }
                }
              }, y.prototype.onMouseLeave = function(g) {
                g.target, this.options.allowRepick && (!this.options.allowRepick || this.options.startDate || this.options.endDate) && (this.datePicked.length = 0, this.render());
              }, y.prototype.onInput = function(g) {
                var x = this.parseInput(), v = x[0], E = x[1], T = this.options.format;
                if (this.options.elementEnd ? v instanceof c.DateTime && E instanceof c.DateTime && v.format(T) === this.options.element.value && E.format(T) === this.options.elementEnd.value : this.options.singleMode ? v instanceof c.DateTime && v.format(T) === this.options.element.value : v instanceof c.DateTime && E instanceof c.DateTime && "" + v.format(T) + this.options.delimiter + E.format(T) === this.options.element.value) {
                  if (E && v.getTime() > E.getTime()) {
                    var M = v.clone();
                    v = E.clone(), E = M.clone();
                  }
                  this.options.startDate = new c.DateTime(v, this.options.format, this.options.lang), E && (this.options.endDate = new c.DateTime(E, this.options.format, this.options.lang)), this.updateInput(), this.render();
                  var P = v.clone(), R = 0;
                  (this.options.elementEnd ? v.format(T) === g.target.value : g.target.value.startsWith(v.format(T))) || (P = E.clone(), R = this.options.numberOfMonths - 1), this.emit("selected", this.getStartDate(), this.getEndDate()), this.gotoDate(P, R);
                }
              }, y;
            }(l.Calendar);
            n.Litepicker = m;
          },
          function(t, n, i) {
            Object.defineProperty(n, "__esModule", {
              value: true
            }), n.findNestedMonthItem = function(r) {
              for (var o = r.parentNode.childNodes, a = 0; a < o.length; a += 1) if (o.item(a) === r) return a;
              return 0;
            }, n.dateIsLocked = function(r, o, a) {
              var l = false;
              return o.lockDays.length && (l = o.lockDays.filter(function(c) {
                return c instanceof Array ? r.isBetween(c[0], c[1], o.lockDaysInclusivity) : c.isSame(r, "day");
              }).length), l || typeof o.lockDaysFilter != "function" || (l = o.lockDaysFilter.call(this, r.clone(), null, a)), l;
            }, n.rangeIsLocked = function(r, o) {
              var a = false;
              return o.lockDays.length && (a = o.lockDays.filter(function(l) {
                if (l instanceof Array) {
                  var c = r[0].toDateString() === l[0].toDateString() && r[1].toDateString() === l[1].toDateString();
                  return l[0].isBetween(r[0], r[1], o.lockDaysInclusivity) || l[1].isBetween(r[0], r[1], o.lockDaysInclusivity) || c;
                }
                return l.isBetween(r[0], r[1], o.lockDaysInclusivity);
              }).length), a || typeof o.lockDaysFilter != "function" || (a = o.lockDaysFilter.call(this, r[0].clone(), r[1].clone(), r)), a;
            };
          },
          function(t, n, i) {
            var r = i(8);
            typeof r == "string" && (r = [
              [
                t.i,
                r,
                ""
              ]
            ]);
            var o = {
              insert: function(a) {
                var l = document.querySelector("head"), c = window._lastElementInsertedByStyleLoader;
                window.disableLitepickerStyles || (c ? c.nextSibling ? l.insertBefore(a, c.nextSibling) : l.appendChild(a) : l.insertBefore(a, l.firstChild), window._lastElementInsertedByStyleLoader = a);
              },
              singleton: false
            };
            i(10)(r, o), r.locals && (t.exports = r.locals);
          },
          function(t, n, i) {
            Object.defineProperty(n, "__esModule", {
              value: true
            });
            var r = i(1);
            n.Litepicker = r.Litepicker, i(11), window.Litepicker = r.Litepicker, n.default = r.Litepicker;
          },
          function(t, n, i) {
            var r, o = this && this.__extends || (r = function(m, _) {
              return (r = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function(y, g) {
                y.__proto__ = g;
              } || function(y, g) {
                for (var x in g) g.hasOwnProperty(x) && (y[x] = g[x]);
              })(m, _);
            }, function(m, _) {
              function y() {
                this.constructor = m;
              }
              r(m, _), m.prototype = _ === null ? Object.create(_) : (y.prototype = _.prototype, new y());
            });
            Object.defineProperty(n, "__esModule", {
              value: true
            });
            var a = i(6), l = i(0), c = i(3), h = i(2), f = function(m) {
              function _(y) {
                return m.call(this, y) || this;
              }
              return o(_, m), _.prototype.render = function() {
                var y = this;
                this.emit("before:render", this.ui);
                var g = document.createElement("div");
                g.className = c.containerMain;
                var x = document.createElement("div");
                x.className = c.containerMonths, c["columns" + this.options.numberOfColumns] && (x.classList.remove(c.columns2, c.columns3, c.columns4), x.classList.add(c["columns" + this.options.numberOfColumns])), this.options.splitView && x.classList.add(c.splitView), this.options.showWeekNumbers && x.classList.add(c.showWeekNumbers);
                for (var v = this.calendars[0].clone(), E = v.getMonth(), T = v.getMonth() + this.options.numberOfMonths, M = 0, P = E; P < T; P += 1) {
                  var R = v.clone();
                  R.setDate(1), R.setHours(0, 0, 0, 0), this.options.splitView ? R = this.calendars[M].clone() : R.setMonth(P), x.appendChild(this.renderMonth(R, M)), M += 1;
                }
                if (this.ui.innerHTML = "", g.appendChild(x), this.options.resetButton) {
                  var d = void 0;
                  typeof this.options.resetButton == "function" ? d = this.options.resetButton.call(this) : ((d = document.createElement("button")).type = "button", d.className = c.resetButton, d.innerHTML = this.options.buttonText.reset), d.addEventListener("click", function(N) {
                    N.preventDefault(), y.clearSelection();
                  }), g.querySelector("." + c.monthItem + ":last-child").querySelector("." + c.monthItemHeader).appendChild(d);
                }
                this.ui.appendChild(g), this.options.autoApply && !this.options.footerHTML || this.ui.appendChild(this.renderFooter()), this.options.showTooltip && this.ui.appendChild(this.renderTooltip()), this.ui.dataset.plugins = (this.options.plugins || []).join("|"), this.emit("render", this.ui);
              }, _.prototype.renderMonth = function(y, g) {
                var x = this, v = y.clone(), E = 32 - new Date(v.getFullYear(), v.getMonth(), 32).getDate(), T = document.createElement("div");
                T.className = c.monthItem;
                var M = document.createElement("div");
                M.className = c.monthItemHeader;
                var P = document.createElement("div");
                if (this.options.dropdowns.months) {
                  var R = document.createElement("select");
                  R.className = c.monthItemName;
                  for (var d = 0; d < 12; d += 1) {
                    var N = document.createElement("option"), w = new l.DateTime(new Date(y.getFullYear(), d, 2, 0, 0, 0)), D = new l.DateTime(new Date(y.getFullYear(), d, 1, 0, 0, 0));
                    N.value = String(d), N.text = w.toLocaleString(this.options.lang, {
                      month: "long"
                    }), N.disabled = this.options.minDate && D.isBefore(new l.DateTime(this.options.minDate), "month") || this.options.maxDate && D.isAfter(new l.DateTime(this.options.maxDate), "month"), N.selected = D.getMonth() === y.getMonth(), R.appendChild(N);
                  }
                  R.addEventListener("change", function(Te) {
                    var Ye = Te.target, lt = 0;
                    if (x.options.splitView) {
                      var Fe = Ye.closest("." + c.monthItem);
                      lt = h.findNestedMonthItem(Fe);
                    }
                    x.calendars[lt].setMonth(Number(Ye.value)), x.render(), x.emit("change:month", x.calendars[lt], lt, Te);
                  }), P.appendChild(R);
                } else (w = document.createElement("strong")).className = c.monthItemName, w.innerHTML = y.toLocaleString(this.options.lang, {
                  month: "long"
                }), P.appendChild(w);
                if (this.options.dropdowns.years) {
                  var B = document.createElement("select");
                  B.className = c.monthItemYear;
                  var Z = this.options.dropdowns.minYear, G = this.options.dropdowns.maxYear ? this.options.dropdowns.maxYear : (/* @__PURE__ */ new Date()).getFullYear();
                  for (y.getFullYear() > G && ((N = document.createElement("option")).value = String(y.getFullYear()), N.text = String(y.getFullYear()), N.selected = true, N.disabled = true, B.appendChild(N)), d = G; d >= Z; d -= 1) {
                    var N = document.createElement("option"), Q = new l.DateTime(new Date(d, 0, 1, 0, 0, 0));
                    N.value = String(d), N.text = String(d), N.disabled = this.options.minDate && Q.isBefore(new l.DateTime(this.options.minDate), "year") || this.options.maxDate && Q.isAfter(new l.DateTime(this.options.maxDate), "year"), N.selected = y.getFullYear() === d, B.appendChild(N);
                  }
                  if (y.getFullYear() < Z && ((N = document.createElement("option")).value = String(y.getFullYear()), N.text = String(y.getFullYear()), N.selected = true, N.disabled = true, B.appendChild(N)), this.options.dropdowns.years === "asc") {
                    var ue = Array.prototype.slice.call(B.childNodes).reverse();
                    B.innerHTML = "", ue.forEach(function(Te) {
                      Te.innerHTML = Te.value, B.appendChild(Te);
                    });
                  }
                  B.addEventListener("change", function(Te) {
                    var Ye = Te.target, lt = 0;
                    if (x.options.splitView) {
                      var Fe = Ye.closest("." + c.monthItem);
                      lt = h.findNestedMonthItem(Fe);
                    }
                    x.calendars[lt].setFullYear(Number(Ye.value)), x.render(), x.emit("change:year", x.calendars[lt], lt, Te);
                  }), P.appendChild(B);
                } else {
                  var te = document.createElement("span");
                  te.className = c.monthItemYear, te.innerHTML = String(y.getFullYear()), P.appendChild(te);
                }
                var he = document.createElement("button");
                he.type = "button", he.className = c.buttonPreviousMonth, he.innerHTML = this.options.buttonText.previousMonth;
                var ie = document.createElement("button");
                ie.type = "button", ie.className = c.buttonNextMonth, ie.innerHTML = this.options.buttonText.nextMonth, M.appendChild(he), M.appendChild(P), M.appendChild(ie), this.options.minDate && v.isSameOrBefore(new l.DateTime(this.options.minDate), "month") && T.classList.add(c.noPreviousMonth), this.options.maxDate && v.isSameOrAfter(new l.DateTime(this.options.maxDate), "month") && T.classList.add(c.noNextMonth);
                var Me = document.createElement("div");
                Me.className = c.monthItemWeekdaysRow, this.options.showWeekNumbers && (Me.innerHTML = "<div>W</div>");
                for (var Ce = 1; Ce <= 7; Ce += 1) {
                  var Le = 3 + this.options.firstDay + Ce, Je = document.createElement("div");
                  Je.innerHTML = this.weekdayName(Le), Je.title = this.weekdayName(Le, "long"), Me.appendChild(Je);
                }
                var dt = document.createElement("div");
                dt.className = c.containerDays;
                var ce = this.calcSkipDays(v);
                this.options.showWeekNumbers && ce && dt.appendChild(this.renderWeekNumber(v));
                for (var ve = 0; ve < ce; ve += 1) {
                  var qe = document.createElement("div");
                  dt.appendChild(qe);
                }
                for (ve = 1; ve <= E; ve += 1) v.setDate(ve), this.options.showWeekNumbers && v.getDay() === this.options.firstDay && dt.appendChild(this.renderWeekNumber(v)), dt.appendChild(this.renderDay(v));
                return T.appendChild(M), T.appendChild(Me), T.appendChild(dt), this.emit("render:month", T, y), T;
              }, _.prototype.renderDay = function(y) {
                y.setHours();
                var g = document.createElement("div");
                if (g.className = c.dayItem, g.innerHTML = String(y.getDate()), g.dataset.time = String(y.getTime()), y.toDateString() === (/* @__PURE__ */ new Date()).toDateString() && g.classList.add(c.isToday), this.datePicked.length) this.datePicked[0].toDateString() === y.toDateString() && (g.classList.add(c.isStartDate), this.options.singleMode && g.classList.add(c.isEndDate)), this.datePicked.length === 2 && this.datePicked[1].toDateString() === y.toDateString() && g.classList.add(c.isEndDate), this.datePicked.length === 2 && y.isBetween(this.datePicked[0], this.datePicked[1]) && g.classList.add(c.isInRange);
                else if (this.options.startDate) {
                  var x = this.options.startDate, v = this.options.endDate;
                  x.toDateString() === y.toDateString() && (g.classList.add(c.isStartDate), this.options.singleMode && g.classList.add(c.isEndDate)), v && v.toDateString() === y.toDateString() && g.classList.add(c.isEndDate), x && v && y.isBetween(x, v) && g.classList.add(c.isInRange);
                }
                if (this.options.minDate && y.isBefore(new l.DateTime(this.options.minDate)) && g.classList.add(c.isLocked), this.options.maxDate && y.isAfter(new l.DateTime(this.options.maxDate)) && g.classList.add(c.isLocked), this.options.minDays > 1 && this.datePicked.length === 1) {
                  var E = this.options.minDays - 1, T = this.datePicked[0].clone().subtract(E, "day"), M = this.datePicked[0].clone().add(E, "day");
                  y.isBetween(T, this.datePicked[0], "(]") && g.classList.add(c.isLocked), y.isBetween(this.datePicked[0], M, "[)") && g.classList.add(c.isLocked);
                }
                if (this.options.maxDays && this.datePicked.length === 1) {
                  var P = this.options.maxDays;
                  T = this.datePicked[0].clone().subtract(P, "day"), M = this.datePicked[0].clone().add(P, "day"), y.isSameOrBefore(T) && g.classList.add(c.isLocked), y.isSameOrAfter(M) && g.classList.add(c.isLocked);
                }
                return this.options.selectForward && this.datePicked.length === 1 && y.isBefore(this.datePicked[0]) && g.classList.add(c.isLocked), this.options.selectBackward && this.datePicked.length === 1 && y.isAfter(this.datePicked[0]) && g.classList.add(c.isLocked), h.dateIsLocked(y, this.options, this.datePicked) && g.classList.add(c.isLocked), this.options.highlightedDays.length && this.options.highlightedDays.filter(function(R) {
                  return R instanceof Array ? y.isBetween(R[0], R[1], "[]") : R.isSame(y, "day");
                }).length && g.classList.add(c.isHighlighted), g.tabIndex = g.classList.contains("is-locked") ? -1 : 0, this.emit("render:day", g, y), g;
              }, _.prototype.renderFooter = function() {
                var y = document.createElement("div");
                if (y.className = c.containerFooter, this.options.footerHTML ? y.innerHTML = this.options.footerHTML : y.innerHTML = `
      <span class="` + c.previewDateRange + `"></span>
      <button type="button" class="` + c.buttonCancel + '">' + this.options.buttonText.cancel + `</button>
      <button type="button" class="` + c.buttonApply + '">' + this.options.buttonText.apply + `</button>
      `, this.options.singleMode) {
                  if (this.datePicked.length === 1) {
                    var g = this.datePicked[0].format(this.options.format, this.options.lang);
                    y.querySelector("." + c.previewDateRange).innerHTML = g;
                  }
                } else if (this.datePicked.length === 1 && y.querySelector("." + c.buttonApply).setAttribute("disabled", ""), this.datePicked.length === 2) {
                  g = this.datePicked[0].format(this.options.format, this.options.lang);
                  var x = this.datePicked[1].format(this.options.format, this.options.lang);
                  y.querySelector("." + c.previewDateRange).innerHTML = "" + g + this.options.delimiter + x;
                }
                return this.emit("render:footer", y), y;
              }, _.prototype.renderWeekNumber = function(y) {
                var g = document.createElement("div"), x = y.getWeek(this.options.firstDay);
                return g.className = c.weekNumber, g.innerHTML = x === 53 && y.getMonth() === 0 ? "53 / 1" : x, g;
              }, _.prototype.renderTooltip = function() {
                var y = document.createElement("div");
                return y.className = c.containerTooltip, y;
              }, _.prototype.weekdayName = function(y, g) {
                return g === void 0 && (g = "short"), new Date(1970, 0, y, 12, 0, 0, 0).toLocaleString(this.options.lang, {
                  weekday: g
                });
              }, _.prototype.calcSkipDays = function(y) {
                var g = y.getDay() - this.options.firstDay;
                return g < 0 && (g += 7), g;
              }, _;
            }(a.LPCore);
            n.Calendar = f;
          },
          function(t, n, i) {
            var r, o = this && this.__extends || (r = function(m, _) {
              return (r = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function(y, g) {
                y.__proto__ = g;
              } || function(y, g) {
                for (var x in g) g.hasOwnProperty(x) && (y[x] = g[x]);
              })(m, _);
            }, function(m, _) {
              function y() {
                this.constructor = m;
              }
              r(m, _), m.prototype = _ === null ? Object.create(_) : (y.prototype = _.prototype, new y());
            }), a = this && this.__assign || function() {
              return (a = Object.assign || function(m) {
                for (var _, y = 1, g = arguments.length; y < g; y++) for (var x in _ = arguments[y]) Object.prototype.hasOwnProperty.call(_, x) && (m[x] = _[x]);
                return m;
              }).apply(this, arguments);
            };
            Object.defineProperty(n, "__esModule", {
              value: true
            });
            var l = i(7), c = i(0), h = i(1), f = function(m) {
              function _(y) {
                var g = m.call(this) || this;
                g.datePicked = [], g.calendars = [], g.options = {
                  element: null,
                  elementEnd: null,
                  parentEl: null,
                  firstDay: 1,
                  format: "YYYY-MM-DD",
                  lang: "en-US",
                  delimiter: " - ",
                  numberOfMonths: 1,
                  numberOfColumns: 1,
                  startDate: null,
                  endDate: null,
                  zIndex: 9999,
                  position: "auto",
                  selectForward: false,
                  selectBackward: false,
                  splitView: false,
                  inlineMode: false,
                  singleMode: true,
                  autoApply: true,
                  allowRepick: false,
                  showWeekNumbers: false,
                  showTooltip: true,
                  scrollToDate: true,
                  mobileFriendly: true,
                  resetButton: false,
                  autoRefresh: false,
                  lockDaysFormat: "YYYY-MM-DD",
                  lockDays: [],
                  disallowLockDaysInRange: false,
                  lockDaysInclusivity: "[]",
                  highlightedDaysFormat: "YYYY-MM-DD",
                  highlightedDays: [],
                  dropdowns: {
                    minYear: 1990,
                    maxYear: null,
                    months: false,
                    years: false
                  },
                  buttonText: {
                    apply: "Apply",
                    cancel: "Cancel",
                    previousMonth: '<svg width="11" height="16" xmlns="http://www.w3.org/2000/svg"><path d="M7.919 0l2.748 2.667L5.333 8l5.334 5.333L7.919 16 0 8z" fill-rule="nonzero"/></svg>',
                    nextMonth: '<svg width="11" height="16" xmlns="http://www.w3.org/2000/svg"><path d="M2.748 16L0 13.333 5.333 8 0 2.667 2.748 0l7.919 8z" fill-rule="nonzero"/></svg>',
                    reset: `<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24">
        <path d="M0 0h24v24H0z" fill="none"/>
        <path d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"/>
      </svg>`
                  },
                  tooltipText: {
                    one: "day",
                    other: "days"
                  }
                }, g.options = a(a({}, g.options), y.element.dataset), Object.keys(g.options).forEach(function(Z) {
                  g.options[Z] !== "true" && g.options[Z] !== "false" || (g.options[Z] = g.options[Z] === "true");
                });
                var x = a(a({}, g.options.dropdowns), y.dropdowns), v = a(a({}, g.options.buttonText), y.buttonText), E = a(a({}, g.options.tooltipText), y.tooltipText);
                g.options = a(a({}, g.options), y), g.options.dropdowns = a({}, x), g.options.buttonText = a({}, v), g.options.tooltipText = a({}, E), g.options.elementEnd || (g.options.allowRepick = false), g.options.lockDays.length && (g.options.lockDays = c.DateTime.convertArray(g.options.lockDays, g.options.lockDaysFormat)), g.options.highlightedDays.length && (g.options.highlightedDays = c.DateTime.convertArray(g.options.highlightedDays, g.options.highlightedDaysFormat));
                var T = g.parseInput(), M = T[0], P = T[1];
                g.options.startDate && (g.options.singleMode || g.options.endDate) && (M = new c.DateTime(g.options.startDate, g.options.format, g.options.lang)), M && g.options.endDate && (P = new c.DateTime(g.options.endDate, g.options.format, g.options.lang)), M instanceof c.DateTime && !isNaN(M.getTime()) && (g.options.startDate = M), g.options.startDate && P instanceof c.DateTime && !isNaN(P.getTime()) && (g.options.endDate = P), !g.options.singleMode || g.options.startDate instanceof c.DateTime || (g.options.startDate = null), g.options.singleMode || g.options.startDate instanceof c.DateTime && g.options.endDate instanceof c.DateTime || (g.options.startDate = null, g.options.endDate = null);
                for (var R = 0; R < g.options.numberOfMonths; R += 1) {
                  var d = g.options.startDate instanceof c.DateTime ? g.options.startDate.clone() : new c.DateTime();
                  if (!g.options.startDate && (R === 0 || g.options.splitView)) {
                    var N = g.options.maxDate ? new c.DateTime(g.options.maxDate) : null, w = g.options.minDate ? new c.DateTime(g.options.minDate) : null, D = g.options.numberOfMonths - 1;
                    w && N && d.isAfter(N) ? (d = w.clone()).setDate(1) : !w && N && d.isAfter(N) && ((d = N.clone()).setDate(1), d.setMonth(d.getMonth() - D));
                  }
                  d.setDate(1), d.setMonth(d.getMonth() + R), g.calendars[R] = d;
                }
                if (g.options.showTooltip) if (g.options.tooltipPluralSelector) g.pluralSelector = g.options.tooltipPluralSelector;
                else try {
                  var B = new Intl.PluralRules(g.options.lang);
                  g.pluralSelector = B.select.bind(B);
                } catch {
                  g.pluralSelector = function(G) {
                    return Math.abs(G) === 0 ? "one" : "other";
                  };
                }
                return g;
              }
              return o(_, m), _.add = function(y, g) {
                h.Litepicker.prototype[y] = g;
              }, _.prototype.DateTime = function(y, g) {
                return y ? new c.DateTime(y, g) : new c.DateTime();
              }, _.prototype.init = function() {
                var y = this;
                this.options.plugins && this.options.plugins.length && this.options.plugins.forEach(function(g) {
                  h.Litepicker.prototype.hasOwnProperty(g) ? h.Litepicker.prototype[g].init.call(y, y) : console.warn("Litepicker: plugin \xAB" + g + "\xBB not found.");
                });
              }, _.prototype.parseInput = function() {
                var y = this.options.delimiter, g = new RegExp("" + y), x = this.options.element instanceof HTMLInputElement ? this.options.element.value.split(y) : [];
                if (this.options.elementEnd) {
                  if (this.options.element instanceof HTMLInputElement && this.options.element.value.length && this.options.elementEnd instanceof HTMLInputElement && this.options.elementEnd.value.length) return [
                    new c.DateTime(this.options.element.value, this.options.format),
                    new c.DateTime(this.options.elementEnd.value, this.options.format)
                  ];
                } else if (this.options.singleMode) {
                  if (this.options.element instanceof HTMLInputElement && this.options.element.value.length) return [
                    new c.DateTime(this.options.element.value, this.options.format)
                  ];
                } else if (this.options.element instanceof HTMLInputElement && g.test(this.options.element.value) && x.length && x.length % 2 == 0) {
                  var v = x.slice(0, x.length / 2).join(y), E = x.slice(x.length / 2).join(y);
                  return [
                    new c.DateTime(v, this.options.format),
                    new c.DateTime(E, this.options.format)
                  ];
                }
                return [];
              }, _.prototype.isShowning = function() {
                return this.ui && this.ui.style.display !== "none";
              }, _.prototype.findPosition = function(y) {
                var g = y.getBoundingClientRect(), x = this.ui.getBoundingClientRect(), v = this.options.position.split(" "), E = window.scrollX || window.pageXOffset, T = window.scrollY || window.pageYOffset, M = 0, P = 0;
                if (v[0] !== "auto" && /top|bottom/.test(v[0])) M = g[v[0]] + T, v[0] === "top" && (M -= x.height);
                else {
                  M = g.bottom + T;
                  var R = g.bottom + x.height > window.innerHeight, d = g.top + T - x.height >= x.height;
                  R && d && (M = g.top + T - x.height);
                }
                if (/left|right/.test(v[0]) || v[1] && v[1] !== "auto" && /left|right/.test(v[1])) P = /left|right/.test(v[0]) ? g[v[0]] + E : g[v[1]] + E, v[0] !== "right" && v[1] !== "right" || (P -= x.width);
                else {
                  P = g.left + E, R = g.left + x.width > window.innerWidth;
                  var N = g.right + E - x.width >= 0;
                  R && N && (P = g.right + E - x.width);
                }
                return {
                  left: P,
                  top: M
                };
              }, _;
            }(l.EventEmitter);
            n.LPCore = f;
          },
          function(t, n, i) {
            var r, o = typeof Reflect == "object" ? Reflect : null, a = o && typeof o.apply == "function" ? o.apply : function(E, T, M) {
              return Function.prototype.apply.call(E, T, M);
            };
            r = o && typeof o.ownKeys == "function" ? o.ownKeys : Object.getOwnPropertySymbols ? function(E) {
              return Object.getOwnPropertyNames(E).concat(Object.getOwnPropertySymbols(E));
            } : function(E) {
              return Object.getOwnPropertyNames(E);
            };
            var l = Number.isNaN || function(E) {
              return E != E;
            };
            function c() {
              c.init.call(this);
            }
            t.exports = c, c.EventEmitter = c, c.prototype._events = void 0, c.prototype._eventsCount = 0, c.prototype._maxListeners = void 0;
            var h = 10;
            function f(E) {
              return E._maxListeners === void 0 ? c.defaultMaxListeners : E._maxListeners;
            }
            function m(E, T, M, P) {
              var R, d, N, w;
              if (typeof M != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof M);
              if ((d = E._events) === void 0 ? (d = E._events = /* @__PURE__ */ Object.create(null), E._eventsCount = 0) : (d.newListener !== void 0 && (E.emit("newListener", T, M.listener ? M.listener : M), d = E._events), N = d[T]), N === void 0) N = d[T] = M, ++E._eventsCount;
              else if (typeof N == "function" ? N = d[T] = P ? [
                M,
                N
              ] : [
                N,
                M
              ] : P ? N.unshift(M) : N.push(M), (R = f(E)) > 0 && N.length > R && !N.warned) {
                N.warned = true;
                var D = new Error("Possible EventEmitter memory leak detected. " + N.length + " " + String(T) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                D.name = "MaxListenersExceededWarning", D.emitter = E, D.type = T, D.count = N.length, w = D, console && console.warn && console.warn(w);
              }
              return E;
            }
            function _() {
              for (var E = [], T = 0; T < arguments.length; T++) E.push(arguments[T]);
              this.fired || (this.target.removeListener(this.type, this.wrapFn), this.fired = true, a(this.listener, this.target, E));
            }
            function y(E, T, M) {
              var P = {
                fired: false,
                wrapFn: void 0,
                target: E,
                type: T,
                listener: M
              }, R = _.bind(P);
              return R.listener = M, P.wrapFn = R, R;
            }
            function g(E, T, M) {
              var P = E._events;
              if (P === void 0) return [];
              var R = P[T];
              return R === void 0 ? [] : typeof R == "function" ? M ? [
                R.listener || R
              ] : [
                R
              ] : M ? function(d) {
                for (var N = new Array(d.length), w = 0; w < N.length; ++w) N[w] = d[w].listener || d[w];
                return N;
              }(R) : v(R, R.length);
            }
            function x(E) {
              var T = this._events;
              if (T !== void 0) {
                var M = T[E];
                if (typeof M == "function") return 1;
                if (M !== void 0) return M.length;
              }
              return 0;
            }
            function v(E, T) {
              for (var M = new Array(T), P = 0; P < T; ++P) M[P] = E[P];
              return M;
            }
            Object.defineProperty(c, "defaultMaxListeners", {
              enumerable: true,
              get: function() {
                return h;
              },
              set: function(E) {
                if (typeof E != "number" || E < 0 || l(E)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + E + ".");
                h = E;
              }
            }), c.init = function() {
              this._events !== void 0 && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
            }, c.prototype.setMaxListeners = function(E) {
              if (typeof E != "number" || E < 0 || l(E)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + E + ".");
              return this._maxListeners = E, this;
            }, c.prototype.getMaxListeners = function() {
              return f(this);
            }, c.prototype.emit = function(E) {
              for (var T = [], M = 1; M < arguments.length; M++) T.push(arguments[M]);
              var P = E === "error", R = this._events;
              if (R !== void 0) P = P && R.error === void 0;
              else if (!P) return false;
              if (P) {
                var d;
                if (T.length > 0 && (d = T[0]), d instanceof Error) throw d;
                var N = new Error("Unhandled error." + (d ? " (" + d.message + ")" : ""));
                throw N.context = d, N;
              }
              var w = R[E];
              if (w === void 0) return false;
              if (typeof w == "function") a(w, this, T);
              else {
                var D = w.length, B = v(w, D);
                for (M = 0; M < D; ++M) a(B[M], this, T);
              }
              return true;
            }, c.prototype.addListener = function(E, T) {
              return m(this, E, T, false);
            }, c.prototype.on = c.prototype.addListener, c.prototype.prependListener = function(E, T) {
              return m(this, E, T, true);
            }, c.prototype.once = function(E, T) {
              if (typeof T != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof T);
              return this.on(E, y(this, E, T)), this;
            }, c.prototype.prependOnceListener = function(E, T) {
              if (typeof T != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof T);
              return this.prependListener(E, y(this, E, T)), this;
            }, c.prototype.removeListener = function(E, T) {
              var M, P, R, d, N;
              if (typeof T != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof T);
              if ((P = this._events) === void 0) return this;
              if ((M = P[E]) === void 0) return this;
              if (M === T || M.listener === T) --this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete P[E], P.removeListener && this.emit("removeListener", E, M.listener || T));
              else if (typeof M != "function") {
                for (R = -1, d = M.length - 1; d >= 0; d--) if (M[d] === T || M[d].listener === T) {
                  N = M[d].listener, R = d;
                  break;
                }
                if (R < 0) return this;
                R === 0 ? M.shift() : function(w, D) {
                  for (; D + 1 < w.length; D++) w[D] = w[D + 1];
                  w.pop();
                }(M, R), M.length === 1 && (P[E] = M[0]), P.removeListener !== void 0 && this.emit("removeListener", E, N || T);
              }
              return this;
            }, c.prototype.off = c.prototype.removeListener, c.prototype.removeAllListeners = function(E) {
              var T, M, P;
              if ((M = this._events) === void 0) return this;
              if (M.removeListener === void 0) return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : M[E] !== void 0 && (--this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete M[E]), this;
              if (arguments.length === 0) {
                var R, d = Object.keys(M);
                for (P = 0; P < d.length; ++P) (R = d[P]) !== "removeListener" && this.removeAllListeners(R);
                return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
              }
              if (typeof (T = M[E]) == "function") this.removeListener(E, T);
              else if (T !== void 0) for (P = T.length - 1; P >= 0; P--) this.removeListener(E, T[P]);
              return this;
            }, c.prototype.listeners = function(E) {
              return g(this, E, true);
            }, c.prototype.rawListeners = function(E) {
              return g(this, E, false);
            }, c.listenerCount = function(E, T) {
              return typeof E.listenerCount == "function" ? E.listenerCount(T) : x.call(E, T);
            }, c.prototype.listenerCount = x, c.prototype.eventNames = function() {
              return this._eventsCount > 0 ? r(this._events) : [];
            };
          },
          function(t, n, i) {
            (n = i(9)(false)).push([
              t.i,
              `:root{--litepicker-container-months-color-bg: #fff;--litepicker-container-months-box-shadow-color: #ddd;--litepicker-footer-color-bg: #fafafa;--litepicker-footer-box-shadow-color: #ddd;--litepicker-tooltip-color-bg: #fff;--litepicker-month-header-color: #333;--litepicker-button-prev-month-color: #9e9e9e;--litepicker-button-next-month-color: #9e9e9e;--litepicker-button-prev-month-color-hover: #2196f3;--litepicker-button-next-month-color-hover: #2196f3;--litepicker-month-width: calc(var(--litepicker-day-width) * 7);--litepicker-month-weekday-color: #9e9e9e;--litepicker-month-week-number-color: #9e9e9e;--litepicker-day-width: 38px;--litepicker-day-color: #333;--litepicker-day-color-hover: #2196f3;--litepicker-is-today-color: #f44336;--litepicker-is-in-range-color: #bbdefb;--litepicker-is-locked-color: #9e9e9e;--litepicker-is-start-color: #fff;--litepicker-is-start-color-bg: #2196f3;--litepicker-is-end-color: #fff;--litepicker-is-end-color-bg: #2196f3;--litepicker-button-cancel-color: #fff;--litepicker-button-cancel-color-bg: #9e9e9e;--litepicker-button-apply-color: #fff;--litepicker-button-apply-color-bg: #2196f3;--litepicker-button-reset-color: #909090;--litepicker-button-reset-color-hover: #2196f3;--litepicker-highlighted-day-color: #333;--litepicker-highlighted-day-color-bg: #ffeb3b}.show-week-numbers{--litepicker-month-width: calc(var(--litepicker-day-width) * 8)}.litepicker{font-family:-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;font-size:0.8em;display:none}.litepicker button{border:none;background:none}.litepicker .container__main{display:-webkit-box;display:-ms-flexbox;display:flex}.litepicker .container__months{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;background-color:var(--litepicker-container-months-color-bg);border-radius:5px;-webkit-box-shadow:0 0 5px var(--litepicker-container-months-box-shadow-color);box-shadow:0 0 5px var(--litepicker-container-months-box-shadow-color);width:calc(var(--litepicker-month-width) + 10px);-webkit-box-sizing:content-box;box-sizing:content-box}.litepicker .container__months.columns-2{width:calc((var(--litepicker-month-width) * 2) + 20px)}.litepicker .container__months.columns-3{width:calc((var(--litepicker-month-width) * 3) + 30px)}.litepicker .container__months.columns-4{width:calc((var(--litepicker-month-width) * 4) + 40px)}.litepicker .container__months.split-view .month-item-header .button-previous-month,.litepicker .container__months.split-view .month-item-header .button-next-month{visibility:visible}.litepicker .container__months .month-item{padding:5px;width:var(--litepicker-month-width);-webkit-box-sizing:content-box;box-sizing:content-box}.litepicker .container__months .month-item-header{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;font-weight:500;padding:10px 5px;text-align:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:var(--litepicker-month-header-color)}.litepicker .container__months .month-item-header div{-webkit-box-flex:1;-ms-flex:1;flex:1}.litepicker .container__months .month-item-header div>.month-item-name{margin-right:5px}.litepicker .container__months .month-item-header div>.month-item-year{padding:0}.litepicker .container__months .month-item-header .reset-button{color:var(--litepicker-button-reset-color)}.litepicker .container__months .month-item-header .reset-button>svg{fill:var(--litepicker-button-reset-color)}.litepicker .container__months .month-item-header .reset-button *{pointer-events:none}.litepicker .container__months .month-item-header .reset-button:hover{color:var(--litepicker-button-reset-color-hover)}.litepicker .container__months .month-item-header .reset-button:hover>svg{fill:var(--litepicker-button-reset-color-hover)}.litepicker .container__months .month-item-header .button-previous-month,.litepicker .container__months .month-item-header .button-next-month{visibility:hidden;text-decoration:none;padding:3px 5px;border-radius:3px;-webkit-transition:color 0.3s, border 0.3s;transition:color 0.3s, border 0.3s;cursor:default}.litepicker .container__months .month-item-header .button-previous-month *,.litepicker .container__months .month-item-header .button-next-month *{pointer-events:none}.litepicker .container__months .month-item-header .button-previous-month{color:var(--litepicker-button-prev-month-color)}.litepicker .container__months .month-item-header .button-previous-month>svg,.litepicker .container__months .month-item-header .button-previous-month>img{fill:var(--litepicker-button-prev-month-color)}.litepicker .container__months .month-item-header .button-previous-month:hover{color:var(--litepicker-button-prev-month-color-hover)}.litepicker .container__months .month-item-header .button-previous-month:hover>svg{fill:var(--litepicker-button-prev-month-color-hover)}.litepicker .container__months .month-item-header .button-next-month{color:var(--litepicker-button-next-month-color)}.litepicker .container__months .month-item-header .button-next-month>svg,.litepicker .container__months .month-item-header .button-next-month>img{fill:var(--litepicker-button-next-month-color)}.litepicker .container__months .month-item-header .button-next-month:hover{color:var(--litepicker-button-next-month-color-hover)}.litepicker .container__months .month-item-header .button-next-month:hover>svg{fill:var(--litepicker-button-next-month-color-hover)}.litepicker .container__months .month-item-weekdays-row{display:-webkit-box;display:-ms-flexbox;display:flex;justify-self:center;-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;color:var(--litepicker-month-weekday-color)}.litepicker .container__months .month-item-weekdays-row>div{padding:5px 0;font-size:85%;-webkit-box-flex:1;-ms-flex:1;flex:1;width:var(--litepicker-day-width);text-align:center}.litepicker .container__months .month-item:first-child .button-previous-month{visibility:visible}.litepicker .container__months .month-item:last-child .button-next-month{visibility:visible}.litepicker .container__months .month-item.no-previous-month .button-previous-month{visibility:hidden}.litepicker .container__months .month-item.no-next-month .button-next-month{visibility:hidden}.litepicker .container__days{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;justify-self:center;-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:center;-webkit-box-sizing:content-box;box-sizing:content-box}.litepicker .container__days>div,.litepicker .container__days>a{padding:5px 0;width:var(--litepicker-day-width)}.litepicker .container__days .day-item{color:var(--litepicker-day-color);text-align:center;text-decoration:none;border-radius:3px;-webkit-transition:color 0.3s, border 0.3s;transition:color 0.3s, border 0.3s;cursor:default}.litepicker .container__days .day-item:hover{color:var(--litepicker-day-color-hover);-webkit-box-shadow:inset 0 0 0 1px var(--litepicker-day-color-hover);box-shadow:inset 0 0 0 1px var(--litepicker-day-color-hover)}.litepicker .container__days .day-item.is-today{color:var(--litepicker-is-today-color)}.litepicker .container__days .day-item.is-locked{color:var(--litepicker-is-locked-color)}.litepicker .container__days .day-item.is-locked:hover{color:var(--litepicker-is-locked-color);-webkit-box-shadow:none;box-shadow:none;cursor:default}.litepicker .container__days .day-item.is-in-range{background-color:var(--litepicker-is-in-range-color);border-radius:0}.litepicker .container__days .day-item.is-start-date{color:var(--litepicker-is-start-color);background-color:var(--litepicker-is-start-color-bg);border-top-left-radius:5px;border-bottom-left-radius:5px;border-top-right-radius:0;border-bottom-right-radius:0}.litepicker .container__days .day-item.is-start-date.is-flipped{border-top-left-radius:0;border-bottom-left-radius:0;border-top-right-radius:5px;border-bottom-right-radius:5px}.litepicker .container__days .day-item.is-end-date{color:var(--litepicker-is-end-color);background-color:var(--litepicker-is-end-color-bg);border-top-left-radius:0;border-bottom-left-radius:0;border-top-right-radius:5px;border-bottom-right-radius:5px}.litepicker .container__days .day-item.is-end-date.is-flipped{border-top-left-radius:5px;border-bottom-left-radius:5px;border-top-right-radius:0;border-bottom-right-radius:0}.litepicker .container__days .day-item.is-start-date.is-end-date{border-top-left-radius:5px;border-bottom-left-radius:5px;border-top-right-radius:5px;border-bottom-right-radius:5px}.litepicker .container__days .day-item.is-highlighted{color:var(--litepicker-highlighted-day-color);background-color:var(--litepicker-highlighted-day-color-bg)}.litepicker .container__days .week-number{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;color:var(--litepicker-month-week-number-color);font-size:85%}.litepicker .container__footer{text-align:right;padding:10px 5px;margin:0 5px;background-color:var(--litepicker-footer-color-bg);-webkit-box-shadow:inset 0px 3px 3px 0px var(--litepicker-footer-box-shadow-color);box-shadow:inset 0px 3px 3px 0px var(--litepicker-footer-box-shadow-color);border-bottom-left-radius:5px;border-bottom-right-radius:5px}.litepicker .container__footer .preview-date-range{margin-right:10px;font-size:90%}.litepicker .container__footer .button-cancel{background-color:var(--litepicker-button-cancel-color-bg);color:var(--litepicker-button-cancel-color);border:0;padding:3px 7px 4px;border-radius:3px}.litepicker .container__footer .button-cancel *{pointer-events:none}.litepicker .container__footer .button-apply{background-color:var(--litepicker-button-apply-color-bg);color:var(--litepicker-button-apply-color);border:0;padding:3px 7px 4px;border-radius:3px;margin-left:10px;margin-right:10px}.litepicker .container__footer .button-apply:disabled{opacity:0.7}.litepicker .container__footer .button-apply *{pointer-events:none}.litepicker .container__tooltip{position:absolute;margin-top:-4px;padding:4px 8px;border-radius:4px;background-color:var(--litepicker-tooltip-color-bg);-webkit-box-shadow:0 1px 3px rgba(0,0,0,0.25);box-shadow:0 1px 3px rgba(0,0,0,0.25);white-space:nowrap;font-size:11px;pointer-events:none;visibility:hidden}.litepicker .container__tooltip:before{position:absolute;bottom:-5px;left:calc(50% - 5px);border-top:5px solid rgba(0,0,0,0.12);border-right:5px solid transparent;border-left:5px solid transparent;content:""}.litepicker .container__tooltip:after{position:absolute;bottom:-4px;left:calc(50% - 4px);border-top:4px solid var(--litepicker-tooltip-color-bg);border-right:4px solid transparent;border-left:4px solid transparent;content:""}
`,
              ""
            ]), n.locals = {
              showWeekNumbers: "show-week-numbers",
              litepicker: "litepicker",
              containerMain: "container__main",
              containerMonths: "container__months",
              columns2: "columns-2",
              columns3: "columns-3",
              columns4: "columns-4",
              splitView: "split-view",
              monthItemHeader: "month-item-header",
              buttonPreviousMonth: "button-previous-month",
              buttonNextMonth: "button-next-month",
              monthItem: "month-item",
              monthItemName: "month-item-name",
              monthItemYear: "month-item-year",
              resetButton: "reset-button",
              monthItemWeekdaysRow: "month-item-weekdays-row",
              noPreviousMonth: "no-previous-month",
              noNextMonth: "no-next-month",
              containerDays: "container__days",
              dayItem: "day-item",
              isToday: "is-today",
              isLocked: "is-locked",
              isInRange: "is-in-range",
              isStartDate: "is-start-date",
              isFlipped: "is-flipped",
              isEndDate: "is-end-date",
              isHighlighted: "is-highlighted",
              weekNumber: "week-number",
              containerFooter: "container__footer",
              previewDateRange: "preview-date-range",
              buttonCancel: "button-cancel",
              buttonApply: "button-apply",
              containerTooltip: "container__tooltip"
            }, t.exports = n;
          },
          function(t, n, i) {
            t.exports = function(r) {
              var o = [];
              return o.toString = function() {
                return this.map(function(a) {
                  var l = function(c, h) {
                    var f = c[1] || "", m = c[3];
                    if (!m) return f;
                    if (h && typeof btoa == "function") {
                      var _ = (g = m, x = btoa(unescape(encodeURIComponent(JSON.stringify(g)))), v = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(x), "/*# ".concat(v, " */")), y = m.sources.map(function(E) {
                        return "/*# sourceURL=".concat(m.sourceRoot || "").concat(E, " */");
                      });
                      return [
                        f
                      ].concat(y).concat([
                        _
                      ]).join(`
`);
                    }
                    var g, x, v;
                    return [
                      f
                    ].join(`
`);
                  }(a, r);
                  return a[2] ? "@media ".concat(a[2], " {").concat(l, "}") : l;
                }).join("");
              }, o.i = function(a, l, c) {
                typeof a == "string" && (a = [
                  [
                    null,
                    a,
                    ""
                  ]
                ]);
                var h = {};
                if (c) for (var f = 0; f < this.length; f++) {
                  var m = this[f][0];
                  m != null && (h[m] = true);
                }
                for (var _ = 0; _ < a.length; _++) {
                  var y = [].concat(a[_]);
                  c && h[y[0]] || (l && (y[2] ? y[2] = "".concat(l, " and ").concat(y[2]) : y[2] = l), o.push(y));
                }
              }, o;
            };
          },
          function(t, n, i) {
            var r, o = {}, a = function() {
              return r === void 0 && (r = !!(window && document && document.all && !window.atob)), r;
            }, l = /* @__PURE__ */ function() {
              var T = {};
              return function(M) {
                if (T[M] === void 0) {
                  var P = document.querySelector(M);
                  if (window.HTMLIFrameElement && P instanceof window.HTMLIFrameElement) try {
                    P = P.contentDocument.head;
                  } catch {
                    P = null;
                  }
                  T[M] = P;
                }
                return T[M];
              };
            }();
            function c(T, M) {
              for (var P = [], R = {}, d = 0; d < T.length; d++) {
                var N = T[d], w = M.base ? N[0] + M.base : N[0], D = {
                  css: N[1],
                  media: N[2],
                  sourceMap: N[3]
                };
                R[w] ? R[w].parts.push(D) : P.push(R[w] = {
                  id: w,
                  parts: [
                    D
                  ]
                });
              }
              return P;
            }
            function h(T, M) {
              for (var P = 0; P < T.length; P++) {
                var R = T[P], d = o[R.id], N = 0;
                if (d) {
                  for (d.refs++; N < d.parts.length; N++) d.parts[N](R.parts[N]);
                  for (; N < R.parts.length; N++) d.parts.push(E(R.parts[N], M));
                } else {
                  for (var w = []; N < R.parts.length; N++) w.push(E(R.parts[N], M));
                  o[R.id] = {
                    id: R.id,
                    refs: 1,
                    parts: w
                  };
                }
              }
            }
            function f(T) {
              var M = document.createElement("style");
              if (T.attributes.nonce === void 0) {
                var P = i.nc;
                P && (T.attributes.nonce = P);
              }
              if (Object.keys(T.attributes).forEach(function(d) {
                M.setAttribute(d, T.attributes[d]);
              }), typeof T.insert == "function") T.insert(M);
              else {
                var R = l(T.insert || "head");
                if (!R) throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
                R.appendChild(M);
              }
              return M;
            }
            var m, _ = (m = [], function(T, M) {
              return m[T] = M, m.filter(Boolean).join(`
`);
            });
            function y(T, M, P, R) {
              var d = P ? "" : R.css;
              if (T.styleSheet) T.styleSheet.cssText = _(M, d);
              else {
                var N = document.createTextNode(d), w = T.childNodes;
                w[M] && T.removeChild(w[M]), w.length ? T.insertBefore(N, w[M]) : T.appendChild(N);
              }
            }
            function g(T, M, P) {
              var R = P.css, d = P.media, N = P.sourceMap;
              if (d && T.setAttribute("media", d), N && btoa && (R += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(N)))), " */")), T.styleSheet) T.styleSheet.cssText = R;
              else {
                for (; T.firstChild; ) T.removeChild(T.firstChild);
                T.appendChild(document.createTextNode(R));
              }
            }
            var x = null, v = 0;
            function E(T, M) {
              var P, R, d;
              if (M.singleton) {
                var N = v++;
                P = x || (x = f(M)), R = y.bind(null, P, N, false), d = y.bind(null, P, N, true);
              } else P = f(M), R = g.bind(null, P, M), d = function() {
                (function(w) {
                  if (w.parentNode === null) return false;
                  w.parentNode.removeChild(w);
                })(P);
              };
              return R(T), function(w) {
                if (w) {
                  if (w.css === T.css && w.media === T.media && w.sourceMap === T.sourceMap) return;
                  R(T = w);
                } else d();
              };
            }
            t.exports = function(T, M) {
              (M = M || {}).attributes = typeof M.attributes == "object" ? M.attributes : {}, M.singleton || typeof M.singleton == "boolean" || (M.singleton = a());
              var P = c(T, M);
              return h(P, M), function(R) {
                for (var d = [], N = 0; N < P.length; N++) {
                  var w = P[N], D = o[w.id];
                  D && (D.refs--, d.push(D));
                }
                R && h(c(R, M), M);
                for (var B = 0; B < d.length; B++) {
                  var Z = d[B];
                  if (Z.refs === 0) {
                    for (var G = 0; G < Z.parts.length; G++) Z.parts[G]();
                    delete o[Z.id];
                  }
                }
              };
            };
          },
          function(t, n, i) {
            var r = this && this.__assign || function() {
              return (r = Object.assign || function(c) {
                for (var h, f = 1, m = arguments.length; f < m; f++) for (var _ in h = arguments[f]) Object.prototype.hasOwnProperty.call(h, _) && (c[_] = h[_]);
                return c;
              }).apply(this, arguments);
            };
            Object.defineProperty(n, "__esModule", {
              value: true
            });
            var o = i(0), a = i(1), l = i(2);
            a.Litepicker.prototype.show = function(c) {
              c === void 0 && (c = null), this.emit("before:show", c);
              var h = c || this.options.element;
              if (this.triggerElement = h, !this.isShowning()) {
                if (this.options.inlineMode) return this.ui.style.position = "relative", this.ui.style.display = "inline-block", this.ui.style.top = null, this.ui.style.left = null, this.ui.style.bottom = null, void (this.ui.style.right = null);
                this.scrollToDate(c), this.render(), this.ui.style.position = "absolute", this.ui.style.display = "block", this.ui.style.zIndex = this.options.zIndex;
                var f = this.findPosition(h);
                this.ui.style.top = f.top + "px", this.ui.style.left = f.left + "px", this.ui.style.right = null, this.ui.style.bottom = null, this.emit("show", c);
              }
            }, a.Litepicker.prototype.hide = function() {
              this.isShowning() && (this.datePicked.length = 0, this.updateInput(), this.options.inlineMode ? this.render() : (this.ui.style.display = "none", this.emit("hide")));
            }, a.Litepicker.prototype.getDate = function() {
              return this.getStartDate();
            }, a.Litepicker.prototype.getStartDate = function() {
              return this.options.startDate ? this.options.startDate.clone() : null;
            }, a.Litepicker.prototype.getEndDate = function() {
              return this.options.endDate ? this.options.endDate.clone() : null;
            }, a.Litepicker.prototype.setDate = function(c, h) {
              h === void 0 && (h = false);
              var f = new o.DateTime(c, this.options.format, this.options.lang);
              l.dateIsLocked(f, this.options, [
                f
              ]) && !h ? this.emit("error:date", f) : (this.setStartDate(c), this.options.inlineMode && this.render(), this.emit("selected", this.getDate()));
            }, a.Litepicker.prototype.setStartDate = function(c) {
              c && (this.options.startDate = new o.DateTime(c, this.options.format, this.options.lang), this.updateInput());
            }, a.Litepicker.prototype.setEndDate = function(c) {
              c && (this.options.endDate = new o.DateTime(c, this.options.format, this.options.lang), this.options.startDate.getTime() > this.options.endDate.getTime() && (this.options.endDate = this.options.startDate.clone(), this.options.startDate = new o.DateTime(c, this.options.format, this.options.lang)), this.updateInput());
            }, a.Litepicker.prototype.setDateRange = function(c, h, f) {
              f === void 0 && (f = false), this.triggerElement = void 0;
              var m = new o.DateTime(c, this.options.format, this.options.lang), _ = new o.DateTime(h, this.options.format, this.options.lang);
              (this.options.disallowLockDaysInRange ? l.rangeIsLocked([
                m,
                _
              ], this.options) : l.dateIsLocked(m, this.options, [
                m,
                _
              ]) || l.dateIsLocked(_, this.options, [
                m,
                _
              ])) && !f ? this.emit("error:range", [
                m,
                _
              ]) : (this.setStartDate(m), this.setEndDate(_), this.options.inlineMode && this.render(), this.updateInput(), this.emit("selected", this.getStartDate(), this.getEndDate()));
            }, a.Litepicker.prototype.gotoDate = function(c, h) {
              h === void 0 && (h = 0);
              var f = new o.DateTime(c);
              f.setDate(1), this.calendars[h] = f.clone(), this.render();
            }, a.Litepicker.prototype.setLockDays = function(c) {
              this.options.lockDays = o.DateTime.convertArray(c, this.options.lockDaysFormat), this.render();
            }, a.Litepicker.prototype.setHighlightedDays = function(c) {
              this.options.highlightedDays = o.DateTime.convertArray(c, this.options.highlightedDaysFormat), this.render();
            }, a.Litepicker.prototype.setOptions = function(c) {
              delete c.element, delete c.elementEnd, delete c.parentEl, c.startDate && (c.startDate = new o.DateTime(c.startDate, this.options.format, this.options.lang)), c.endDate && (c.endDate = new o.DateTime(c.endDate, this.options.format, this.options.lang));
              var h = r(r({}, this.options.dropdowns), c.dropdowns), f = r(r({}, this.options.buttonText), c.buttonText), m = r(r({}, this.options.tooltipText), c.tooltipText);
              this.options = r(r({}, this.options), c), this.options.dropdowns = r({}, h), this.options.buttonText = r({}, f), this.options.tooltipText = r({}, m), !this.options.singleMode || this.options.startDate instanceof o.DateTime || (this.options.startDate = null, this.options.endDate = null), this.options.singleMode || this.options.startDate instanceof o.DateTime && this.options.endDate instanceof o.DateTime || (this.options.startDate = null, this.options.endDate = null);
              for (var _ = 0; _ < this.options.numberOfMonths; _ += 1) {
                var y = this.options.startDate ? this.options.startDate.clone() : new o.DateTime();
                y.setDate(1), y.setMonth(y.getMonth() + _), this.calendars[_] = y;
              }
              this.options.lockDays.length && (this.options.lockDays = o.DateTime.convertArray(this.options.lockDays, this.options.lockDaysFormat)), this.options.highlightedDays.length && (this.options.highlightedDays = o.DateTime.convertArray(this.options.highlightedDays, this.options.highlightedDaysFormat)), this.render(), this.options.inlineMode && this.show(), this.updateInput();
            }, a.Litepicker.prototype.clearSelection = function() {
              this.options.startDate = null, this.options.endDate = null, this.datePicked.length = 0, this.updateInput(), this.isShowning() && this.render(), this.emit("clear:selection");
            }, a.Litepicker.prototype.destroy = function() {
              this.ui && this.ui.parentNode && (this.ui.parentNode.removeChild(this.ui), this.ui = null), this.emit("destroy");
            };
          }
        ]);
      });
    }(sh)), sh.exports;
  }
  Z1();
  var yc = {
    exports: {}
  };
  var J1 = yc.exports, Rm;
  function Q1() {
    return Rm || (Rm = 1, function(s) {
      (function(e, t) {
        s.exports = e.document ? t(e, true) : function(n) {
          if (!n.document) throw new Error("jQuery requires a window with a document");
          return t(n);
        };
      })(typeof window < "u" ? window : J1, function(e, t) {
        var n = [], i = Object.getPrototypeOf, r = n.slice, o = n.flat ? function(u) {
          return n.flat.call(u);
        } : function(u) {
          return n.concat.apply([], u);
        }, a = n.push, l = n.indexOf, c = {}, h = c.toString, f = c.hasOwnProperty, m = f.toString, _ = m.call(Object), y = {}, g = function(p) {
          return typeof p == "function" && typeof p.nodeType != "number" && typeof p.item != "function";
        }, x = function(p) {
          return p != null && p === p.window;
        }, v = e.document, E = {
          type: true,
          src: true,
          nonce: true,
          noModule: true
        };
        function T(u, p, b) {
          b = b || v;
          var S, A, C = b.createElement("script");
          if (C.text = u, p) for (S in E) A = p[S] || p.getAttribute && p.getAttribute(S), A && C.setAttribute(S, A);
          b.head.appendChild(C).parentNode.removeChild(C);
        }
        function M(u) {
          return u == null ? u + "" : typeof u == "object" || typeof u == "function" ? c[h.call(u)] || "object" : typeof u;
        }
        var P = "3.7.1", R = /HTML$/i, d = function(u, p) {
          return new d.fn.init(u, p);
        };
        d.fn = d.prototype = {
          jquery: P,
          constructor: d,
          length: 0,
          toArray: function() {
            return r.call(this);
          },
          get: function(u) {
            return u == null ? r.call(this) : u < 0 ? this[u + this.length] : this[u];
          },
          pushStack: function(u) {
            var p = d.merge(this.constructor(), u);
            return p.prevObject = this, p;
          },
          each: function(u) {
            return d.each(this, u);
          },
          map: function(u) {
            return this.pushStack(d.map(this, function(p, b) {
              return u.call(p, b, p);
            }));
          },
          slice: function() {
            return this.pushStack(r.apply(this, arguments));
          },
          first: function() {
            return this.eq(0);
          },
          last: function() {
            return this.eq(-1);
          },
          even: function() {
            return this.pushStack(d.grep(this, function(u, p) {
              return (p + 1) % 2;
            }));
          },
          odd: function() {
            return this.pushStack(d.grep(this, function(u, p) {
              return p % 2;
            }));
          },
          eq: function(u) {
            var p = this.length, b = +u + (u < 0 ? p : 0);
            return this.pushStack(b >= 0 && b < p ? [
              this[b]
            ] : []);
          },
          end: function() {
            return this.prevObject || this.constructor();
          },
          push: a,
          sort: n.sort,
          splice: n.splice
        }, d.extend = d.fn.extend = function() {
          var u, p, b, S, A, C, L = arguments[0] || {}, H = 1, z = arguments.length, X = false;
          for (typeof L == "boolean" && (X = L, L = arguments[H] || {}, H++), typeof L != "object" && !g(L) && (L = {}), H === z && (L = this, H--); H < z; H++) if ((u = arguments[H]) != null) for (p in u) S = u[p], !(p === "__proto__" || L === S) && (X && S && (d.isPlainObject(S) || (A = Array.isArray(S))) ? (b = L[p], A && !Array.isArray(b) ? C = [] : !A && !d.isPlainObject(b) ? C = {} : C = b, A = false, L[p] = d.extend(X, C, S)) : S !== void 0 && (L[p] = S));
          return L;
        }, d.extend({
          expando: "jQuery" + (P + Math.random()).replace(/\D/g, ""),
          isReady: true,
          error: function(u) {
            throw new Error(u);
          },
          noop: function() {
          },
          isPlainObject: function(u) {
            var p, b;
            return !u || h.call(u) !== "[object Object]" ? false : (p = i(u), p ? (b = f.call(p, "constructor") && p.constructor, typeof b == "function" && m.call(b) === _) : true);
          },
          isEmptyObject: function(u) {
            var p;
            for (p in u) return false;
            return true;
          },
          globalEval: function(u, p, b) {
            T(u, {
              nonce: p && p.nonce
            }, b);
          },
          each: function(u, p) {
            var b, S = 0;
            if (N(u)) for (b = u.length; S < b && p.call(u[S], S, u[S]) !== false; S++) ;
            else for (S in u) if (p.call(u[S], S, u[S]) === false) break;
            return u;
          },
          text: function(u) {
            var p, b = "", S = 0, A = u.nodeType;
            if (!A) for (; p = u[S++]; ) b += d.text(p);
            return A === 1 || A === 11 ? u.textContent : A === 9 ? u.documentElement.textContent : A === 3 || A === 4 ? u.nodeValue : b;
          },
          makeArray: function(u, p) {
            var b = p || [];
            return u != null && (N(Object(u)) ? d.merge(b, typeof u == "string" ? [
              u
            ] : u) : a.call(b, u)), b;
          },
          inArray: function(u, p, b) {
            return p == null ? -1 : l.call(p, u, b);
          },
          isXMLDoc: function(u) {
            var p = u && u.namespaceURI, b = u && (u.ownerDocument || u).documentElement;
            return !R.test(p || b && b.nodeName || "HTML");
          },
          merge: function(u, p) {
            for (var b = +p.length, S = 0, A = u.length; S < b; S++) u[A++] = p[S];
            return u.length = A, u;
          },
          grep: function(u, p, b) {
            for (var S, A = [], C = 0, L = u.length, H = !b; C < L; C++) S = !p(u[C], C), S !== H && A.push(u[C]);
            return A;
          },
          map: function(u, p, b) {
            var S, A, C = 0, L = [];
            if (N(u)) for (S = u.length; C < S; C++) A = p(u[C], C, b), A != null && L.push(A);
            else for (C in u) A = p(u[C], C, b), A != null && L.push(A);
            return o(L);
          },
          guid: 1,
          support: y
        }), typeof Symbol == "function" && (d.fn[Symbol.iterator] = n[Symbol.iterator]), d.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(u, p) {
          c["[object " + p + "]"] = p.toLowerCase();
        });
        function N(u) {
          var p = !!u && "length" in u && u.length, b = M(u);
          return g(u) || x(u) ? false : b === "array" || p === 0 || typeof p == "number" && p > 0 && p - 1 in u;
        }
        function w(u, p) {
          return u.nodeName && u.nodeName.toLowerCase() === p.toLowerCase();
        }
        var D = n.pop, B = n.sort, Z = n.splice, G = "[\\x20\\t\\r\\n\\f]", Q = new RegExp("^" + G + "+|((?:^|[^\\\\])(?:\\\\.)*)" + G + "+$", "g");
        d.contains = function(u, p) {
          var b = p && p.parentNode;
          return u === b || !!(b && b.nodeType === 1 && (u.contains ? u.contains(b) : u.compareDocumentPosition && u.compareDocumentPosition(b) & 16));
        };
        var ue = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
        function te(u, p) {
          return p ? u === "\0" ? "\uFFFD" : u.slice(0, -1) + "\\" + u.charCodeAt(u.length - 1).toString(16) + " " : "\\" + u;
        }
        d.escapeSelector = function(u) {
          return (u + "").replace(ue, te);
        };
        var he = v, ie = a;
        (function() {
          var u, p, b, S, A, C = ie, L, H, z, X, oe, pe = d.expando, ee = 0, xe = 0, ut = Sl(), Lt = Sl(), gt = Sl(), Pn = Sl(), bn = function(F, W) {
            return F === W && (A = true), 0;
          }, Oi = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", Fi = "(?:\\\\[\\da-fA-F]{1,6}" + G + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", Ct = "\\[" + G + "*(" + Fi + ")(?:" + G + "*([*^$|!~]?=)" + G + `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + Fi + "))|)" + G + "*\\]", cs = ":(" + Fi + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + Ct + ")*)|.*)\\)|)", Ut = new RegExp(G + "+", "g"), an = new RegExp("^" + G + "*," + G + "*"), ga = new RegExp("^" + G + "*([>+~]|" + G + ")" + G + "*"), tu = new RegExp(G + "|>"), ki = new RegExp(cs), _a = new RegExp("^" + Fi + "$"), Bi = {
            ID: new RegExp("^#(" + Fi + ")"),
            CLASS: new RegExp("^\\.(" + Fi + ")"),
            TAG: new RegExp("^(" + Fi + "|[*])"),
            ATTR: new RegExp("^" + Ct),
            PSEUDO: new RegExp("^" + cs),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + G + "*(even|odd|(([+-]|)(\\d*)n|)" + G + "*(?:([+-]|)" + G + "*(\\d+)|))" + G + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + Oi + ")$", "i"),
            needsContext: new RegExp("^" + G + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + G + "*((?:-\\d)?\\d*)" + G + "*\\)|)(?=[^-]|$)", "i")
          }, Ir = /^(?:input|select|textarea|button)$/i, Nr = /^h\d$/i, vi = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, nu = /[+~]/, ar = new RegExp("\\\\[\\da-fA-F]{1,6}" + G + "?|\\\\([^\\r\\n\\f])", "g"), lr = function(F, W) {
            var J = "0x" + F.slice(1) - 65536;
            return W || (J < 0 ? String.fromCharCode(J + 65536) : String.fromCharCode(J >> 10 | 55296, J & 1023 | 56320));
          }, a0 = function() {
            Ur();
          }, l0 = Tl(function(F) {
            return F.disabled === true && w(F, "fieldset");
          }, {
            dir: "parentNode",
            next: "legend"
          });
          function c0() {
            try {
              return L.activeElement;
            } catch {
            }
          }
          try {
            C.apply(n = r.call(he.childNodes), he.childNodes), n[he.childNodes.length].nodeType;
          } catch {
            C = {
              apply: function(W, J) {
                ie.apply(W, r.call(J));
              },
              call: function(W) {
                ie.apply(W, r.call(arguments, 1));
              }
            };
          }
          function Xt(F, W, J, se) {
            var de, Ae, ke, $e, Be, Mt, ot, ft = W && W.ownerDocument, Tt = W ? W.nodeType : 9;
            if (J = J || [], typeof F != "string" || !F || Tt !== 1 && Tt !== 9 && Tt !== 11) return J;
            if (!se && (Ur(W), W = W || L, z)) {
              if (Tt !== 11 && (Be = vi.exec(F))) if (de = Be[1]) {
                if (Tt === 9) if (ke = W.getElementById(de)) {
                  if (ke.id === de) return C.call(J, ke), J;
                } else return J;
                else if (ft && (ke = ft.getElementById(de)) && Xt.contains(W, ke) && ke.id === de) return C.call(J, ke), J;
              } else {
                if (Be[2]) return C.apply(J, W.getElementsByTagName(F)), J;
                if ((de = Be[3]) && W.getElementsByClassName) return C.apply(J, W.getElementsByClassName(de)), J;
              }
              if (!Pn[F + " "] && (!X || !X.test(F))) {
                if (ot = F, ft = W, Tt === 1 && (tu.test(F) || ga.test(F))) {
                  for (ft = nu.test(F) && iu(W.parentNode) || W, (ft != W || !y.scope) && (($e = W.getAttribute("id")) ? $e = d.escapeSelector($e) : W.setAttribute("id", $e = pe)), Mt = va(F), Ae = Mt.length; Ae--; ) Mt[Ae] = ($e ? "#" + $e : ":scope") + " " + Ml(Mt[Ae]);
                  ot = Mt.join(",");
                }
                try {
                  return C.apply(J, ft.querySelectorAll(ot)), J;
                } catch {
                  Pn(F, true);
                } finally {
                  $e === pe && W.removeAttribute("id");
                }
              }
            }
            return Ed(F.replace(Q, "$1"), W, J, se);
          }
          function Sl() {
            var F = [];
            function W(J, se) {
              return F.push(J + " ") > p.cacheLength && delete W[F.shift()], W[J + " "] = se;
            }
            return W;
          }
          function Ci(F) {
            return F[pe] = true, F;
          }
          function qs(F) {
            var W = L.createElement("fieldset");
            try {
              return !!F(W);
            } catch {
              return false;
            } finally {
              W.parentNode && W.parentNode.removeChild(W), W = null;
            }
          }
          function u0(F) {
            return function(W) {
              return w(W, "input") && W.type === F;
            };
          }
          function h0(F) {
            return function(W) {
              return (w(W, "input") || w(W, "button")) && W.type === F;
            };
          }
          function Md(F) {
            return function(W) {
              return "form" in W ? W.parentNode && W.disabled === false ? "label" in W ? "label" in W.parentNode ? W.parentNode.disabled === F : W.disabled === F : W.isDisabled === F || W.isDisabled !== !F && l0(W) === F : W.disabled === F : "label" in W ? W.disabled === F : false;
            };
          }
          function us(F) {
            return Ci(function(W) {
              return W = +W, Ci(function(J, se) {
                for (var de, Ae = F([], J.length, W), ke = Ae.length; ke--; ) J[de = Ae[ke]] && (J[de] = !(se[de] = J[de]));
              });
            });
          }
          function iu(F) {
            return F && typeof F.getElementsByTagName < "u" && F;
          }
          function Ur(F) {
            var W, J = F ? F.ownerDocument || F : he;
            return J == L || J.nodeType !== 9 || !J.documentElement || (L = J, H = L.documentElement, z = !d.isXMLDoc(L), oe = H.matches || H.webkitMatchesSelector || H.msMatchesSelector, H.msMatchesSelector && he != L && (W = L.defaultView) && W.top !== W && W.addEventListener("unload", a0), y.getById = qs(function(se) {
              return H.appendChild(se).id = d.expando, !L.getElementsByName || !L.getElementsByName(d.expando).length;
            }), y.disconnectedMatch = qs(function(se) {
              return oe.call(se, "*");
            }), y.scope = qs(function() {
              return L.querySelectorAll(":scope");
            }), y.cssHas = qs(function() {
              try {
                return L.querySelector(":has(*,:jqfake)"), false;
              } catch {
                return true;
              }
            }), y.getById ? (p.filter.ID = function(se) {
              var de = se.replace(ar, lr);
              return function(Ae) {
                return Ae.getAttribute("id") === de;
              };
            }, p.find.ID = function(se, de) {
              if (typeof de.getElementById < "u" && z) {
                var Ae = de.getElementById(se);
                return Ae ? [
                  Ae
                ] : [];
              }
            }) : (p.filter.ID = function(se) {
              var de = se.replace(ar, lr);
              return function(Ae) {
                var ke = typeof Ae.getAttributeNode < "u" && Ae.getAttributeNode("id");
                return ke && ke.value === de;
              };
            }, p.find.ID = function(se, de) {
              if (typeof de.getElementById < "u" && z) {
                var Ae, ke, $e, Be = de.getElementById(se);
                if (Be) {
                  if (Ae = Be.getAttributeNode("id"), Ae && Ae.value === se) return [
                    Be
                  ];
                  for ($e = de.getElementsByName(se), ke = 0; Be = $e[ke++]; ) if (Ae = Be.getAttributeNode("id"), Ae && Ae.value === se) return [
                    Be
                  ];
                }
                return [];
              }
            }), p.find.TAG = function(se, de) {
              return typeof de.getElementsByTagName < "u" ? de.getElementsByTagName(se) : de.querySelectorAll(se);
            }, p.find.CLASS = function(se, de) {
              if (typeof de.getElementsByClassName < "u" && z) return de.getElementsByClassName(se);
            }, X = [], qs(function(se) {
              var de;
              H.appendChild(se).innerHTML = "<a id='" + pe + "' href='' disabled='disabled'></a><select id='" + pe + "-\r\\' disabled='disabled'><option selected=''></option></select>", se.querySelectorAll("[selected]").length || X.push("\\[" + G + "*(?:value|" + Oi + ")"), se.querySelectorAll("[id~=" + pe + "-]").length || X.push("~="), se.querySelectorAll("a#" + pe + "+*").length || X.push(".#.+[+~]"), se.querySelectorAll(":checked").length || X.push(":checked"), de = L.createElement("input"), de.setAttribute("type", "hidden"), se.appendChild(de).setAttribute("name", "D"), H.appendChild(se).disabled = true, se.querySelectorAll(":disabled").length !== 2 && X.push(":enabled", ":disabled"), de = L.createElement("input"), de.setAttribute("name", ""), se.appendChild(de), se.querySelectorAll("[name='']").length || X.push("\\[" + G + "*name" + G + "*=" + G + `*(?:''|"")`);
            }), y.cssHas || X.push(":has"), X = X.length && new RegExp(X.join("|")), bn = function(se, de) {
              if (se === de) return A = true, 0;
              var Ae = !se.compareDocumentPosition - !de.compareDocumentPosition;
              return Ae || (Ae = (se.ownerDocument || se) == (de.ownerDocument || de) ? se.compareDocumentPosition(de) : 1, Ae & 1 || !y.sortDetached && de.compareDocumentPosition(se) === Ae ? se === L || se.ownerDocument == he && Xt.contains(he, se) ? -1 : de === L || de.ownerDocument == he && Xt.contains(he, de) ? 1 : S ? l.call(S, se) - l.call(S, de) : 0 : Ae & 4 ? -1 : 1);
            }), L;
          }
          Xt.matches = function(F, W) {
            return Xt(F, null, null, W);
          }, Xt.matchesSelector = function(F, W) {
            if (Ur(F), z && !Pn[W + " "] && (!X || !X.test(W))) try {
              var J = oe.call(F, W);
              if (J || y.disconnectedMatch || F.document && F.document.nodeType !== 11) return J;
            } catch {
              Pn(W, true);
            }
            return Xt(W, L, null, [
              F
            ]).length > 0;
          }, Xt.contains = function(F, W) {
            return (F.ownerDocument || F) != L && Ur(F), d.contains(F, W);
          }, Xt.attr = function(F, W) {
            (F.ownerDocument || F) != L && Ur(F);
            var J = p.attrHandle[W.toLowerCase()], se = J && f.call(p.attrHandle, W.toLowerCase()) ? J(F, W, !z) : void 0;
            return se !== void 0 ? se : F.getAttribute(W);
          }, Xt.error = function(F) {
            throw new Error("Syntax error, unrecognized expression: " + F);
          }, d.uniqueSort = function(F) {
            var W, J = [], se = 0, de = 0;
            if (A = !y.sortStable, S = !y.sortStable && r.call(F, 0), B.call(F, bn), A) {
              for (; W = F[de++]; ) W === F[de] && (se = J.push(de));
              for (; se--; ) Z.call(F, J[se], 1);
            }
            return S = null, F;
          }, d.fn.uniqueSort = function() {
            return this.pushStack(d.uniqueSort(r.apply(this)));
          }, p = d.expr = {
            cacheLength: 50,
            createPseudo: Ci,
            match: Bi,
            attrHandle: {},
            find: {},
            relative: {
              ">": {
                dir: "parentNode",
                first: true
              },
              " ": {
                dir: "parentNode"
              },
              "+": {
                dir: "previousSibling",
                first: true
              },
              "~": {
                dir: "previousSibling"
              }
            },
            preFilter: {
              ATTR: function(F) {
                return F[1] = F[1].replace(ar, lr), F[3] = (F[3] || F[4] || F[5] || "").replace(ar, lr), F[2] === "~=" && (F[3] = " " + F[3] + " "), F.slice(0, 4);
              },
              CHILD: function(F) {
                return F[1] = F[1].toLowerCase(), F[1].slice(0, 3) === "nth" ? (F[3] || Xt.error(F[0]), F[4] = +(F[4] ? F[5] + (F[6] || 1) : 2 * (F[3] === "even" || F[3] === "odd")), F[5] = +(F[7] + F[8] || F[3] === "odd")) : F[3] && Xt.error(F[0]), F;
              },
              PSEUDO: function(F) {
                var W, J = !F[6] && F[2];
                return Bi.CHILD.test(F[0]) ? null : (F[3] ? F[2] = F[4] || F[5] || "" : J && ki.test(J) && (W = va(J, true)) && (W = J.indexOf(")", J.length - W) - J.length) && (F[0] = F[0].slice(0, W), F[2] = J.slice(0, W)), F.slice(0, 3));
              }
            },
            filter: {
              TAG: function(F) {
                var W = F.replace(ar, lr).toLowerCase();
                return F === "*" ? function() {
                  return true;
                } : function(J) {
                  return w(J, W);
                };
              },
              CLASS: function(F) {
                var W = ut[F + " "];
                return W || (W = new RegExp("(^|" + G + ")" + F + "(" + G + "|$)")) && ut(F, function(J) {
                  return W.test(typeof J.className == "string" && J.className || typeof J.getAttribute < "u" && J.getAttribute("class") || "");
                });
              },
              ATTR: function(F, W, J) {
                return function(se) {
                  var de = Xt.attr(se, F);
                  return de == null ? W === "!=" : W ? (de += "", W === "=" ? de === J : W === "!=" ? de !== J : W === "^=" ? J && de.indexOf(J) === 0 : W === "*=" ? J && de.indexOf(J) > -1 : W === "$=" ? J && de.slice(-J.length) === J : W === "~=" ? (" " + de.replace(Ut, " ") + " ").indexOf(J) > -1 : W === "|=" ? de === J || de.slice(0, J.length + 1) === J + "-" : false) : true;
                };
              },
              CHILD: function(F, W, J, se, de) {
                var Ae = F.slice(0, 3) !== "nth", ke = F.slice(-4) !== "last", $e = W === "of-type";
                return se === 1 && de === 0 ? function(Be) {
                  return !!Be.parentNode;
                } : function(Be, Mt, ot) {
                  var ft, Tt, rt, Jt, Jn, Nn = Ae !== ke ? "nextSibling" : "previousSibling", yi = Be.parentNode, zi = $e && Be.nodeName.toLowerCase(), Ys = !ot && !$e, Vn = false;
                  if (yi) {
                    if (Ae) {
                      for (; Nn; ) {
                        for (rt = Be; rt = rt[Nn]; ) if ($e ? w(rt, zi) : rt.nodeType === 1) return false;
                        Jn = Nn = F === "only" && !Jn && "nextSibling";
                      }
                      return true;
                    }
                    if (Jn = [
                      ke ? yi.firstChild : yi.lastChild
                    ], ke && Ys) {
                      for (Tt = yi[pe] || (yi[pe] = {}), ft = Tt[F] || [], Jt = ft[0] === ee && ft[1], Vn = Jt && ft[2], rt = Jt && yi.childNodes[Jt]; rt = ++Jt && rt && rt[Nn] || (Vn = Jt = 0) || Jn.pop(); ) if (rt.nodeType === 1 && ++Vn && rt === Be) {
                        Tt[F] = [
                          ee,
                          Jt,
                          Vn
                        ];
                        break;
                      }
                    } else if (Ys && (Tt = Be[pe] || (Be[pe] = {}), ft = Tt[F] || [], Jt = ft[0] === ee && ft[1], Vn = Jt), Vn === false) for (; (rt = ++Jt && rt && rt[Nn] || (Vn = Jt = 0) || Jn.pop()) && !(($e ? w(rt, zi) : rt.nodeType === 1) && ++Vn && (Ys && (Tt = rt[pe] || (rt[pe] = {}), Tt[F] = [
                      ee,
                      Vn
                    ]), rt === Be)); ) ;
                    return Vn -= de, Vn === se || Vn % se === 0 && Vn / se >= 0;
                  }
                };
              },
              PSEUDO: function(F, W) {
                var J, se = p.pseudos[F] || p.setFilters[F.toLowerCase()] || Xt.error("unsupported pseudo: " + F);
                return se[pe] ? se(W) : se.length > 1 ? (J = [
                  F,
                  F,
                  "",
                  W
                ], p.setFilters.hasOwnProperty(F.toLowerCase()) ? Ci(function(de, Ae) {
                  for (var ke, $e = se(de, W), Be = $e.length; Be--; ) ke = l.call(de, $e[Be]), de[ke] = !(Ae[ke] = $e[Be]);
                }) : function(de) {
                  return se(de, 0, J);
                }) : se;
              }
            },
            pseudos: {
              not: Ci(function(F) {
                var W = [], J = [], se = au(F.replace(Q, "$1"));
                return se[pe] ? Ci(function(de, Ae, ke, $e) {
                  for (var Be, Mt = se(de, null, $e, []), ot = de.length; ot--; ) (Be = Mt[ot]) && (de[ot] = !(Ae[ot] = Be));
                }) : function(de, Ae, ke) {
                  return W[0] = de, se(W, null, ke, J), W[0] = null, !J.pop();
                };
              }),
              has: Ci(function(F) {
                return function(W) {
                  return Xt(F, W).length > 0;
                };
              }),
              contains: Ci(function(F) {
                return F = F.replace(ar, lr), function(W) {
                  return (W.textContent || d.text(W)).indexOf(F) > -1;
                };
              }),
              lang: Ci(function(F) {
                return _a.test(F || "") || Xt.error("unsupported lang: " + F), F = F.replace(ar, lr).toLowerCase(), function(W) {
                  var J;
                  do
                    if (J = z ? W.lang : W.getAttribute("xml:lang") || W.getAttribute("lang")) return J = J.toLowerCase(), J === F || J.indexOf(F + "-") === 0;
                  while ((W = W.parentNode) && W.nodeType === 1);
                  return false;
                };
              }),
              target: function(F) {
                var W = e.location && e.location.hash;
                return W && W.slice(1) === F.id;
              },
              root: function(F) {
                return F === H;
              },
              focus: function(F) {
                return F === c0() && L.hasFocus() && !!(F.type || F.href || ~F.tabIndex);
              },
              enabled: Md(false),
              disabled: Md(true),
              checked: function(F) {
                return w(F, "input") && !!F.checked || w(F, "option") && !!F.selected;
              },
              selected: function(F) {
                return F.parentNode && F.parentNode.selectedIndex, F.selected === true;
              },
              empty: function(F) {
                for (F = F.firstChild; F; F = F.nextSibling) if (F.nodeType < 6) return false;
                return true;
              },
              parent: function(F) {
                return !p.pseudos.empty(F);
              },
              header: function(F) {
                return Nr.test(F.nodeName);
              },
              input: function(F) {
                return Ir.test(F.nodeName);
              },
              button: function(F) {
                return w(F, "input") && F.type === "button" || w(F, "button");
              },
              text: function(F) {
                var W;
                return w(F, "input") && F.type === "text" && ((W = F.getAttribute("type")) == null || W.toLowerCase() === "text");
              },
              first: us(function() {
                return [
                  0
                ];
              }),
              last: us(function(F, W) {
                return [
                  W - 1
                ];
              }),
              eq: us(function(F, W, J) {
                return [
                  J < 0 ? J + W : J
                ];
              }),
              even: us(function(F, W) {
                for (var J = 0; J < W; J += 2) F.push(J);
                return F;
              }),
              odd: us(function(F, W) {
                for (var J = 1; J < W; J += 2) F.push(J);
                return F;
              }),
              lt: us(function(F, W, J) {
                var se;
                for (J < 0 ? se = J + W : J > W ? se = W : se = J; --se >= 0; ) F.push(se);
                return F;
              }),
              gt: us(function(F, W, J) {
                for (var se = J < 0 ? J + W : J; ++se < W; ) F.push(se);
                return F;
              })
            }
          }, p.pseudos.nth = p.pseudos.eq;
          for (u in {
            radio: true,
            checkbox: true,
            file: true,
            password: true,
            image: true
          }) p.pseudos[u] = u0(u);
          for (u in {
            submit: true,
            reset: true
          }) p.pseudos[u] = h0(u);
          function Td() {
          }
          Td.prototype = p.filters = p.pseudos, p.setFilters = new Td();
          function va(F, W) {
            var J, se, de, Ae, ke, $e, Be, Mt = Lt[F + " "];
            if (Mt) return W ? 0 : Mt.slice(0);
            for (ke = F, $e = [], Be = p.preFilter; ke; ) {
              (!J || (se = an.exec(ke))) && (se && (ke = ke.slice(se[0].length) || ke), $e.push(de = [])), J = false, (se = ga.exec(ke)) && (J = se.shift(), de.push({
                value: J,
                type: se[0].replace(Q, " ")
              }), ke = ke.slice(J.length));
              for (Ae in p.filter) (se = Bi[Ae].exec(ke)) && (!Be[Ae] || (se = Be[Ae](se))) && (J = se.shift(), de.push({
                value: J,
                type: Ae,
                matches: se
              }), ke = ke.slice(J.length));
              if (!J) break;
            }
            return W ? ke.length : ke ? Xt.error(F) : Lt(F, $e).slice(0);
          }
          function Ml(F) {
            for (var W = 0, J = F.length, se = ""; W < J; W++) se += F[W].value;
            return se;
          }
          function Tl(F, W, J) {
            var se = W.dir, de = W.next, Ae = de || se, ke = J && Ae === "parentNode", $e = xe++;
            return W.first ? function(Be, Mt, ot) {
              for (; Be = Be[se]; ) if (Be.nodeType === 1 || ke) return F(Be, Mt, ot);
              return false;
            } : function(Be, Mt, ot) {
              var ft, Tt, rt = [
                ee,
                $e
              ];
              if (ot) {
                for (; Be = Be[se]; ) if ((Be.nodeType === 1 || ke) && F(Be, Mt, ot)) return true;
              } else for (; Be = Be[se]; ) if (Be.nodeType === 1 || ke) if (Tt = Be[pe] || (Be[pe] = {}), de && w(Be, de)) Be = Be[se] || Be;
              else {
                if ((ft = Tt[Ae]) && ft[0] === ee && ft[1] === $e) return rt[2] = ft[2];
                if (Tt[Ae] = rt, rt[2] = F(Be, Mt, ot)) return true;
              }
              return false;
            };
          }
          function ru(F) {
            return F.length > 1 ? function(W, J, se) {
              for (var de = F.length; de--; ) if (!F[de](W, J, se)) return false;
              return true;
            } : F[0];
          }
          function f0(F, W, J) {
            for (var se = 0, de = W.length; se < de; se++) Xt(F, W[se], J);
            return J;
          }
          function El(F, W, J, se, de) {
            for (var Ae, ke = [], $e = 0, Be = F.length, Mt = W != null; $e < Be; $e++) (Ae = F[$e]) && (!J || J(Ae, se, de)) && (ke.push(Ae), Mt && W.push($e));
            return ke;
          }
          function su(F, W, J, se, de, Ae) {
            return se && !se[pe] && (se = su(se)), de && !de[pe] && (de = su(de, Ae)), Ci(function(ke, $e, Be, Mt) {
              var ot, ft, Tt, rt, Jt = [], Jn = [], Nn = $e.length, yi = ke || f0(W || "*", Be.nodeType ? [
                Be
              ] : Be, []), zi = F && (ke || !W) ? El(yi, Jt, F, Be, Mt) : yi;
              if (J ? (rt = de || (ke ? F : Nn || se) ? [] : $e, J(zi, rt, Be, Mt)) : rt = zi, se) for (ot = El(rt, Jn), se(ot, [], Be, Mt), ft = ot.length; ft--; ) (Tt = ot[ft]) && (rt[Jn[ft]] = !(zi[Jn[ft]] = Tt));
              if (ke) {
                if (de || F) {
                  if (de) {
                    for (ot = [], ft = rt.length; ft--; ) (Tt = rt[ft]) && ot.push(zi[ft] = Tt);
                    de(null, rt = [], ot, Mt);
                  }
                  for (ft = rt.length; ft--; ) (Tt = rt[ft]) && (ot = de ? l.call(ke, Tt) : Jt[ft]) > -1 && (ke[ot] = !($e[ot] = Tt));
                }
              } else rt = El(rt === $e ? rt.splice(Nn, rt.length) : rt), de ? de(null, $e, rt, Mt) : C.apply($e, rt);
            });
          }
          function ou(F) {
            for (var W, J, se, de = F.length, Ae = p.relative[F[0].type], ke = Ae || p.relative[" "], $e = Ae ? 1 : 0, Be = Tl(function(ft) {
              return ft === W;
            }, ke, true), Mt = Tl(function(ft) {
              return l.call(W, ft) > -1;
            }, ke, true), ot = [
              function(ft, Tt, rt) {
                var Jt = !Ae && (rt || Tt != b) || ((W = Tt).nodeType ? Be(ft, Tt, rt) : Mt(ft, Tt, rt));
                return W = null, Jt;
              }
            ]; $e < de; $e++) if (J = p.relative[F[$e].type]) ot = [
              Tl(ru(ot), J)
            ];
            else {
              if (J = p.filter[F[$e].type].apply(null, F[$e].matches), J[pe]) {
                for (se = ++$e; se < de && !p.relative[F[se].type]; se++) ;
                return su($e > 1 && ru(ot), $e > 1 && Ml(F.slice(0, $e - 1).concat({
                  value: F[$e - 2].type === " " ? "*" : ""
                })).replace(Q, "$1"), J, $e < se && ou(F.slice($e, se)), se < de && ou(F = F.slice(se)), se < de && Ml(F));
              }
              ot.push(J);
            }
            return ru(ot);
          }
          function d0(F, W) {
            var J = W.length > 0, se = F.length > 0, de = function(Ae, ke, $e, Be, Mt) {
              var ot, ft, Tt, rt = 0, Jt = "0", Jn = Ae && [], Nn = [], yi = b, zi = Ae || se && p.find.TAG("*", Mt), Ys = ee += yi == null ? 1 : Math.random() || 0.1, Vn = zi.length;
              for (Mt && (b = ke == L || ke || Mt); Jt !== Vn && (ot = zi[Jt]) != null; Jt++) {
                if (se && ot) {
                  for (ft = 0, !ke && ot.ownerDocument != L && (Ur(ot), $e = !z); Tt = F[ft++]; ) if (Tt(ot, ke || L, $e)) {
                    C.call(Be, ot);
                    break;
                  }
                  Mt && (ee = Ys);
                }
                J && ((ot = !Tt && ot) && rt--, Ae && Jn.push(ot));
              }
              if (rt += Jt, J && Jt !== rt) {
                for (ft = 0; Tt = W[ft++]; ) Tt(Jn, Nn, ke, $e);
                if (Ae) {
                  if (rt > 0) for (; Jt--; ) Jn[Jt] || Nn[Jt] || (Nn[Jt] = D.call(Be));
                  Nn = El(Nn);
                }
                C.apply(Be, Nn), Mt && !Ae && Nn.length > 0 && rt + W.length > 1 && d.uniqueSort(Be);
              }
              return Mt && (ee = Ys, b = yi), Jn;
            };
            return J ? Ci(de) : de;
          }
          function au(F, W) {
            var J, se = [], de = [], Ae = gt[F + " "];
            if (!Ae) {
              for (W || (W = va(F)), J = W.length; J--; ) Ae = ou(W[J]), Ae[pe] ? se.push(Ae) : de.push(Ae);
              Ae = gt(F, d0(de, se)), Ae.selector = F;
            }
            return Ae;
          }
          function Ed(F, W, J, se) {
            var de, Ae, ke, $e, Be, Mt = typeof F == "function" && F, ot = !se && va(F = Mt.selector || F);
            if (J = J || [], ot.length === 1) {
              if (Ae = ot[0] = ot[0].slice(0), Ae.length > 2 && (ke = Ae[0]).type === "ID" && W.nodeType === 9 && z && p.relative[Ae[1].type]) {
                if (W = (p.find.ID(ke.matches[0].replace(ar, lr), W) || [])[0], W) Mt && (W = W.parentNode);
                else return J;
                F = F.slice(Ae.shift().value.length);
              }
              for (de = Bi.needsContext.test(F) ? 0 : Ae.length; de-- && (ke = Ae[de], !p.relative[$e = ke.type]); ) if ((Be = p.find[$e]) && (se = Be(ke.matches[0].replace(ar, lr), nu.test(Ae[0].type) && iu(W.parentNode) || W))) {
                if (Ae.splice(de, 1), F = se.length && Ml(Ae), !F) return C.apply(J, se), J;
                break;
              }
            }
            return (Mt || au(F, ot))(se, W, !z, J, !W || nu.test(F) && iu(W.parentNode) || W), J;
          }
          y.sortStable = pe.split("").sort(bn).join("") === pe, Ur(), y.sortDetached = qs(function(F) {
            return F.compareDocumentPosition(L.createElement("fieldset")) & 1;
          }), d.find = Xt, d.expr[":"] = d.expr.pseudos, d.unique = d.uniqueSort, Xt.compile = au, Xt.select = Ed, Xt.setDocument = Ur, Xt.tokenize = va, Xt.escape = d.escapeSelector, Xt.getText = d.text, Xt.isXML = d.isXMLDoc, Xt.selectors = d.expr, Xt.support = d.support, Xt.uniqueSort = d.uniqueSort;
        })();
        var Me = function(u, p, b) {
          for (var S = [], A = b !== void 0; (u = u[p]) && u.nodeType !== 9; ) if (u.nodeType === 1) {
            if (A && d(u).is(b)) break;
            S.push(u);
          }
          return S;
        }, Ce = function(u, p) {
          for (var b = []; u; u = u.nextSibling) u.nodeType === 1 && u !== p && b.push(u);
          return b;
        }, Le = d.expr.match.needsContext, Je = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
        function dt(u, p, b) {
          return g(p) ? d.grep(u, function(S, A) {
            return !!p.call(S, A, S) !== b;
          }) : p.nodeType ? d.grep(u, function(S) {
            return S === p !== b;
          }) : typeof p != "string" ? d.grep(u, function(S) {
            return l.call(p, S) > -1 !== b;
          }) : d.filter(p, u, b);
        }
        d.filter = function(u, p, b) {
          var S = p[0];
          return b && (u = ":not(" + u + ")"), p.length === 1 && S.nodeType === 1 ? d.find.matchesSelector(S, u) ? [
            S
          ] : [] : d.find.matches(u, d.grep(p, function(A) {
            return A.nodeType === 1;
          }));
        }, d.fn.extend({
          find: function(u) {
            var p, b, S = this.length, A = this;
            if (typeof u != "string") return this.pushStack(d(u).filter(function() {
              for (p = 0; p < S; p++) if (d.contains(A[p], this)) return true;
            }));
            for (b = this.pushStack([]), p = 0; p < S; p++) d.find(u, A[p], b);
            return S > 1 ? d.uniqueSort(b) : b;
          },
          filter: function(u) {
            return this.pushStack(dt(this, u || [], false));
          },
          not: function(u) {
            return this.pushStack(dt(this, u || [], true));
          },
          is: function(u) {
            return !!dt(this, typeof u == "string" && Le.test(u) ? d(u) : u || [], false).length;
          }
        });
        var ce, ve = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, qe = d.fn.init = function(u, p, b) {
          var S, A;
          if (!u) return this;
          if (b = b || ce, typeof u == "string") if (u[0] === "<" && u[u.length - 1] === ">" && u.length >= 3 ? S = [
            null,
            u,
            null
          ] : S = ve.exec(u), S && (S[1] || !p)) if (S[1]) {
            if (p = p instanceof d ? p[0] : p, d.merge(this, d.parseHTML(S[1], p && p.nodeType ? p.ownerDocument || p : v, true)), Je.test(S[1]) && d.isPlainObject(p)) for (S in p) g(this[S]) ? this[S](p[S]) : this.attr(S, p[S]);
            return this;
          } else return A = v.getElementById(S[2]), A && (this[0] = A, this.length = 1), this;
          else return !p || p.jquery ? (p || b).find(u) : this.constructor(p).find(u);
          else {
            if (u.nodeType) return this[0] = u, this.length = 1, this;
            if (g(u)) return b.ready !== void 0 ? b.ready(u) : u(d);
          }
          return d.makeArray(u, this);
        };
        qe.prototype = d.fn, ce = d(v);
        var Te = /^(?:parents|prev(?:Until|All))/, Ye = {
          children: true,
          contents: true,
          next: true,
          prev: true
        };
        d.fn.extend({
          has: function(u) {
            var p = d(u, this), b = p.length;
            return this.filter(function() {
              for (var S = 0; S < b; S++) if (d.contains(this, p[S])) return true;
            });
          },
          closest: function(u, p) {
            var b, S = 0, A = this.length, C = [], L = typeof u != "string" && d(u);
            if (!Le.test(u)) {
              for (; S < A; S++) for (b = this[S]; b && b !== p; b = b.parentNode) if (b.nodeType < 11 && (L ? L.index(b) > -1 : b.nodeType === 1 && d.find.matchesSelector(b, u))) {
                C.push(b);
                break;
              }
            }
            return this.pushStack(C.length > 1 ? d.uniqueSort(C) : C);
          },
          index: function(u) {
            return u ? typeof u == "string" ? l.call(d(u), this[0]) : l.call(this, u.jquery ? u[0] : u) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
          },
          add: function(u, p) {
            return this.pushStack(d.uniqueSort(d.merge(this.get(), d(u, p))));
          },
          addBack: function(u) {
            return this.add(u == null ? this.prevObject : this.prevObject.filter(u));
          }
        });
        function lt(u, p) {
          for (; (u = u[p]) && u.nodeType !== 1; ) ;
          return u;
        }
        d.each({
          parent: function(u) {
            var p = u.parentNode;
            return p && p.nodeType !== 11 ? p : null;
          },
          parents: function(u) {
            return Me(u, "parentNode");
          },
          parentsUntil: function(u, p, b) {
            return Me(u, "parentNode", b);
          },
          next: function(u) {
            return lt(u, "nextSibling");
          },
          prev: function(u) {
            return lt(u, "previousSibling");
          },
          nextAll: function(u) {
            return Me(u, "nextSibling");
          },
          prevAll: function(u) {
            return Me(u, "previousSibling");
          },
          nextUntil: function(u, p, b) {
            return Me(u, "nextSibling", b);
          },
          prevUntil: function(u, p, b) {
            return Me(u, "previousSibling", b);
          },
          siblings: function(u) {
            return Ce((u.parentNode || {}).firstChild, u);
          },
          children: function(u) {
            return Ce(u.firstChild);
          },
          contents: function(u) {
            return u.contentDocument != null && i(u.contentDocument) ? u.contentDocument : (w(u, "template") && (u = u.content || u), d.merge([], u.childNodes));
          }
        }, function(u, p) {
          d.fn[u] = function(b, S) {
            var A = d.map(this, p, b);
            return u.slice(-5) !== "Until" && (S = b), S && typeof S == "string" && (A = d.filter(S, A)), this.length > 1 && (Ye[u] || d.uniqueSort(A), Te.test(u) && A.reverse()), this.pushStack(A);
          };
        });
        var Fe = /[^\x20\t\r\n\f]+/g;
        function Nt(u) {
          var p = {};
          return d.each(u.match(Fe) || [], function(b, S) {
            p[S] = true;
          }), p;
        }
        d.Callbacks = function(u) {
          u = typeof u == "string" ? Nt(u) : d.extend({}, u);
          var p, b, S, A, C = [], L = [], H = -1, z = function() {
            for (A = A || u.once, S = p = true; L.length; H = -1) for (b = L.shift(); ++H < C.length; ) C[H].apply(b[0], b[1]) === false && u.stopOnFalse && (H = C.length, b = false);
            u.memory || (b = false), p = false, A && (b ? C = [] : C = "");
          }, X = {
            add: function() {
              return C && (b && !p && (H = C.length - 1, L.push(b)), function oe(pe) {
                d.each(pe, function(ee, xe) {
                  g(xe) ? (!u.unique || !X.has(xe)) && C.push(xe) : xe && xe.length && M(xe) !== "string" && oe(xe);
                });
              }(arguments), b && !p && z()), this;
            },
            remove: function() {
              return d.each(arguments, function(oe, pe) {
                for (var ee; (ee = d.inArray(pe, C, ee)) > -1; ) C.splice(ee, 1), ee <= H && H--;
              }), this;
            },
            has: function(oe) {
              return oe ? d.inArray(oe, C) > -1 : C.length > 0;
            },
            empty: function() {
              return C && (C = []), this;
            },
            disable: function() {
              return A = L = [], C = b = "", this;
            },
            disabled: function() {
              return !C;
            },
            lock: function() {
              return A = L = [], !b && !p && (C = b = ""), this;
            },
            locked: function() {
              return !!A;
            },
            fireWith: function(oe, pe) {
              return A || (pe = pe || [], pe = [
                oe,
                pe.slice ? pe.slice() : pe
              ], L.push(pe), p || z()), this;
            },
            fire: function() {
              return X.fireWith(this, arguments), this;
            },
            fired: function() {
              return !!S;
            }
          };
          return X;
        };
        function _e(u) {
          return u;
        }
        function ge(u) {
          throw u;
        }
        function k(u, p, b, S) {
          var A;
          try {
            u && g(A = u.promise) ? A.call(u).done(p).fail(b) : u && g(A = u.then) ? A.call(u, p, b) : p.apply(void 0, [
              u
            ].slice(S));
          } catch (C) {
            b.apply(void 0, [
              C
            ]);
          }
        }
        d.extend({
          Deferred: function(u) {
            var p = [
              [
                "notify",
                "progress",
                d.Callbacks("memory"),
                d.Callbacks("memory"),
                2
              ],
              [
                "resolve",
                "done",
                d.Callbacks("once memory"),
                d.Callbacks("once memory"),
                0,
                "resolved"
              ],
              [
                "reject",
                "fail",
                d.Callbacks("once memory"),
                d.Callbacks("once memory"),
                1,
                "rejected"
              ]
            ], b = "pending", S = {
              state: function() {
                return b;
              },
              always: function() {
                return A.done(arguments).fail(arguments), this;
              },
              catch: function(C) {
                return S.then(null, C);
              },
              pipe: function() {
                var C = arguments;
                return d.Deferred(function(L) {
                  d.each(p, function(H, z) {
                    var X = g(C[z[4]]) && C[z[4]];
                    A[z[1]](function() {
                      var oe = X && X.apply(this, arguments);
                      oe && g(oe.promise) ? oe.promise().progress(L.notify).done(L.resolve).fail(L.reject) : L[z[0] + "With"](this, X ? [
                        oe
                      ] : arguments);
                    });
                  }), C = null;
                }).promise();
              },
              then: function(C, L, H) {
                var z = 0;
                function X(oe, pe, ee, xe) {
                  return function() {
                    var ut = this, Lt = arguments, gt = function() {
                      var bn, Oi;
                      if (!(oe < z)) {
                        if (bn = ee.apply(ut, Lt), bn === pe.promise()) throw new TypeError("Thenable self-resolution");
                        Oi = bn && (typeof bn == "object" || typeof bn == "function") && bn.then, g(Oi) ? xe ? Oi.call(bn, X(z, pe, _e, xe), X(z, pe, ge, xe)) : (z++, Oi.call(bn, X(z, pe, _e, xe), X(z, pe, ge, xe), X(z, pe, _e, pe.notifyWith))) : (ee !== _e && (ut = void 0, Lt = [
                          bn
                        ]), (xe || pe.resolveWith)(ut, Lt));
                      }
                    }, Pn = xe ? gt : function() {
                      try {
                        gt();
                      } catch (bn) {
                        d.Deferred.exceptionHook && d.Deferred.exceptionHook(bn, Pn.error), oe + 1 >= z && (ee !== ge && (ut = void 0, Lt = [
                          bn
                        ]), pe.rejectWith(ut, Lt));
                      }
                    };
                    oe ? Pn() : (d.Deferred.getErrorHook ? Pn.error = d.Deferred.getErrorHook() : d.Deferred.getStackHook && (Pn.error = d.Deferred.getStackHook()), e.setTimeout(Pn));
                  };
                }
                return d.Deferred(function(oe) {
                  p[0][3].add(X(0, oe, g(H) ? H : _e, oe.notifyWith)), p[1][3].add(X(0, oe, g(C) ? C : _e)), p[2][3].add(X(0, oe, g(L) ? L : ge));
                }).promise();
              },
              promise: function(C) {
                return C != null ? d.extend(C, S) : S;
              }
            }, A = {};
            return d.each(p, function(C, L) {
              var H = L[2], z = L[5];
              S[L[1]] = H.add, z && H.add(function() {
                b = z;
              }, p[3 - C][2].disable, p[3 - C][3].disable, p[0][2].lock, p[0][3].lock), H.add(L[3].fire), A[L[0]] = function() {
                return A[L[0] + "With"](this === A ? void 0 : this, arguments), this;
              }, A[L[0] + "With"] = H.fireWith;
            }), S.promise(A), u && u.call(A, A), A;
          },
          when: function(u) {
            var p = arguments.length, b = p, S = Array(b), A = r.call(arguments), C = d.Deferred(), L = function(H) {
              return function(z) {
                S[H] = this, A[H] = arguments.length > 1 ? r.call(arguments) : z, --p || C.resolveWith(S, A);
              };
            };
            if (p <= 1 && (k(u, C.done(L(b)).resolve, C.reject, !p), C.state() === "pending" || g(A[b] && A[b].then))) return C.then();
            for (; b--; ) k(A[b], L(b), C.reject);
            return C.promise();
          }
        });
        var Ke = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
        d.Deferred.exceptionHook = function(u, p) {
          e.console && e.console.warn && u && Ke.test(u.name) && e.console.warn("jQuery.Deferred exception: " + u.message, u.stack, p);
        }, d.readyException = function(u) {
          e.setTimeout(function() {
            throw u;
          });
        };
        var ye = d.Deferred();
        d.fn.ready = function(u) {
          return ye.then(u).catch(function(p) {
            d.readyException(p);
          }), this;
        }, d.extend({
          isReady: false,
          readyWait: 1,
          ready: function(u) {
            (u === true ? --d.readyWait : d.isReady) || (d.isReady = true, !(u !== true && --d.readyWait > 0) && ye.resolveWith(v, [
              d
            ]));
          }
        }), d.ready.then = ye.then;
        function ze() {
          v.removeEventListener("DOMContentLoaded", ze), e.removeEventListener("load", ze), d.ready();
        }
        v.readyState === "complete" || v.readyState !== "loading" && !v.documentElement.doScroll ? e.setTimeout(d.ready) : (v.addEventListener("DOMContentLoaded", ze), e.addEventListener("load", ze));
        var Ee = function(u, p, b, S, A, C, L) {
          var H = 0, z = u.length, X = b == null;
          if (M(b) === "object") {
            A = true;
            for (H in b) Ee(u, p, H, b[H], true, C, L);
          } else if (S !== void 0 && (A = true, g(S) || (L = true), X && (L ? (p.call(u, S), p = null) : (X = p, p = function(oe, pe, ee) {
            return X.call(d(oe), ee);
          })), p)) for (; H < z; H++) p(u[H], b, L ? S : S.call(u[H], H, p(u[H], b)));
          return A ? u : X ? p.call(u) : z ? p(u[0], b) : C;
        }, st = /^-ms-/, Ue = /-([a-z])/g;
        function O(u, p) {
          return p.toUpperCase();
        }
        function I(u) {
          return u.replace(st, "ms-").replace(Ue, O);
        }
        var $ = function(u) {
          return u.nodeType === 1 || u.nodeType === 9 || !+u.nodeType;
        };
        function fe() {
          this.expando = d.expando + fe.uid++;
        }
        fe.uid = 1, fe.prototype = {
          cache: function(u) {
            var p = u[this.expando];
            return p || (p = {}, $(u) && (u.nodeType ? u[this.expando] = p : Object.defineProperty(u, this.expando, {
              value: p,
              configurable: true
            }))), p;
          },
          set: function(u, p, b) {
            var S, A = this.cache(u);
            if (typeof p == "string") A[I(p)] = b;
            else for (S in p) A[I(S)] = p[S];
            return A;
          },
          get: function(u, p) {
            return p === void 0 ? this.cache(u) : u[this.expando] && u[this.expando][I(p)];
          },
          access: function(u, p, b) {
            return p === void 0 || p && typeof p == "string" && b === void 0 ? this.get(u, p) : (this.set(u, p, b), b !== void 0 ? b : p);
          },
          remove: function(u, p) {
            var b, S = u[this.expando];
            if (S !== void 0) {
              if (p !== void 0) for (Array.isArray(p) ? p = p.map(I) : (p = I(p), p = p in S ? [
                p
              ] : p.match(Fe) || []), b = p.length; b--; ) delete S[p[b]];
              (p === void 0 || d.isEmptyObject(S)) && (u.nodeType ? u[this.expando] = void 0 : delete u[this.expando]);
            }
          },
          hasData: function(u) {
            var p = u[this.expando];
            return p !== void 0 && !d.isEmptyObject(p);
          }
        };
        var K = new fe(), le = new fe(), je = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, Re = /[A-Z]/g;
        function Ge(u) {
          return u === "true" ? true : u === "false" ? false : u === "null" ? null : u === +u + "" ? +u : je.test(u) ? JSON.parse(u) : u;
        }
        function vt(u, p, b) {
          var S;
          if (b === void 0 && u.nodeType === 1) if (S = "data-" + p.replace(Re, "-$&").toLowerCase(), b = u.getAttribute(S), typeof b == "string") {
            try {
              b = Ge(b);
            } catch {
            }
            le.set(u, p, b);
          } else b = void 0;
          return b;
        }
        d.extend({
          hasData: function(u) {
            return le.hasData(u) || K.hasData(u);
          },
          data: function(u, p, b) {
            return le.access(u, p, b);
          },
          removeData: function(u, p) {
            le.remove(u, p);
          },
          _data: function(u, p, b) {
            return K.access(u, p, b);
          },
          _removeData: function(u, p) {
            K.remove(u, p);
          }
        }), d.fn.extend({
          data: function(u, p) {
            var b, S, A, C = this[0], L = C && C.attributes;
            if (u === void 0) {
              if (this.length && (A = le.get(C), C.nodeType === 1 && !K.get(C, "hasDataAttrs"))) {
                for (b = L.length; b--; ) L[b] && (S = L[b].name, S.indexOf("data-") === 0 && (S = I(S.slice(5)), vt(C, S, A[S])));
                K.set(C, "hasDataAttrs", true);
              }
              return A;
            }
            return typeof u == "object" ? this.each(function() {
              le.set(this, u);
            }) : Ee(this, function(H) {
              var z;
              if (C && H === void 0) return z = le.get(C, u), z !== void 0 || (z = vt(C, u), z !== void 0) ? z : void 0;
              this.each(function() {
                le.set(this, u, H);
              });
            }, null, p, arguments.length > 1, null, true);
          },
          removeData: function(u) {
            return this.each(function() {
              le.remove(this, u);
            });
          }
        }), d.extend({
          queue: function(u, p, b) {
            var S;
            if (u) return p = (p || "fx") + "queue", S = K.get(u, p), b && (!S || Array.isArray(b) ? S = K.access(u, p, d.makeArray(b)) : S.push(b)), S || [];
          },
          dequeue: function(u, p) {
            p = p || "fx";
            var b = d.queue(u, p), S = b.length, A = b.shift(), C = d._queueHooks(u, p), L = function() {
              d.dequeue(u, p);
            };
            A === "inprogress" && (A = b.shift(), S--), A && (p === "fx" && b.unshift("inprogress"), delete C.stop, A.call(u, L, C)), !S && C && C.empty.fire();
          },
          _queueHooks: function(u, p) {
            var b = p + "queueHooks";
            return K.get(u, b) || K.access(u, b, {
              empty: d.Callbacks("once memory").add(function() {
                K.remove(u, [
                  p + "queue",
                  b
                ]);
              })
            });
          }
        }), d.fn.extend({
          queue: function(u, p) {
            var b = 2;
            return typeof u != "string" && (p = u, u = "fx", b--), arguments.length < b ? d.queue(this[0], u) : p === void 0 ? this : this.each(function() {
              var S = d.queue(this, u, p);
              d._queueHooks(this, u), u === "fx" && S[0] !== "inprogress" && d.dequeue(this, u);
            });
          },
          dequeue: function(u) {
            return this.each(function() {
              d.dequeue(this, u);
            });
          },
          clearQueue: function(u) {
            return this.queue(u || "fx", []);
          },
          promise: function(u, p) {
            var b, S = 1, A = d.Deferred(), C = this, L = this.length, H = function() {
              --S || A.resolveWith(C, [
                C
              ]);
            };
            for (typeof u != "string" && (p = u, u = void 0), u = u || "fx"; L--; ) b = K.get(C[L], u + "queueHooks"), b && b.empty && (S++, b.empty.add(H));
            return H(), A.promise(p);
          }
        });
        var we = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, Ve = new RegExp("^(?:([+-])=|)(" + we + ")([a-z%]*)$", "i"), Ze = [
          "Top",
          "Right",
          "Bottom",
          "Left"
        ], nt = v.documentElement, He = function(u) {
          return d.contains(u.ownerDocument, u);
        }, wt = {
          composed: true
        };
        nt.getRootNode && (He = function(u) {
          return d.contains(u.ownerDocument, u) || u.getRootNode(wt) === u.ownerDocument;
        });
        var ht = function(u, p) {
          return u = p || u, u.style.display === "none" || u.style.display === "" && He(u) && d.css(u, "display") === "none";
        };
        function Wt(u, p, b, S) {
          var A, C, L = 20, H = S ? function() {
            return S.cur();
          } : function() {
            return d.css(u, p, "");
          }, z = H(), X = b && b[3] || (d.cssNumber[p] ? "" : "px"), oe = u.nodeType && (d.cssNumber[p] || X !== "px" && +z) && Ve.exec(d.css(u, p));
          if (oe && oe[3] !== X) {
            for (z = z / 2, X = X || oe[3], oe = +z || 1; L--; ) d.style(u, p, oe + X), (1 - C) * (1 - (C = H() / z || 0.5)) <= 0 && (L = 0), oe = oe / C;
            oe = oe * 2, d.style(u, p, oe + X), b = b || [];
          }
          return b && (oe = +oe || +z || 0, A = b[1] ? oe + (b[1] + 1) * b[2] : +b[2], S && (S.unit = X, S.start = oe, S.end = A)), A;
        }
        var q = {};
        function Ie(u) {
          var p, b = u.ownerDocument, S = u.nodeName, A = q[S];
          return A || (p = b.body.appendChild(b.createElement(S)), A = d.css(p, "display"), p.parentNode.removeChild(p), A === "none" && (A = "block"), q[S] = A, A);
        }
        function ae(u, p) {
          for (var b, S, A = [], C = 0, L = u.length; C < L; C++) S = u[C], S.style && (b = S.style.display, p ? (b === "none" && (A[C] = K.get(S, "display") || null, A[C] || (S.style.display = "")), S.style.display === "" && ht(S) && (A[C] = Ie(S))) : b !== "none" && (A[C] = "none", K.set(S, "display", b)));
          for (C = 0; C < L; C++) A[C] != null && (u[C].style.display = A[C]);
          return u;
        }
        d.fn.extend({
          show: function() {
            return ae(this, true);
          },
          hide: function() {
            return ae(this);
          },
          toggle: function(u) {
            return typeof u == "boolean" ? u ? this.show() : this.hide() : this.each(function() {
              ht(this) ? d(this).show() : d(this).hide();
            });
          }
        });
        var me = /^(?:checkbox|radio)$/i, Oe = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i, Ne = /^$|^module$|\/(?:java|ecma)script/i;
        (function() {
          var u = v.createDocumentFragment(), p = u.appendChild(v.createElement("div")), b = v.createElement("input");
          b.setAttribute("type", "radio"), b.setAttribute("checked", "checked"), b.setAttribute("name", "t"), p.appendChild(b), y.checkClone = p.cloneNode(true).cloneNode(true).lastChild.checked, p.innerHTML = "<textarea>x</textarea>", y.noCloneChecked = !!p.cloneNode(true).lastChild.defaultValue, p.innerHTML = "<option></option>", y.option = !!p.lastChild;
        })();
        var tt = {
          thead: [
            1,
            "<table>",
            "</table>"
          ],
          col: [
            2,
            "<table><colgroup>",
            "</colgroup></table>"
          ],
          tr: [
            2,
            "<table><tbody>",
            "</tbody></table>"
          ],
          td: [
            3,
            "<table><tbody><tr>",
            "</tr></tbody></table>"
          ],
          _default: [
            0,
            "",
            ""
          ]
        };
        tt.tbody = tt.tfoot = tt.colgroup = tt.caption = tt.thead, tt.th = tt.td, y.option || (tt.optgroup = tt.option = [
          1,
          "<select multiple='multiple'>",
          "</select>"
        ]);
        function bt(u, p) {
          var b;
          return typeof u.getElementsByTagName < "u" ? b = u.getElementsByTagName(p || "*") : typeof u.querySelectorAll < "u" ? b = u.querySelectorAll(p || "*") : b = [], p === void 0 || p && w(u, p) ? d.merge([
            u
          ], b) : b;
        }
        function fn(u, p) {
          for (var b = 0, S = u.length; b < S; b++) K.set(u[b], "globalEval", !p || K.get(p[b], "globalEval"));
        }
        var kt = /<|&#?\w+;/;
        function Kn(u, p, b, S, A) {
          for (var C, L, H, z, X, oe, pe = p.createDocumentFragment(), ee = [], xe = 0, ut = u.length; xe < ut; xe++) if (C = u[xe], C || C === 0) if (M(C) === "object") d.merge(ee, C.nodeType ? [
            C
          ] : C);
          else if (!kt.test(C)) ee.push(p.createTextNode(C));
          else {
            for (L = L || pe.appendChild(p.createElement("div")), H = (Oe.exec(C) || [
              "",
              ""
            ])[1].toLowerCase(), z = tt[H] || tt._default, L.innerHTML = z[1] + d.htmlPrefilter(C) + z[2], oe = z[0]; oe--; ) L = L.lastChild;
            d.merge(ee, L.childNodes), L = pe.firstChild, L.textContent = "";
          }
          for (pe.textContent = "", xe = 0; C = ee[xe++]; ) {
            if (S && d.inArray(C, S) > -1) {
              A && A.push(C);
              continue;
            }
            if (X = He(C), L = bt(pe.appendChild(C), "script"), X && fn(L), b) for (oe = 0; C = L[oe++]; ) Ne.test(C.type || "") && b.push(C);
          }
          return pe;
        }
        var _i = /^([^.]*)(?:\.(.+)|)/;
        function ir() {
          return true;
        }
        function rr() {
          return false;
        }
        function Ai(u, p, b, S, A, C) {
          var L, H;
          if (typeof p == "object") {
            typeof b != "string" && (S = S || b, b = void 0);
            for (H in p) Ai(u, H, b, S, p[H], C);
            return u;
          }
          if (S == null && A == null ? (A = b, S = b = void 0) : A == null && (typeof b == "string" ? (A = S, S = void 0) : (A = S, S = b, b = void 0)), A === false) A = rr;
          else if (!A) return u;
          return C === 1 && (L = A, A = function(z) {
            return d().off(z), L.apply(this, arguments);
          }, A.guid = L.guid || (L.guid = d.guid++)), u.each(function() {
            d.event.add(this, p, A, S, b);
          });
        }
        d.event = {
          global: {},
          add: function(u, p, b, S, A) {
            var C, L, H, z, X, oe, pe, ee, xe, ut, Lt, gt = K.get(u);
            if ($(u)) for (b.handler && (C = b, b = C.handler, A = C.selector), A && d.find.matchesSelector(nt, A), b.guid || (b.guid = d.guid++), (z = gt.events) || (z = gt.events = /* @__PURE__ */ Object.create(null)), (L = gt.handle) || (L = gt.handle = function(Pn) {
              return typeof d < "u" && d.event.triggered !== Pn.type ? d.event.dispatch.apply(u, arguments) : void 0;
            }), p = (p || "").match(Fe) || [
              ""
            ], X = p.length; X--; ) H = _i.exec(p[X]) || [], xe = Lt = H[1], ut = (H[2] || "").split(".").sort(), xe && (pe = d.event.special[xe] || {}, xe = (A ? pe.delegateType : pe.bindType) || xe, pe = d.event.special[xe] || {}, oe = d.extend({
              type: xe,
              origType: Lt,
              data: S,
              handler: b,
              guid: b.guid,
              selector: A,
              needsContext: A && d.expr.match.needsContext.test(A),
              namespace: ut.join(".")
            }, C), (ee = z[xe]) || (ee = z[xe] = [], ee.delegateCount = 0, (!pe.setup || pe.setup.call(u, S, ut, L) === false) && u.addEventListener && u.addEventListener(xe, L)), pe.add && (pe.add.call(u, oe), oe.handler.guid || (oe.handler.guid = b.guid)), A ? ee.splice(ee.delegateCount++, 0, oe) : ee.push(oe), d.event.global[xe] = true);
          },
          remove: function(u, p, b, S, A) {
            var C, L, H, z, X, oe, pe, ee, xe, ut, Lt, gt = K.hasData(u) && K.get(u);
            if (!(!gt || !(z = gt.events))) {
              for (p = (p || "").match(Fe) || [
                ""
              ], X = p.length; X--; ) {
                if (H = _i.exec(p[X]) || [], xe = Lt = H[1], ut = (H[2] || "").split(".").sort(), !xe) {
                  for (xe in z) d.event.remove(u, xe + p[X], b, S, true);
                  continue;
                }
                for (pe = d.event.special[xe] || {}, xe = (S ? pe.delegateType : pe.bindType) || xe, ee = z[xe] || [], H = H[2] && new RegExp("(^|\\.)" + ut.join("\\.(?:.*\\.|)") + "(\\.|$)"), L = C = ee.length; C--; ) oe = ee[C], (A || Lt === oe.origType) && (!b || b.guid === oe.guid) && (!H || H.test(oe.namespace)) && (!S || S === oe.selector || S === "**" && oe.selector) && (ee.splice(C, 1), oe.selector && ee.delegateCount--, pe.remove && pe.remove.call(u, oe));
                L && !ee.length && ((!pe.teardown || pe.teardown.call(u, ut, gt.handle) === false) && d.removeEvent(u, xe, gt.handle), delete z[xe]);
              }
              d.isEmptyObject(z) && K.remove(u, "handle events");
            }
          },
          dispatch: function(u) {
            var p, b, S, A, C, L, H = new Array(arguments.length), z = d.event.fix(u), X = (K.get(this, "events") || /* @__PURE__ */ Object.create(null))[z.type] || [], oe = d.event.special[z.type] || {};
            for (H[0] = z, p = 1; p < arguments.length; p++) H[p] = arguments[p];
            if (z.delegateTarget = this, !(oe.preDispatch && oe.preDispatch.call(this, z) === false)) {
              for (L = d.event.handlers.call(this, z, X), p = 0; (A = L[p++]) && !z.isPropagationStopped(); ) for (z.currentTarget = A.elem, b = 0; (C = A.handlers[b++]) && !z.isImmediatePropagationStopped(); ) (!z.rnamespace || C.namespace === false || z.rnamespace.test(C.namespace)) && (z.handleObj = C, z.data = C.data, S = ((d.event.special[C.origType] || {}).handle || C.handler).apply(A.elem, H), S !== void 0 && (z.result = S) === false && (z.preventDefault(), z.stopPropagation()));
              return oe.postDispatch && oe.postDispatch.call(this, z), z.result;
            }
          },
          handlers: function(u, p) {
            var b, S, A, C, L, H = [], z = p.delegateCount, X = u.target;
            if (z && X.nodeType && !(u.type === "click" && u.button >= 1)) {
              for (; X !== this; X = X.parentNode || this) if (X.nodeType === 1 && !(u.type === "click" && X.disabled === true)) {
                for (C = [], L = {}, b = 0; b < z; b++) S = p[b], A = S.selector + " ", L[A] === void 0 && (L[A] = S.needsContext ? d(A, this).index(X) > -1 : d.find(A, this, null, [
                  X
                ]).length), L[A] && C.push(S);
                C.length && H.push({
                  elem: X,
                  handlers: C
                });
              }
            }
            return X = this, z < p.length && H.push({
              elem: X,
              handlers: p.slice(z)
            }), H;
          },
          addProp: function(u, p) {
            Object.defineProperty(d.Event.prototype, u, {
              enumerable: true,
              configurable: true,
              get: g(p) ? function() {
                if (this.originalEvent) return p(this.originalEvent);
              } : function() {
                if (this.originalEvent) return this.originalEvent[u];
              },
              set: function(b) {
                Object.defineProperty(this, u, {
                  enumerable: true,
                  configurable: true,
                  writable: true,
                  value: b
                });
              }
            });
          },
          fix: function(u) {
            return u[d.expando] ? u : new d.Event(u);
          },
          special: {
            load: {
              noBubble: true
            },
            click: {
              setup: function(u) {
                var p = this || u;
                return me.test(p.type) && p.click && w(p, "input") && Pr(p, "click", true), false;
              },
              trigger: function(u) {
                var p = this || u;
                return me.test(p.type) && p.click && w(p, "input") && Pr(p, "click"), true;
              },
              _default: function(u) {
                var p = u.target;
                return me.test(p.type) && p.click && w(p, "input") && K.get(p, "click") || w(p, "a");
              }
            },
            beforeunload: {
              postDispatch: function(u) {
                u.result !== void 0 && u.originalEvent && (u.originalEvent.returnValue = u.result);
              }
            }
          }
        };
        function Pr(u, p, b) {
          if (!b) {
            K.get(u, p) === void 0 && d.event.add(u, p, ir);
            return;
          }
          K.set(u, p, false), d.event.add(u, p, {
            namespace: false,
            handler: function(S) {
              var A, C = K.get(this, p);
              if (S.isTrigger & 1 && this[p]) {
                if (C) (d.event.special[p] || {}).delegateType && S.stopPropagation();
                else if (C = r.call(arguments), K.set(this, p, C), this[p](), A = K.get(this, p), K.set(this, p, false), C !== A) return S.stopImmediatePropagation(), S.preventDefault(), A;
              } else C && (K.set(this, p, d.event.trigger(C[0], C.slice(1), this)), S.stopPropagation(), S.isImmediatePropagationStopped = ir);
            }
          });
        }
        d.removeEvent = function(u, p, b) {
          u.removeEventListener && u.removeEventListener(p, b);
        }, d.Event = function(u, p) {
          if (!(this instanceof d.Event)) return new d.Event(u, p);
          u && u.type ? (this.originalEvent = u, this.type = u.type, this.isDefaultPrevented = u.defaultPrevented || u.defaultPrevented === void 0 && u.returnValue === false ? ir : rr, this.target = u.target && u.target.nodeType === 3 ? u.target.parentNode : u.target, this.currentTarget = u.currentTarget, this.relatedTarget = u.relatedTarget) : this.type = u, p && d.extend(this, p), this.timeStamp = u && u.timeStamp || Date.now(), this[d.expando] = true;
        }, d.Event.prototype = {
          constructor: d.Event,
          isDefaultPrevented: rr,
          isPropagationStopped: rr,
          isImmediatePropagationStopped: rr,
          isSimulated: false,
          preventDefault: function() {
            var u = this.originalEvent;
            this.isDefaultPrevented = ir, u && !this.isSimulated && u.preventDefault();
          },
          stopPropagation: function() {
            var u = this.originalEvent;
            this.isPropagationStopped = ir, u && !this.isSimulated && u.stopPropagation();
          },
          stopImmediatePropagation: function() {
            var u = this.originalEvent;
            this.isImmediatePropagationStopped = ir, u && !this.isSimulated && u.stopImmediatePropagation(), this.stopPropagation();
          }
        }, d.each({
          altKey: true,
          bubbles: true,
          cancelable: true,
          changedTouches: true,
          ctrlKey: true,
          detail: true,
          eventPhase: true,
          metaKey: true,
          pageX: true,
          pageY: true,
          shiftKey: true,
          view: true,
          char: true,
          code: true,
          charCode: true,
          key: true,
          keyCode: true,
          button: true,
          buttons: true,
          clientX: true,
          clientY: true,
          offsetX: true,
          offsetY: true,
          pointerId: true,
          pointerType: true,
          screenX: true,
          screenY: true,
          targetTouches: true,
          toElement: true,
          touches: true,
          which: true
        }, d.event.addProp), d.each({
          focus: "focusin",
          blur: "focusout"
        }, function(u, p) {
          function b(S) {
            if (v.documentMode) {
              var A = K.get(this, "handle"), C = d.event.fix(S);
              C.type = S.type === "focusin" ? "focus" : "blur", C.isSimulated = true, A(S), C.target === C.currentTarget && A(C);
            } else d.event.simulate(p, S.target, d.event.fix(S));
          }
          d.event.special[u] = {
            setup: function() {
              var S;
              if (Pr(this, u, true), v.documentMode) S = K.get(this, p), S || this.addEventListener(p, b), K.set(this, p, (S || 0) + 1);
              else return false;
            },
            trigger: function() {
              return Pr(this, u), true;
            },
            teardown: function() {
              var S;
              if (v.documentMode) S = K.get(this, p) - 1, S ? K.set(this, p, S) : (this.removeEventListener(p, b), K.remove(this, p));
              else return false;
            },
            _default: function(S) {
              return K.get(S.target, u);
            },
            delegateType: p
          }, d.event.special[p] = {
            setup: function() {
              var S = this.ownerDocument || this.document || this, A = v.documentMode ? this : S, C = K.get(A, p);
              C || (v.documentMode ? this.addEventListener(p, b) : S.addEventListener(u, b, true)), K.set(A, p, (C || 0) + 1);
            },
            teardown: function() {
              var S = this.ownerDocument || this.document || this, A = v.documentMode ? this : S, C = K.get(A, p) - 1;
              C ? K.set(A, p, C) : (v.documentMode ? this.removeEventListener(p, b) : S.removeEventListener(u, b, true), K.remove(A, p));
            }
          };
        }), d.each({
          mouseenter: "mouseover",
          mouseleave: "mouseout",
          pointerenter: "pointerover",
          pointerleave: "pointerout"
        }, function(u, p) {
          d.event.special[u] = {
            delegateType: p,
            bindType: p,
            handle: function(b) {
              var S, A = this, C = b.relatedTarget, L = b.handleObj;
              return (!C || C !== A && !d.contains(A, C)) && (b.type = L.origType, S = L.handler.apply(this, arguments), b.type = p), S;
            }
          };
        }), d.fn.extend({
          on: function(u, p, b, S) {
            return Ai(this, u, p, b, S);
          },
          one: function(u, p, b, S) {
            return Ai(this, u, p, b, S, 1);
          },
          off: function(u, p, b) {
            var S, A;
            if (u && u.preventDefault && u.handleObj) return S = u.handleObj, d(u.delegateTarget).off(S.namespace ? S.origType + "." + S.namespace : S.origType, S.selector, S.handler), this;
            if (typeof u == "object") {
              for (A in u) this.off(A, p, u[A]);
              return this;
            }
            return (p === false || typeof p == "function") && (b = p, p = void 0), b === false && (b = rr), this.each(function() {
              d.event.remove(this, u, b, p);
            });
          }
        });
        var vl = /<script|<style|<link/i, yl = /checked\s*(?:[^=]|=\s*.checked.)/i, Gs = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
        function ca(u, p) {
          return w(u, "table") && w(p.nodeType !== 11 ? p : p.firstChild, "tr") && d(u).children("tbody")[0] || u;
        }
        function Ws(u) {
          return u.type = (u.getAttribute("type") !== null) + "/" + u.type, u;
        }
        function xl(u) {
          return (u.type || "").slice(0, 5) === "true/" ? u.type = u.type.slice(5) : u.removeAttribute("type"), u;
        }
        function ua(u, p) {
          var b, S, A, C, L, H, z;
          if (p.nodeType === 1) {
            if (K.hasData(u) && (C = K.get(u), z = C.events, z)) {
              K.remove(p, "handle events");
              for (A in z) for (b = 0, S = z[A].length; b < S; b++) d.event.add(p, A, z[A][b]);
            }
            le.hasData(u) && (L = le.access(u), H = d.extend({}, L), le.set(p, H));
          }
        }
        function Yc(u, p) {
          var b = p.nodeName.toLowerCase();
          b === "input" && me.test(u.type) ? p.checked = u.checked : (b === "input" || b === "textarea") && (p.defaultValue = u.defaultValue);
        }
        function Dr(u, p, b, S) {
          p = o(p);
          var A, C, L, H, z, X, oe = 0, pe = u.length, ee = pe - 1, xe = p[0], ut = g(xe);
          if (ut || pe > 1 && typeof xe == "string" && !y.checkClone && yl.test(xe)) return u.each(function(Lt) {
            var gt = u.eq(Lt);
            ut && (p[0] = xe.call(this, Lt, gt.html())), Dr(gt, p, b, S);
          });
          if (pe && (A = Kn(p, u[0].ownerDocument, false, u, S), C = A.firstChild, A.childNodes.length === 1 && (A = C), C || S)) {
            for (L = d.map(bt(A, "script"), Ws), H = L.length; oe < pe; oe++) z = A, oe !== ee && (z = d.clone(z, true, true), H && d.merge(L, bt(z, "script"))), b.call(u[oe], z, oe);
            if (H) for (X = L[L.length - 1].ownerDocument, d.map(L, xl), oe = 0; oe < H; oe++) z = L[oe], Ne.test(z.type || "") && !K.access(z, "globalEval") && d.contains(X, z) && (z.src && (z.type || "").toLowerCase() !== "module" ? d._evalUrl && !z.noModule && d._evalUrl(z.src, {
              nonce: z.nonce || z.getAttribute("nonce")
            }, X) : T(z.textContent.replace(Gs, ""), z, X));
          }
          return u;
        }
        function bl(u, p, b) {
          for (var S, A = p ? d.filter(p, u) : u, C = 0; (S = A[C]) != null; C++) !b && S.nodeType === 1 && d.cleanData(bt(S)), S.parentNode && (b && He(S) && fn(bt(S, "script")), S.parentNode.removeChild(S));
          return u;
        }
        d.extend({
          htmlPrefilter: function(u) {
            return u;
          },
          clone: function(u, p, b) {
            var S, A, C, L, H = u.cloneNode(true), z = He(u);
            if (!y.noCloneChecked && (u.nodeType === 1 || u.nodeType === 11) && !d.isXMLDoc(u)) for (L = bt(H), C = bt(u), S = 0, A = C.length; S < A; S++) Yc(C[S], L[S]);
            if (p) if (b) for (C = C || bt(u), L = L || bt(H), S = 0, A = C.length; S < A; S++) ua(C[S], L[S]);
            else ua(u, H);
            return L = bt(H, "script"), L.length > 0 && fn(L, !z && bt(u, "script")), H;
          },
          cleanData: function(u) {
            for (var p, b, S, A = d.event.special, C = 0; (b = u[C]) !== void 0; C++) if ($(b)) {
              if (p = b[K.expando]) {
                if (p.events) for (S in p.events) A[S] ? d.event.remove(b, S) : d.removeEvent(b, S, p.handle);
                b[K.expando] = void 0;
              }
              b[le.expando] && (b[le.expando] = void 0);
            }
          }
        }), d.fn.extend({
          detach: function(u) {
            return bl(this, u, true);
          },
          remove: function(u) {
            return bl(this, u);
          },
          text: function(u) {
            return Ee(this, function(p) {
              return p === void 0 ? d.text(this) : this.empty().each(function() {
                (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) && (this.textContent = p);
              });
            }, null, u, arguments.length);
          },
          append: function() {
            return Dr(this, arguments, function(u) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                var p = ca(this, u);
                p.appendChild(u);
              }
            });
          },
          prepend: function() {
            return Dr(this, arguments, function(u) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                var p = ca(this, u);
                p.insertBefore(u, p.firstChild);
              }
            });
          },
          before: function() {
            return Dr(this, arguments, function(u) {
              this.parentNode && this.parentNode.insertBefore(u, this);
            });
          },
          after: function() {
            return Dr(this, arguments, function(u) {
              this.parentNode && this.parentNode.insertBefore(u, this.nextSibling);
            });
          },
          empty: function() {
            for (var u, p = 0; (u = this[p]) != null; p++) u.nodeType === 1 && (d.cleanData(bt(u, false)), u.textContent = "");
            return this;
          },
          clone: function(u, p) {
            return u = u ?? false, p = p ?? u, this.map(function() {
              return d.clone(this, u, p);
            });
          },
          html: function(u) {
            return Ee(this, function(p) {
              var b = this[0] || {}, S = 0, A = this.length;
              if (p === void 0 && b.nodeType === 1) return b.innerHTML;
              if (typeof p == "string" && !vl.test(p) && !tt[(Oe.exec(p) || [
                "",
                ""
              ])[1].toLowerCase()]) {
                p = d.htmlPrefilter(p);
                try {
                  for (; S < A; S++) b = this[S] || {}, b.nodeType === 1 && (d.cleanData(bt(b, false)), b.innerHTML = p);
                  b = 0;
                } catch {
                }
              }
              b && this.empty().append(p);
            }, null, u, arguments.length);
          },
          replaceWith: function() {
            var u = [];
            return Dr(this, arguments, function(p) {
              var b = this.parentNode;
              d.inArray(this, u) < 0 && (d.cleanData(bt(this)), b && b.replaceChild(p, this));
            }, u);
          }
        }), d.each({
          appendTo: "append",
          prependTo: "prepend",
          insertBefore: "before",
          insertAfter: "after",
          replaceAll: "replaceWith"
        }, function(u, p) {
          d.fn[u] = function(b) {
            for (var S, A = [], C = d(b), L = C.length - 1, H = 0; H <= L; H++) S = H === L ? this : this.clone(true), d(C[H])[p](S), a.apply(A, S.get());
            return this.pushStack(A);
          };
        });
        var ha = new RegExp("^(" + we + ")(?!px)[a-z%]+$", "i"), fa = /^--/, Xs = function(u) {
          var p = u.ownerDocument.defaultView;
          return (!p || !p.opener) && (p = e), p.getComputedStyle(u);
        }, U = function(u, p, b) {
          var S, A, C = {};
          for (A in p) C[A] = u.style[A], u.style[A] = p[A];
          S = b.call(u);
          for (A in p) u.style[A] = C[A];
          return S;
        }, Y = new RegExp(Ze.join("|"), "i");
        (function() {
          function u() {
            if (X) {
              z.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", X.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", nt.appendChild(z).appendChild(X);
              var oe = e.getComputedStyle(X);
              b = oe.top !== "1%", H = p(oe.marginLeft) === 12, X.style.right = "60%", C = p(oe.right) === 36, S = p(oe.width) === 36, X.style.position = "absolute", A = p(X.offsetWidth / 3) === 12, nt.removeChild(z), X = null;
            }
          }
          function p(oe) {
            return Math.round(parseFloat(oe));
          }
          var b, S, A, C, L, H, z = v.createElement("div"), X = v.createElement("div");
          X.style && (X.style.backgroundClip = "content-box", X.cloneNode(true).style.backgroundClip = "", y.clearCloneStyle = X.style.backgroundClip === "content-box", d.extend(y, {
            boxSizingReliable: function() {
              return u(), S;
            },
            pixelBoxStyles: function() {
              return u(), C;
            },
            pixelPosition: function() {
              return u(), b;
            },
            reliableMarginLeft: function() {
              return u(), H;
            },
            scrollboxSize: function() {
              return u(), A;
            },
            reliableTrDimensions: function() {
              var oe, pe, ee, xe;
              return L == null && (oe = v.createElement("table"), pe = v.createElement("tr"), ee = v.createElement("div"), oe.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", pe.style.cssText = "box-sizing:content-box;border:1px solid", pe.style.height = "1px", ee.style.height = "9px", ee.style.display = "block", nt.appendChild(oe).appendChild(pe).appendChild(ee), xe = e.getComputedStyle(pe), L = parseInt(xe.height, 10) + parseInt(xe.borderTopWidth, 10) + parseInt(xe.borderBottomWidth, 10) === pe.offsetHeight, nt.removeChild(oe)), L;
            }
          }));
        })();
        function ne(u, p, b) {
          var S, A, C, L, H = fa.test(p), z = u.style;
          return b = b || Xs(u), b && (L = b.getPropertyValue(p) || b[p], H && L && (L = L.replace(Q, "$1") || void 0), L === "" && !He(u) && (L = d.style(u, p)), !y.pixelBoxStyles() && ha.test(L) && Y.test(p) && (S = z.width, A = z.minWidth, C = z.maxWidth, z.minWidth = z.maxWidth = z.width = L, L = b.width, z.width = S, z.minWidth = A, z.maxWidth = C)), L !== void 0 ? L + "" : L;
        }
        function re(u, p) {
          return {
            get: function() {
              if (u()) {
                delete this.get;
                return;
              }
              return (this.get = p).apply(this, arguments);
            }
          };
        }
        var j = [
          "Webkit",
          "Moz",
          "ms"
        ], be = v.createElement("div").style, Pe = {};
        function We(u) {
          for (var p = u[0].toUpperCase() + u.slice(1), b = j.length; b--; ) if (u = j[b] + p, u in be) return u;
        }
        function Xe(u) {
          var p = d.cssProps[u] || Pe[u];
          return p || (u in be ? u : Pe[u] = We(u) || u);
        }
        var at = /^(none|table(?!-c[ea]).+)/, ct = {
          position: "absolute",
          visibility: "hidden",
          display: "block"
        }, et = {
          letterSpacing: "0",
          fontWeight: "400"
        };
        function At(u, p, b) {
          var S = Ve.exec(p);
          return S ? Math.max(0, S[2] - (b || 0)) + (S[3] || "px") : p;
        }
        function Dt(u, p, b, S, A, C) {
          var L = p === "width" ? 1 : 0, H = 0, z = 0, X = 0;
          if (b === (S ? "border" : "content")) return 0;
          for (; L < 4; L += 2) b === "margin" && (X += d.css(u, b + Ze[L], true, A)), S ? (b === "content" && (z -= d.css(u, "padding" + Ze[L], true, A)), b !== "margin" && (z -= d.css(u, "border" + Ze[L] + "Width", true, A))) : (z += d.css(u, "padding" + Ze[L], true, A), b !== "padding" ? z += d.css(u, "border" + Ze[L] + "Width", true, A) : H += d.css(u, "border" + Ze[L] + "Width", true, A));
          return !S && C >= 0 && (z += Math.max(0, Math.ceil(u["offset" + p[0].toUpperCase() + p.slice(1)] - C - z - H - 0.5)) || 0), z + X;
        }
        function tn(u, p, b) {
          var S = Xs(u), A = !y.boxSizingReliable() || b, C = A && d.css(u, "boxSizing", false, S) === "border-box", L = C, H = ne(u, p, S), z = "offset" + p[0].toUpperCase() + p.slice(1);
          if (ha.test(H)) {
            if (!b) return H;
            H = "auto";
          }
          return (!y.boxSizingReliable() && C || !y.reliableTrDimensions() && w(u, "tr") || H === "auto" || !parseFloat(H) && d.css(u, "display", false, S) === "inline") && u.getClientRects().length && (C = d.css(u, "boxSizing", false, S) === "border-box", L = z in u, L && (H = u[z])), H = parseFloat(H) || 0, H + Dt(u, p, b || (C ? "border" : "content"), L, S, H) + "px";
        }
        d.extend({
          cssHooks: {
            opacity: {
              get: function(u, p) {
                if (p) {
                  var b = ne(u, "opacity");
                  return b === "" ? "1" : b;
                }
              }
            }
          },
          cssNumber: {
            animationIterationCount: true,
            aspectRatio: true,
            borderImageSlice: true,
            columnCount: true,
            flexGrow: true,
            flexShrink: true,
            fontWeight: true,
            gridArea: true,
            gridColumn: true,
            gridColumnEnd: true,
            gridColumnStart: true,
            gridRow: true,
            gridRowEnd: true,
            gridRowStart: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            scale: true,
            widows: true,
            zIndex: true,
            zoom: true,
            fillOpacity: true,
            floodOpacity: true,
            stopOpacity: true,
            strokeMiterlimit: true,
            strokeOpacity: true
          },
          cssProps: {},
          style: function(u, p, b, S) {
            if (!(!u || u.nodeType === 3 || u.nodeType === 8 || !u.style)) {
              var A, C, L, H = I(p), z = fa.test(p), X = u.style;
              if (z || (p = Xe(H)), L = d.cssHooks[p] || d.cssHooks[H], b !== void 0) {
                if (C = typeof b, C === "string" && (A = Ve.exec(b)) && A[1] && (b = Wt(u, p, A), C = "number"), b == null || b !== b) return;
                C === "number" && !z && (b += A && A[3] || (d.cssNumber[H] ? "" : "px")), !y.clearCloneStyle && b === "" && p.indexOf("background") === 0 && (X[p] = "inherit"), (!L || !("set" in L) || (b = L.set(u, b, S)) !== void 0) && (z ? X.setProperty(p, b) : X[p] = b);
              } else return L && "get" in L && (A = L.get(u, false, S)) !== void 0 ? A : X[p];
            }
          },
          css: function(u, p, b, S) {
            var A, C, L, H = I(p), z = fa.test(p);
            return z || (p = Xe(H)), L = d.cssHooks[p] || d.cssHooks[H], L && "get" in L && (A = L.get(u, true, b)), A === void 0 && (A = ne(u, p, S)), A === "normal" && p in et && (A = et[p]), b === "" || b ? (C = parseFloat(A), b === true || isFinite(C) ? C || 0 : A) : A;
          }
        }), d.each([
          "height",
          "width"
        ], function(u, p) {
          d.cssHooks[p] = {
            get: function(b, S, A) {
              if (S) return at.test(d.css(b, "display")) && (!b.getClientRects().length || !b.getBoundingClientRect().width) ? U(b, ct, function() {
                return tn(b, p, A);
              }) : tn(b, p, A);
            },
            set: function(b, S, A) {
              var C, L = Xs(b), H = !y.scrollboxSize() && L.position === "absolute", z = H || A, X = z && d.css(b, "boxSizing", false, L) === "border-box", oe = A ? Dt(b, p, A, X, L) : 0;
              return X && H && (oe -= Math.ceil(b["offset" + p[0].toUpperCase() + p.slice(1)] - parseFloat(L[p]) - Dt(b, p, "border", false, L) - 0.5)), oe && (C = Ve.exec(S)) && (C[3] || "px") !== "px" && (b.style[p] = S, S = d.css(b, p)), At(b, S, oe);
            }
          };
        }), d.cssHooks.marginLeft = re(y.reliableMarginLeft, function(u, p) {
          if (p) return (parseFloat(ne(u, "marginLeft")) || u.getBoundingClientRect().left - U(u, {
            marginLeft: 0
          }, function() {
            return u.getBoundingClientRect().left;
          })) + "px";
        }), d.each({
          margin: "",
          padding: "",
          border: "Width"
        }, function(u, p) {
          d.cssHooks[u + p] = {
            expand: function(b) {
              for (var S = 0, A = {}, C = typeof b == "string" ? b.split(" ") : [
                b
              ]; S < 4; S++) A[u + Ze[S] + p] = C[S] || C[S - 2] || C[0];
              return A;
            }
          }, u !== "margin" && (d.cssHooks[u + p].set = At);
        }), d.fn.extend({
          css: function(u, p) {
            return Ee(this, function(b, S, A) {
              var C, L, H = {}, z = 0;
              if (Array.isArray(S)) {
                for (C = Xs(b), L = S.length; z < L; z++) H[S[z]] = d.css(b, S[z], false, C);
                return H;
              }
              return A !== void 0 ? d.style(b, S, A) : d.css(b, S);
            }, u, p, arguments.length > 1);
          }
        });
        function St(u, p, b, S, A) {
          return new St.prototype.init(u, p, b, S, A);
        }
        d.Tween = St, St.prototype = {
          constructor: St,
          init: function(u, p, b, S, A, C) {
            this.elem = u, this.prop = b, this.easing = A || d.easing._default, this.options = p, this.start = this.now = this.cur(), this.end = S, this.unit = C || (d.cssNumber[b] ? "" : "px");
          },
          cur: function() {
            var u = St.propHooks[this.prop];
            return u && u.get ? u.get(this) : St.propHooks._default.get(this);
          },
          run: function(u) {
            var p, b = St.propHooks[this.prop];
            return this.options.duration ? this.pos = p = d.easing[this.easing](u, this.options.duration * u, 0, 1, this.options.duration) : this.pos = p = u, this.now = (this.end - this.start) * p + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), b && b.set ? b.set(this) : St.propHooks._default.set(this), this;
          }
        }, St.prototype.init.prototype = St.prototype, St.propHooks = {
          _default: {
            get: function(u) {
              var p;
              return u.elem.nodeType !== 1 || u.elem[u.prop] != null && u.elem.style[u.prop] == null ? u.elem[u.prop] : (p = d.css(u.elem, u.prop, ""), !p || p === "auto" ? 0 : p);
            },
            set: function(u) {
              d.fx.step[u.prop] ? d.fx.step[u.prop](u) : u.elem.nodeType === 1 && (d.cssHooks[u.prop] || u.elem.style[Xe(u.prop)] != null) ? d.style(u.elem, u.prop, u.now + u.unit) : u.elem[u.prop] = u.now;
            }
          }
        }, St.propHooks.scrollTop = St.propHooks.scrollLeft = {
          set: function(u) {
            u.elem.nodeType && u.elem.parentNode && (u.elem[u.prop] = u.now);
          }
        }, d.easing = {
          linear: function(u) {
            return u;
          },
          swing: function(u) {
            return 0.5 - Math.cos(u * Math.PI) / 2;
          },
          _default: "swing"
        }, d.fx = St.prototype.init, d.fx.step = {};
        var yt, Qe, xn = /^(?:toggle|show|hide)$/, Ft = /queueHooks$/;
        function Hn() {
          Qe && (v.hidden === false && e.requestAnimationFrame ? e.requestAnimationFrame(Hn) : e.setTimeout(Hn, d.fx.interval), d.fx.tick());
        }
        function sr() {
          return e.setTimeout(function() {
            yt = void 0;
          }), yt = Date.now();
        }
        function wn(u, p) {
          var b, S = 0, A = {
            height: u
          };
          for (p = p ? 1 : 0; S < 4; S += 2 - p) b = Ze[S], A["margin" + b] = A["padding" + b] = u;
          return p && (A.opacity = A.width = u), A;
        }
        function Lr(u, p, b) {
          for (var S, A = (Qt.tweeners[p] || []).concat(Qt.tweeners["*"]), C = 0, L = A.length; C < L; C++) if (S = A[C].call(b, p, u)) return S;
        }
        function Zt(u, p, b) {
          var S, A, C, L, H, z, X, oe, pe = "width" in p || "height" in p, ee = this, xe = {}, ut = u.style, Lt = u.nodeType && ht(u), gt = K.get(u, "fxshow");
          b.queue || (L = d._queueHooks(u, "fx"), L.unqueued == null && (L.unqueued = 0, H = L.empty.fire, L.empty.fire = function() {
            L.unqueued || H();
          }), L.unqueued++, ee.always(function() {
            ee.always(function() {
              L.unqueued--, d.queue(u, "fx").length || L.empty.fire();
            });
          }));
          for (S in p) if (A = p[S], xn.test(A)) {
            if (delete p[S], C = C || A === "toggle", A === (Lt ? "hide" : "show")) if (A === "show" && gt && gt[S] !== void 0) Lt = true;
            else continue;
            xe[S] = gt && gt[S] || d.style(u, S);
          }
          if (z = !d.isEmptyObject(p), !(!z && d.isEmptyObject(xe))) {
            pe && u.nodeType === 1 && (b.overflow = [
              ut.overflow,
              ut.overflowX,
              ut.overflowY
            ], X = gt && gt.display, X == null && (X = K.get(u, "display")), oe = d.css(u, "display"), oe === "none" && (X ? oe = X : (ae([
              u
            ], true), X = u.style.display || X, oe = d.css(u, "display"), ae([
              u
            ]))), (oe === "inline" || oe === "inline-block" && X != null) && d.css(u, "float") === "none" && (z || (ee.done(function() {
              ut.display = X;
            }), X == null && (oe = ut.display, X = oe === "none" ? "" : oe)), ut.display = "inline-block")), b.overflow && (ut.overflow = "hidden", ee.always(function() {
              ut.overflow = b.overflow[0], ut.overflowX = b.overflow[1], ut.overflowY = b.overflow[2];
            })), z = false;
            for (S in xe) z || (gt ? "hidden" in gt && (Lt = gt.hidden) : gt = K.access(u, "fxshow", {
              display: X
            }), C && (gt.hidden = !Lt), Lt && ae([
              u
            ], true), ee.done(function() {
              Lt || ae([
                u
              ]), K.remove(u, "fxshow");
              for (S in xe) d.style(u, S, xe[S]);
            })), z = Lr(Lt ? gt[S] : 0, S, ee), S in gt || (gt[S] = z.start, Lt && (z.end = z.start, z.start = 0));
          }
        }
        function Zn(u, p) {
          var b, S, A, C, L;
          for (b in u) if (S = I(b), A = p[S], C = u[b], Array.isArray(C) && (A = C[1], C = u[b] = C[0]), b !== S && (u[S] = C, delete u[b]), L = d.cssHooks[S], L && "expand" in L) {
            C = L.expand(C), delete u[S];
            for (b in C) b in u || (u[b] = C[b], p[b] = A);
          } else p[S] = A;
        }
        function Qt(u, p, b) {
          var S, A, C = 0, L = Qt.prefilters.length, H = d.Deferred().always(function() {
            delete z.elem;
          }), z = function() {
            if (A) return false;
            for (var pe = yt || sr(), ee = Math.max(0, X.startTime + X.duration - pe), xe = ee / X.duration || 0, ut = 1 - xe, Lt = 0, gt = X.tweens.length; Lt < gt; Lt++) X.tweens[Lt].run(ut);
            return H.notifyWith(u, [
              X,
              ut,
              ee
            ]), ut < 1 && gt ? ee : (gt || H.notifyWith(u, [
              X,
              1,
              0
            ]), H.resolveWith(u, [
              X
            ]), false);
          }, X = H.promise({
            elem: u,
            props: d.extend({}, p),
            opts: d.extend(true, {
              specialEasing: {},
              easing: d.easing._default
            }, b),
            originalProperties: p,
            originalOptions: b,
            startTime: yt || sr(),
            duration: b.duration,
            tweens: [],
            createTween: function(pe, ee) {
              var xe = d.Tween(u, X.opts, pe, ee, X.opts.specialEasing[pe] || X.opts.easing);
              return X.tweens.push(xe), xe;
            },
            stop: function(pe) {
              var ee = 0, xe = pe ? X.tweens.length : 0;
              if (A) return this;
              for (A = true; ee < xe; ee++) X.tweens[ee].run(1);
              return pe ? (H.notifyWith(u, [
                X,
                1,
                0
              ]), H.resolveWith(u, [
                X,
                pe
              ])) : H.rejectWith(u, [
                X,
                pe
              ]), this;
            }
          }), oe = X.props;
          for (Zn(oe, X.opts.specialEasing); C < L; C++) if (S = Qt.prefilters[C].call(X, u, oe, X.opts), S) return g(S.stop) && (d._queueHooks(X.elem, X.opts.queue).stop = S.stop.bind(S)), S;
          return d.map(oe, Lr, X), g(X.opts.start) && X.opts.start.call(u, X), X.progress(X.opts.progress).done(X.opts.done, X.opts.complete).fail(X.opts.fail).always(X.opts.always), d.fx.timer(d.extend(z, {
            elem: u,
            anim: X,
            queue: X.opts.queue
          })), X;
        }
        d.Animation = d.extend(Qt, {
          tweeners: {
            "*": [
              function(u, p) {
                var b = this.createTween(u, p);
                return Wt(b.elem, u, Ve.exec(p), b), b;
              }
            ]
          },
          tweener: function(u, p) {
            g(u) ? (p = u, u = [
              "*"
            ]) : u = u.match(Fe);
            for (var b, S = 0, A = u.length; S < A; S++) b = u[S], Qt.tweeners[b] = Qt.tweeners[b] || [], Qt.tweeners[b].unshift(p);
          },
          prefilters: [
            Zt
          ],
          prefilter: function(u, p) {
            p ? Qt.prefilters.unshift(u) : Qt.prefilters.push(u);
          }
        }), d.speed = function(u, p, b) {
          var S = u && typeof u == "object" ? d.extend({}, u) : {
            complete: b || !b && p || g(u) && u,
            duration: u,
            easing: b && p || p && !g(p) && p
          };
          return d.fx.off ? S.duration = 0 : typeof S.duration != "number" && (S.duration in d.fx.speeds ? S.duration = d.fx.speeds[S.duration] : S.duration = d.fx.speeds._default), (S.queue == null || S.queue === true) && (S.queue = "fx"), S.old = S.complete, S.complete = function() {
            g(S.old) && S.old.call(this), S.queue && d.dequeue(this, S.queue);
          }, S;
        }, d.fn.extend({
          fadeTo: function(u, p, b, S) {
            return this.filter(ht).css("opacity", 0).show().end().animate({
              opacity: p
            }, u, b, S);
          },
          animate: function(u, p, b, S) {
            var A = d.isEmptyObject(u), C = d.speed(p, b, S), L = function() {
              var H = Qt(this, d.extend({}, u), C);
              (A || K.get(this, "finish")) && H.stop(true);
            };
            return L.finish = L, A || C.queue === false ? this.each(L) : this.queue(C.queue, L);
          },
          stop: function(u, p, b) {
            var S = function(A) {
              var C = A.stop;
              delete A.stop, C(b);
            };
            return typeof u != "string" && (b = p, p = u, u = void 0), p && this.queue(u || "fx", []), this.each(function() {
              var A = true, C = u != null && u + "queueHooks", L = d.timers, H = K.get(this);
              if (C) H[C] && H[C].stop && S(H[C]);
              else for (C in H) H[C] && H[C].stop && Ft.test(C) && S(H[C]);
              for (C = L.length; C--; ) L[C].elem === this && (u == null || L[C].queue === u) && (L[C].anim.stop(b), A = false, L.splice(C, 1));
              (A || !b) && d.dequeue(this, u);
            });
          },
          finish: function(u) {
            return u !== false && (u = u || "fx"), this.each(function() {
              var p, b = K.get(this), S = b[u + "queue"], A = b[u + "queueHooks"], C = d.timers, L = S ? S.length : 0;
              for (b.finish = true, d.queue(this, u, []), A && A.stop && A.stop.call(this, true), p = C.length; p--; ) C[p].elem === this && C[p].queue === u && (C[p].anim.stop(true), C.splice(p, 1));
              for (p = 0; p < L; p++) S[p] && S[p].finish && S[p].finish.call(this);
              delete b.finish;
            });
          }
        }), d.each([
          "toggle",
          "show",
          "hide"
        ], function(u, p) {
          var b = d.fn[p];
          d.fn[p] = function(S, A, C) {
            return S == null || typeof S == "boolean" ? b.apply(this, arguments) : this.animate(wn(p, true), S, A, C);
          };
        }), d.each({
          slideDown: wn("show"),
          slideUp: wn("hide"),
          slideToggle: wn("toggle"),
          fadeIn: {
            opacity: "show"
          },
          fadeOut: {
            opacity: "hide"
          },
          fadeToggle: {
            opacity: "toggle"
          }
        }, function(u, p) {
          d.fn[u] = function(b, S, A) {
            return this.animate(p, b, S, A);
          };
        }), d.timers = [], d.fx.tick = function() {
          var u, p = 0, b = d.timers;
          for (yt = Date.now(); p < b.length; p++) u = b[p], !u() && b[p] === u && b.splice(p--, 1);
          b.length || d.fx.stop(), yt = void 0;
        }, d.fx.timer = function(u) {
          d.timers.push(u), d.fx.start();
        }, d.fx.interval = 13, d.fx.start = function() {
          Qe || (Qe = true, Hn());
        }, d.fx.stop = function() {
          Qe = null;
        }, d.fx.speeds = {
          slow: 600,
          fast: 200,
          _default: 400
        }, d.fn.delay = function(u, p) {
          return u = d.fx && d.fx.speeds[u] || u, p = p || "fx", this.queue(p, function(b, S) {
            var A = e.setTimeout(b, u);
            S.stop = function() {
              e.clearTimeout(A);
            };
          });
        }, function() {
          var u = v.createElement("input"), p = v.createElement("select"), b = p.appendChild(v.createElement("option"));
          u.type = "checkbox", y.checkOn = u.value !== "", y.optSelected = b.selected, u = v.createElement("input"), u.value = "t", u.type = "radio", y.radioValue = u.value === "t";
        }();
        var An, dn = d.expr.attrHandle;
        d.fn.extend({
          attr: function(u, p) {
            return Ee(this, d.attr, u, p, arguments.length > 1);
          },
          removeAttr: function(u) {
            return this.each(function() {
              d.removeAttr(this, u);
            });
          }
        }), d.extend({
          attr: function(u, p, b) {
            var S, A, C = u.nodeType;
            if (!(C === 3 || C === 8 || C === 2)) {
              if (typeof u.getAttribute > "u") return d.prop(u, p, b);
              if ((C !== 1 || !d.isXMLDoc(u)) && (A = d.attrHooks[p.toLowerCase()] || (d.expr.match.bool.test(p) ? An : void 0)), b !== void 0) {
                if (b === null) {
                  d.removeAttr(u, p);
                  return;
                }
                return A && "set" in A && (S = A.set(u, b, p)) !== void 0 ? S : (u.setAttribute(p, b + ""), b);
              }
              return A && "get" in A && (S = A.get(u, p)) !== null ? S : (S = d.find.attr(u, p), S ?? void 0);
            }
          },
          attrHooks: {
            type: {
              set: function(u, p) {
                if (!y.radioValue && p === "radio" && w(u, "input")) {
                  var b = u.value;
                  return u.setAttribute("type", p), b && (u.value = b), p;
                }
              }
            }
          },
          removeAttr: function(u, p) {
            var b, S = 0, A = p && p.match(Fe);
            if (A && u.nodeType === 1) for (; b = A[S++]; ) u.removeAttribute(b);
          }
        }), An = {
          set: function(u, p, b) {
            return p === false ? d.removeAttr(u, b) : u.setAttribute(b, b), b;
          }
        }, d.each(d.expr.match.bool.source.match(/\w+/g), function(u, p) {
          var b = dn[p] || d.find.attr;
          dn[p] = function(S, A, C) {
            var L, H, z = A.toLowerCase();
            return C || (H = dn[z], dn[z] = L, L = b(S, A, C) != null ? z : null, dn[z] = H), L;
          };
        });
        var da = /^(?:input|select|textarea|button)$/i, or = /^(?:a|area)$/i;
        d.fn.extend({
          prop: function(u, p) {
            return Ee(this, d.prop, u, p, arguments.length > 1);
          },
          removeProp: function(u) {
            return this.each(function() {
              delete this[d.propFix[u] || u];
            });
          }
        }), d.extend({
          prop: function(u, p, b) {
            var S, A, C = u.nodeType;
            if (!(C === 3 || C === 8 || C === 2)) return (C !== 1 || !d.isXMLDoc(u)) && (p = d.propFix[p] || p, A = d.propHooks[p]), b !== void 0 ? A && "set" in A && (S = A.set(u, b, p)) !== void 0 ? S : u[p] = b : A && "get" in A && (S = A.get(u, p)) !== null ? S : u[p];
          },
          propHooks: {
            tabIndex: {
              get: function(u) {
                var p = d.find.attr(u, "tabindex");
                return p ? parseInt(p, 10) : da.test(u.nodeName) || or.test(u.nodeName) && u.href ? 0 : -1;
              }
            }
          },
          propFix: {
            for: "htmlFor",
            class: "className"
          }
        }), y.optSelected || (d.propHooks.selected = {
          get: function(u) {
            var p = u.parentNode;
            return p && p.parentNode && p.parentNode.selectedIndex, null;
          },
          set: function(u) {
            var p = u.parentNode;
            p && (p.selectedIndex, p.parentNode && p.parentNode.selectedIndex);
          }
        }), d.each([
          "tabIndex",
          "readOnly",
          "maxLength",
          "cellSpacing",
          "cellPadding",
          "rowSpan",
          "colSpan",
          "useMap",
          "frameBorder",
          "contentEditable"
        ], function() {
          d.propFix[this.toLowerCase()] = this;
        });
        function as(u) {
          var p = u.match(Fe) || [];
          return p.join(" ");
        }
        function ls(u) {
          return u.getAttribute && u.getAttribute("class") || "";
        }
        function jc(u) {
          return Array.isArray(u) ? u : typeof u == "string" ? u.match(Fe) || [] : [];
        }
        d.fn.extend({
          addClass: function(u) {
            var p, b, S, A, C, L;
            return g(u) ? this.each(function(H) {
              d(this).addClass(u.call(this, H, ls(this)));
            }) : (p = jc(u), p.length ? this.each(function() {
              if (S = ls(this), b = this.nodeType === 1 && " " + as(S) + " ", b) {
                for (C = 0; C < p.length; C++) A = p[C], b.indexOf(" " + A + " ") < 0 && (b += A + " ");
                L = as(b), S !== L && this.setAttribute("class", L);
              }
            }) : this);
          },
          removeClass: function(u) {
            var p, b, S, A, C, L;
            return g(u) ? this.each(function(H) {
              d(this).removeClass(u.call(this, H, ls(this)));
            }) : arguments.length ? (p = jc(u), p.length ? this.each(function() {
              if (S = ls(this), b = this.nodeType === 1 && " " + as(S) + " ", b) {
                for (C = 0; C < p.length; C++) for (A = p[C]; b.indexOf(" " + A + " ") > -1; ) b = b.replace(" " + A + " ", " ");
                L = as(b), S !== L && this.setAttribute("class", L);
              }
            }) : this) : this.attr("class", "");
          },
          toggleClass: function(u, p) {
            var b, S, A, C, L = typeof u, H = L === "string" || Array.isArray(u);
            return g(u) ? this.each(function(z) {
              d(this).toggleClass(u.call(this, z, ls(this), p), p);
            }) : typeof p == "boolean" && H ? p ? this.addClass(u) : this.removeClass(u) : (b = jc(u), this.each(function() {
              if (H) for (C = d(this), A = 0; A < b.length; A++) S = b[A], C.hasClass(S) ? C.removeClass(S) : C.addClass(S);
              else (u === void 0 || L === "boolean") && (S = ls(this), S && K.set(this, "__className__", S), this.setAttribute && this.setAttribute("class", S || u === false ? "" : K.get(this, "__className__") || ""));
            }));
          },
          hasClass: function(u) {
            var p, b, S = 0;
            for (p = " " + u + " "; b = this[S++]; ) if (b.nodeType === 1 && (" " + as(ls(b)) + " ").indexOf(p) > -1) return true;
            return false;
          }
        });
        var W_ = /\r/g;
        d.fn.extend({
          val: function(u) {
            var p, b, S, A = this[0];
            return arguments.length ? (S = g(u), this.each(function(C) {
              var L;
              this.nodeType === 1 && (S ? L = u.call(this, C, d(this).val()) : L = u, L == null ? L = "" : typeof L == "number" ? L += "" : Array.isArray(L) && (L = d.map(L, function(H) {
                return H == null ? "" : H + "";
              })), p = d.valHooks[this.type] || d.valHooks[this.nodeName.toLowerCase()], (!p || !("set" in p) || p.set(this, L, "value") === void 0) && (this.value = L));
            })) : A ? (p = d.valHooks[A.type] || d.valHooks[A.nodeName.toLowerCase()], p && "get" in p && (b = p.get(A, "value")) !== void 0 ? b : (b = A.value, typeof b == "string" ? b.replace(W_, "") : b ?? "")) : void 0;
          }
        }), d.extend({
          valHooks: {
            option: {
              get: function(u) {
                var p = d.find.attr(u, "value");
                return p ?? as(d.text(u));
              }
            },
            select: {
              get: function(u) {
                var p, b, S, A = u.options, C = u.selectedIndex, L = u.type === "select-one", H = L ? null : [], z = L ? C + 1 : A.length;
                for (C < 0 ? S = z : S = L ? C : 0; S < z; S++) if (b = A[S], (b.selected || S === C) && !b.disabled && (!b.parentNode.disabled || !w(b.parentNode, "optgroup"))) {
                  if (p = d(b).val(), L) return p;
                  H.push(p);
                }
                return H;
              },
              set: function(u, p) {
                for (var b, S, A = u.options, C = d.makeArray(p), L = A.length; L--; ) S = A[L], (S.selected = d.inArray(d.valHooks.option.get(S), C) > -1) && (b = true);
                return b || (u.selectedIndex = -1), C;
              }
            }
          }
        }), d.each([
          "radio",
          "checkbox"
        ], function() {
          d.valHooks[this] = {
            set: function(u, p) {
              if (Array.isArray(p)) return u.checked = d.inArray(d(u).val(), p) > -1;
            }
          }, y.checkOn || (d.valHooks[this].get = function(u) {
            return u.getAttribute("value") === null ? "on" : u.value;
          });
        });
        var pa = e.location, pd = {
          guid: Date.now()
        }, $c = /\?/;
        d.parseXML = function(u) {
          var p, b;
          if (!u || typeof u != "string") return null;
          try {
            p = new e.DOMParser().parseFromString(u, "text/xml");
          } catch {
          }
          return b = p && p.getElementsByTagName("parsererror")[0], (!p || b) && d.error("Invalid XML: " + (b ? d.map(b.childNodes, function(S) {
            return S.textContent;
          }).join(`
`) : u)), p;
        };
        var md = /^(?:focusinfocus|focusoutblur)$/, gd = function(u) {
          u.stopPropagation();
        };
        d.extend(d.event, {
          trigger: function(u, p, b, S) {
            var A, C, L, H, z, X, oe, pe, ee = [
              b || v
            ], xe = f.call(u, "type") ? u.type : u, ut = f.call(u, "namespace") ? u.namespace.split(".") : [];
            if (C = pe = L = b = b || v, !(b.nodeType === 3 || b.nodeType === 8) && !md.test(xe + d.event.triggered) && (xe.indexOf(".") > -1 && (ut = xe.split("."), xe = ut.shift(), ut.sort()), z = xe.indexOf(":") < 0 && "on" + xe, u = u[d.expando] ? u : new d.Event(xe, typeof u == "object" && u), u.isTrigger = S ? 2 : 3, u.namespace = ut.join("."), u.rnamespace = u.namespace ? new RegExp("(^|\\.)" + ut.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, u.result = void 0, u.target || (u.target = b), p = p == null ? [
              u
            ] : d.makeArray(p, [
              u
            ]), oe = d.event.special[xe] || {}, !(!S && oe.trigger && oe.trigger.apply(b, p) === false))) {
              if (!S && !oe.noBubble && !x(b)) {
                for (H = oe.delegateType || xe, md.test(H + xe) || (C = C.parentNode); C; C = C.parentNode) ee.push(C), L = C;
                L === (b.ownerDocument || v) && ee.push(L.defaultView || L.parentWindow || e);
              }
              for (A = 0; (C = ee[A++]) && !u.isPropagationStopped(); ) pe = C, u.type = A > 1 ? H : oe.bindType || xe, X = (K.get(C, "events") || /* @__PURE__ */ Object.create(null))[u.type] && K.get(C, "handle"), X && X.apply(C, p), X = z && C[z], X && X.apply && $(C) && (u.result = X.apply(C, p), u.result === false && u.preventDefault());
              return u.type = xe, !S && !u.isDefaultPrevented() && (!oe._default || oe._default.apply(ee.pop(), p) === false) && $(b) && z && g(b[xe]) && !x(b) && (L = b[z], L && (b[z] = null), d.event.triggered = xe, u.isPropagationStopped() && pe.addEventListener(xe, gd), b[xe](), u.isPropagationStopped() && pe.removeEventListener(xe, gd), d.event.triggered = void 0, L && (b[z] = L)), u.result;
            }
          },
          simulate: function(u, p, b) {
            var S = d.extend(new d.Event(), b, {
              type: u,
              isSimulated: true
            });
            d.event.trigger(S, null, p);
          }
        }), d.fn.extend({
          trigger: function(u, p) {
            return this.each(function() {
              d.event.trigger(u, p, this);
            });
          },
          triggerHandler: function(u, p) {
            var b = this[0];
            if (b) return d.event.trigger(u, p, b, true);
          }
        });
        var X_ = /\[\]$/, _d = /\r?\n/g, q_ = /^(?:submit|button|image|reset|file)$/i, Y_ = /^(?:input|select|textarea|keygen)/i;
        function Kc(u, p, b, S) {
          var A;
          if (Array.isArray(p)) d.each(p, function(C, L) {
            b || X_.test(u) ? S(u, L) : Kc(u + "[" + (typeof L == "object" && L != null ? C : "") + "]", L, b, S);
          });
          else if (!b && M(p) === "object") for (A in p) Kc(u + "[" + A + "]", p[A], b, S);
          else S(u, p);
        }
        d.param = function(u, p) {
          var b, S = [], A = function(C, L) {
            var H = g(L) ? L() : L;
            S[S.length] = encodeURIComponent(C) + "=" + encodeURIComponent(H ?? "");
          };
          if (u == null) return "";
          if (Array.isArray(u) || u.jquery && !d.isPlainObject(u)) d.each(u, function() {
            A(this.name, this.value);
          });
          else for (b in u) Kc(b, u[b], p, A);
          return S.join("&");
        }, d.fn.extend({
          serialize: function() {
            return d.param(this.serializeArray());
          },
          serializeArray: function() {
            return this.map(function() {
              var u = d.prop(this, "elements");
              return u ? d.makeArray(u) : this;
            }).filter(function() {
              var u = this.type;
              return this.name && !d(this).is(":disabled") && Y_.test(this.nodeName) && !q_.test(u) && (this.checked || !me.test(u));
            }).map(function(u, p) {
              var b = d(this).val();
              return b == null ? null : Array.isArray(b) ? d.map(b, function(S) {
                return {
                  name: p.name,
                  value: S.replace(_d, `\r
`)
                };
              }) : {
                name: p.name,
                value: b.replace(_d, `\r
`)
              };
            }).get();
          }
        });
        var j_ = /%20/g, $_ = /#.*$/, K_ = /([?&])_=[^&]*/, Z_ = /^(.*?):[ \t]*([^\r\n]*)$/mg, J_ = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, Q_ = /^(?:GET|HEAD)$/, e0 = /^\/\//, vd = {}, Zc = {}, yd = "*/".concat("*"), Jc = v.createElement("a");
        Jc.href = pa.href;
        function xd(u) {
          return function(p, b) {
            typeof p != "string" && (b = p, p = "*");
            var S, A = 0, C = p.toLowerCase().match(Fe) || [];
            if (g(b)) for (; S = C[A++]; ) S[0] === "+" ? (S = S.slice(1) || "*", (u[S] = u[S] || []).unshift(b)) : (u[S] = u[S] || []).push(b);
          };
        }
        function bd(u, p, b, S) {
          var A = {}, C = u === Zc;
          function L(H) {
            var z;
            return A[H] = true, d.each(u[H] || [], function(X, oe) {
              var pe = oe(p, b, S);
              if (typeof pe == "string" && !C && !A[pe]) return p.dataTypes.unshift(pe), L(pe), false;
              if (C) return !(z = pe);
            }), z;
          }
          return L(p.dataTypes[0]) || !A["*"] && L("*");
        }
        function Qc(u, p) {
          var b, S, A = d.ajaxSettings.flatOptions || {};
          for (b in p) p[b] !== void 0 && ((A[b] ? u : S || (S = {}))[b] = p[b]);
          return S && d.extend(true, u, S), u;
        }
        function t0(u, p, b) {
          for (var S, A, C, L, H = u.contents, z = u.dataTypes; z[0] === "*"; ) z.shift(), S === void 0 && (S = u.mimeType || p.getResponseHeader("Content-Type"));
          if (S) {
            for (A in H) if (H[A] && H[A].test(S)) {
              z.unshift(A);
              break;
            }
          }
          if (z[0] in b) C = z[0];
          else {
            for (A in b) {
              if (!z[0] || u.converters[A + " " + z[0]]) {
                C = A;
                break;
              }
              L || (L = A);
            }
            C = C || L;
          }
          if (C) return C !== z[0] && z.unshift(C), b[C];
        }
        function n0(u, p, b, S) {
          var A, C, L, H, z, X = {}, oe = u.dataTypes.slice();
          if (oe[1]) for (L in u.converters) X[L.toLowerCase()] = u.converters[L];
          for (C = oe.shift(); C; ) if (u.responseFields[C] && (b[u.responseFields[C]] = p), !z && S && u.dataFilter && (p = u.dataFilter(p, u.dataType)), z = C, C = oe.shift(), C) {
            if (C === "*") C = z;
            else if (z !== "*" && z !== C) {
              if (L = X[z + " " + C] || X["* " + C], !L) {
                for (A in X) if (H = A.split(" "), H[1] === C && (L = X[z + " " + H[0]] || X["* " + H[0]], L)) {
                  L === true ? L = X[A] : X[A] !== true && (C = H[0], oe.unshift(H[1]));
                  break;
                }
              }
              if (L !== true) if (L && u.throws) p = L(p);
              else try {
                p = L(p);
              } catch (pe) {
                return {
                  state: "parsererror",
                  error: L ? pe : "No conversion from " + z + " to " + C
                };
              }
            }
          }
          return {
            state: "success",
            data: p
          };
        }
        d.extend({
          active: 0,
          lastModified: {},
          etag: {},
          ajaxSettings: {
            url: pa.href,
            type: "GET",
            isLocal: J_.test(pa.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
              "*": yd,
              text: "text/plain",
              html: "text/html",
              xml: "application/xml, text/xml",
              json: "application/json, text/javascript"
            },
            contents: {
              xml: /\bxml\b/,
              html: /\bhtml/,
              json: /\bjson\b/
            },
            responseFields: {
              xml: "responseXML",
              text: "responseText",
              json: "responseJSON"
            },
            converters: {
              "* text": String,
              "text html": true,
              "text json": JSON.parse,
              "text xml": d.parseXML
            },
            flatOptions: {
              url: true,
              context: true
            }
          },
          ajaxSetup: function(u, p) {
            return p ? Qc(Qc(u, d.ajaxSettings), p) : Qc(d.ajaxSettings, u);
          },
          ajaxPrefilter: xd(vd),
          ajaxTransport: xd(Zc),
          ajax: function(u, p) {
            typeof u == "object" && (p = u, u = void 0), p = p || {};
            var b, S, A, C, L, H, z, X, oe, pe, ee = d.ajaxSetup({}, p), xe = ee.context || ee, ut = ee.context && (xe.nodeType || xe.jquery) ? d(xe) : d.event, Lt = d.Deferred(), gt = d.Callbacks("once memory"), Pn = ee.statusCode || {}, bn = {}, Oi = {}, Fi = "canceled", Ct = {
              readyState: 0,
              getResponseHeader: function(Ut) {
                var an;
                if (z) {
                  if (!C) for (C = {}; an = Z_.exec(A); ) C[an[1].toLowerCase() + " "] = (C[an[1].toLowerCase() + " "] || []).concat(an[2]);
                  an = C[Ut.toLowerCase() + " "];
                }
                return an == null ? null : an.join(", ");
              },
              getAllResponseHeaders: function() {
                return z ? A : null;
              },
              setRequestHeader: function(Ut, an) {
                return z == null && (Ut = Oi[Ut.toLowerCase()] = Oi[Ut.toLowerCase()] || Ut, bn[Ut] = an), this;
              },
              overrideMimeType: function(Ut) {
                return z == null && (ee.mimeType = Ut), this;
              },
              statusCode: function(Ut) {
                var an;
                if (Ut) if (z) Ct.always(Ut[Ct.status]);
                else for (an in Ut) Pn[an] = [
                  Pn[an],
                  Ut[an]
                ];
                return this;
              },
              abort: function(Ut) {
                var an = Ut || Fi;
                return b && b.abort(an), cs(0, an), this;
              }
            };
            if (Lt.promise(Ct), ee.url = ((u || ee.url || pa.href) + "").replace(e0, pa.protocol + "//"), ee.type = p.method || p.type || ee.method || ee.type, ee.dataTypes = (ee.dataType || "*").toLowerCase().match(Fe) || [
              ""
            ], ee.crossDomain == null) {
              H = v.createElement("a");
              try {
                H.href = ee.url, H.href = H.href, ee.crossDomain = Jc.protocol + "//" + Jc.host != H.protocol + "//" + H.host;
              } catch {
                ee.crossDomain = true;
              }
            }
            if (ee.data && ee.processData && typeof ee.data != "string" && (ee.data = d.param(ee.data, ee.traditional)), bd(vd, ee, p, Ct), z) return Ct;
            X = d.event && ee.global, X && d.active++ === 0 && d.event.trigger("ajaxStart"), ee.type = ee.type.toUpperCase(), ee.hasContent = !Q_.test(ee.type), S = ee.url.replace($_, ""), ee.hasContent ? ee.data && ee.processData && (ee.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && (ee.data = ee.data.replace(j_, "+")) : (pe = ee.url.slice(S.length), ee.data && (ee.processData || typeof ee.data == "string") && (S += ($c.test(S) ? "&" : "?") + ee.data, delete ee.data), ee.cache === false && (S = S.replace(K_, "$1"), pe = ($c.test(S) ? "&" : "?") + "_=" + pd.guid++ + pe), ee.url = S + pe), ee.ifModified && (d.lastModified[S] && Ct.setRequestHeader("If-Modified-Since", d.lastModified[S]), d.etag[S] && Ct.setRequestHeader("If-None-Match", d.etag[S])), (ee.data && ee.hasContent && ee.contentType !== false || p.contentType) && Ct.setRequestHeader("Content-Type", ee.contentType), Ct.setRequestHeader("Accept", ee.dataTypes[0] && ee.accepts[ee.dataTypes[0]] ? ee.accepts[ee.dataTypes[0]] + (ee.dataTypes[0] !== "*" ? ", " + yd + "; q=0.01" : "") : ee.accepts["*"]);
            for (oe in ee.headers) Ct.setRequestHeader(oe, ee.headers[oe]);
            if (ee.beforeSend && (ee.beforeSend.call(xe, Ct, ee) === false || z)) return Ct.abort();
            if (Fi = "abort", gt.add(ee.complete), Ct.done(ee.success), Ct.fail(ee.error), b = bd(Zc, ee, p, Ct), !b) cs(-1, "No Transport");
            else {
              if (Ct.readyState = 1, X && ut.trigger("ajaxSend", [
                Ct,
                ee
              ]), z) return Ct;
              ee.async && ee.timeout > 0 && (L = e.setTimeout(function() {
                Ct.abort("timeout");
              }, ee.timeout));
              try {
                z = false, b.send(bn, cs);
              } catch (Ut) {
                if (z) throw Ut;
                cs(-1, Ut);
              }
            }
            function cs(Ut, an, ga, tu) {
              var ki, _a, Bi, Ir, Nr, vi = an;
              z || (z = true, L && e.clearTimeout(L), b = void 0, A = tu || "", Ct.readyState = Ut > 0 ? 4 : 0, ki = Ut >= 200 && Ut < 300 || Ut === 304, ga && (Ir = t0(ee, Ct, ga)), !ki && d.inArray("script", ee.dataTypes) > -1 && d.inArray("json", ee.dataTypes) < 0 && (ee.converters["text script"] = function() {
              }), Ir = n0(ee, Ir, Ct, ki), ki ? (ee.ifModified && (Nr = Ct.getResponseHeader("Last-Modified"), Nr && (d.lastModified[S] = Nr), Nr = Ct.getResponseHeader("etag"), Nr && (d.etag[S] = Nr)), Ut === 204 || ee.type === "HEAD" ? vi = "nocontent" : Ut === 304 ? vi = "notmodified" : (vi = Ir.state, _a = Ir.data, Bi = Ir.error, ki = !Bi)) : (Bi = vi, (Ut || !vi) && (vi = "error", Ut < 0 && (Ut = 0))), Ct.status = Ut, Ct.statusText = (an || vi) + "", ki ? Lt.resolveWith(xe, [
                _a,
                vi,
                Ct
              ]) : Lt.rejectWith(xe, [
                Ct,
                vi,
                Bi
              ]), Ct.statusCode(Pn), Pn = void 0, X && ut.trigger(ki ? "ajaxSuccess" : "ajaxError", [
                Ct,
                ee,
                ki ? _a : Bi
              ]), gt.fireWith(xe, [
                Ct,
                vi
              ]), X && (ut.trigger("ajaxComplete", [
                Ct,
                ee
              ]), --d.active || d.event.trigger("ajaxStop")));
            }
            return Ct;
          },
          getJSON: function(u, p, b) {
            return d.get(u, p, b, "json");
          },
          getScript: function(u, p) {
            return d.get(u, void 0, p, "script");
          }
        }), d.each([
          "get",
          "post"
        ], function(u, p) {
          d[p] = function(b, S, A, C) {
            return g(S) && (C = C || A, A = S, S = void 0), d.ajax(d.extend({
              url: b,
              type: p,
              dataType: C,
              data: S,
              success: A
            }, d.isPlainObject(b) && b));
          };
        }), d.ajaxPrefilter(function(u) {
          var p;
          for (p in u.headers) p.toLowerCase() === "content-type" && (u.contentType = u.headers[p] || "");
        }), d._evalUrl = function(u, p, b) {
          return d.ajax({
            url: u,
            type: "GET",
            dataType: "script",
            cache: true,
            async: false,
            global: false,
            converters: {
              "text script": function() {
              }
            },
            dataFilter: function(S) {
              d.globalEval(S, p, b);
            }
          });
        }, d.fn.extend({
          wrapAll: function(u) {
            var p;
            return this[0] && (g(u) && (u = u.call(this[0])), p = d(u, this[0].ownerDocument).eq(0).clone(true), this[0].parentNode && p.insertBefore(this[0]), p.map(function() {
              for (var b = this; b.firstElementChild; ) b = b.firstElementChild;
              return b;
            }).append(this)), this;
          },
          wrapInner: function(u) {
            return g(u) ? this.each(function(p) {
              d(this).wrapInner(u.call(this, p));
            }) : this.each(function() {
              var p = d(this), b = p.contents();
              b.length ? b.wrapAll(u) : p.append(u);
            });
          },
          wrap: function(u) {
            var p = g(u);
            return this.each(function(b) {
              d(this).wrapAll(p ? u.call(this, b) : u);
            });
          },
          unwrap: function(u) {
            return this.parent(u).not("body").each(function() {
              d(this).replaceWith(this.childNodes);
            }), this;
          }
        }), d.expr.pseudos.hidden = function(u) {
          return !d.expr.pseudos.visible(u);
        }, d.expr.pseudos.visible = function(u) {
          return !!(u.offsetWidth || u.offsetHeight || u.getClientRects().length);
        }, d.ajaxSettings.xhr = function() {
          try {
            return new e.XMLHttpRequest();
          } catch {
          }
        };
        var i0 = {
          0: 200,
          1223: 204
        }, ma = d.ajaxSettings.xhr();
        y.cors = !!ma && "withCredentials" in ma, y.ajax = ma = !!ma, d.ajaxTransport(function(u) {
          var p, b;
          if (y.cors || ma && !u.crossDomain) return {
            send: function(S, A) {
              var C, L = u.xhr();
              if (L.open(u.type, u.url, u.async, u.username, u.password), u.xhrFields) for (C in u.xhrFields) L[C] = u.xhrFields[C];
              u.mimeType && L.overrideMimeType && L.overrideMimeType(u.mimeType), !u.crossDomain && !S["X-Requested-With"] && (S["X-Requested-With"] = "XMLHttpRequest");
              for (C in S) L.setRequestHeader(C, S[C]);
              p = function(H) {
                return function() {
                  p && (p = b = L.onload = L.onerror = L.onabort = L.ontimeout = L.onreadystatechange = null, H === "abort" ? L.abort() : H === "error" ? typeof L.status != "number" ? A(0, "error") : A(L.status, L.statusText) : A(i0[L.status] || L.status, L.statusText, (L.responseType || "text") !== "text" || typeof L.responseText != "string" ? {
                    binary: L.response
                  } : {
                    text: L.responseText
                  }, L.getAllResponseHeaders()));
                };
              }, L.onload = p(), b = L.onerror = L.ontimeout = p("error"), L.onabort !== void 0 ? L.onabort = b : L.onreadystatechange = function() {
                L.readyState === 4 && e.setTimeout(function() {
                  p && b();
                });
              }, p = p("abort");
              try {
                L.send(u.hasContent && u.data || null);
              } catch (H) {
                if (p) throw H;
              }
            },
            abort: function() {
              p && p();
            }
          };
        }), d.ajaxPrefilter(function(u) {
          u.crossDomain && (u.contents.script = false);
        }), d.ajaxSetup({
          accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
          },
          contents: {
            script: /\b(?:java|ecma)script\b/
          },
          converters: {
            "text script": function(u) {
              return d.globalEval(u), u;
            }
          }
        }), d.ajaxPrefilter("script", function(u) {
          u.cache === void 0 && (u.cache = false), u.crossDomain && (u.type = "GET");
        }), d.ajaxTransport("script", function(u) {
          if (u.crossDomain || u.scriptAttrs) {
            var p, b;
            return {
              send: function(S, A) {
                p = d("<script>").attr(u.scriptAttrs || {}).prop({
                  charset: u.scriptCharset,
                  src: u.url
                }).on("load error", b = function(C) {
                  p.remove(), b = null, C && A(C.type === "error" ? 404 : 200, C.type);
                }), v.head.appendChild(p[0]);
              },
              abort: function() {
                b && b();
              }
            };
          }
        });
        var Sd = [], eu = /(=)\?(?=&|$)|\?\?/;
        d.ajaxSetup({
          jsonp: "callback",
          jsonpCallback: function() {
            var u = Sd.pop() || d.expando + "_" + pd.guid++;
            return this[u] = true, u;
          }
        }), d.ajaxPrefilter("json jsonp", function(u, p, b) {
          var S, A, C, L = u.jsonp !== false && (eu.test(u.url) ? "url" : typeof u.data == "string" && (u.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && eu.test(u.data) && "data");
          if (L || u.dataTypes[0] === "jsonp") return S = u.jsonpCallback = g(u.jsonpCallback) ? u.jsonpCallback() : u.jsonpCallback, L ? u[L] = u[L].replace(eu, "$1" + S) : u.jsonp !== false && (u.url += ($c.test(u.url) ? "&" : "?") + u.jsonp + "=" + S), u.converters["script json"] = function() {
            return C || d.error(S + " was not called"), C[0];
          }, u.dataTypes[0] = "json", A = e[S], e[S] = function() {
            C = arguments;
          }, b.always(function() {
            A === void 0 ? d(e).removeProp(S) : e[S] = A, u[S] && (u.jsonpCallback = p.jsonpCallback, Sd.push(S)), C && g(A) && A(C[0]), C = A = void 0;
          }), "script";
        }), y.createHTMLDocument = function() {
          var u = v.implementation.createHTMLDocument("").body;
          return u.innerHTML = "<form></form><form></form>", u.childNodes.length === 2;
        }(), d.parseHTML = function(u, p, b) {
          if (typeof u != "string") return [];
          typeof p == "boolean" && (b = p, p = false);
          var S, A, C;
          return p || (y.createHTMLDocument ? (p = v.implementation.createHTMLDocument(""), S = p.createElement("base"), S.href = v.location.href, p.head.appendChild(S)) : p = v), A = Je.exec(u), C = !b && [], A ? [
            p.createElement(A[1])
          ] : (A = Kn([
            u
          ], p, C), C && C.length && d(C).remove(), d.merge([], A.childNodes));
        }, d.fn.load = function(u, p, b) {
          var S, A, C, L = this, H = u.indexOf(" ");
          return H > -1 && (S = as(u.slice(H)), u = u.slice(0, H)), g(p) ? (b = p, p = void 0) : p && typeof p == "object" && (A = "POST"), L.length > 0 && d.ajax({
            url: u,
            type: A || "GET",
            dataType: "html",
            data: p
          }).done(function(z) {
            C = arguments, L.html(S ? d("<div>").append(d.parseHTML(z)).find(S) : z);
          }).always(b && function(z, X) {
            L.each(function() {
              b.apply(this, C || [
                z.responseText,
                X,
                z
              ]);
            });
          }), this;
        }, d.expr.pseudos.animated = function(u) {
          return d.grep(d.timers, function(p) {
            return u === p.elem;
          }).length;
        }, d.offset = {
          setOffset: function(u, p, b) {
            var S, A, C, L, H, z, X, oe = d.css(u, "position"), pe = d(u), ee = {};
            oe === "static" && (u.style.position = "relative"), H = pe.offset(), C = d.css(u, "top"), z = d.css(u, "left"), X = (oe === "absolute" || oe === "fixed") && (C + z).indexOf("auto") > -1, X ? (S = pe.position(), L = S.top, A = S.left) : (L = parseFloat(C) || 0, A = parseFloat(z) || 0), g(p) && (p = p.call(u, b, d.extend({}, H))), p.top != null && (ee.top = p.top - H.top + L), p.left != null && (ee.left = p.left - H.left + A), "using" in p ? p.using.call(u, ee) : pe.css(ee);
          }
        }, d.fn.extend({
          offset: function(u) {
            if (arguments.length) return u === void 0 ? this : this.each(function(A) {
              d.offset.setOffset(this, u, A);
            });
            var p, b, S = this[0];
            if (S) return S.getClientRects().length ? (p = S.getBoundingClientRect(), b = S.ownerDocument.defaultView, {
              top: p.top + b.pageYOffset,
              left: p.left + b.pageXOffset
            }) : {
              top: 0,
              left: 0
            };
          },
          position: function() {
            if (this[0]) {
              var u, p, b, S = this[0], A = {
                top: 0,
                left: 0
              };
              if (d.css(S, "position") === "fixed") p = S.getBoundingClientRect();
              else {
                for (p = this.offset(), b = S.ownerDocument, u = S.offsetParent || b.documentElement; u && (u === b.body || u === b.documentElement) && d.css(u, "position") === "static"; ) u = u.parentNode;
                u && u !== S && u.nodeType === 1 && (A = d(u).offset(), A.top += d.css(u, "borderTopWidth", true), A.left += d.css(u, "borderLeftWidth", true));
              }
              return {
                top: p.top - A.top - d.css(S, "marginTop", true),
                left: p.left - A.left - d.css(S, "marginLeft", true)
              };
            }
          },
          offsetParent: function() {
            return this.map(function() {
              for (var u = this.offsetParent; u && d.css(u, "position") === "static"; ) u = u.offsetParent;
              return u || nt;
            });
          }
        }), d.each({
          scrollLeft: "pageXOffset",
          scrollTop: "pageYOffset"
        }, function(u, p) {
          var b = p === "pageYOffset";
          d.fn[u] = function(S) {
            return Ee(this, function(A, C, L) {
              var H;
              if (x(A) ? H = A : A.nodeType === 9 && (H = A.defaultView), L === void 0) return H ? H[p] : A[C];
              H ? H.scrollTo(b ? H.pageXOffset : L, b ? L : H.pageYOffset) : A[C] = L;
            }, u, S, arguments.length);
          };
        }), d.each([
          "top",
          "left"
        ], function(u, p) {
          d.cssHooks[p] = re(y.pixelPosition, function(b, S) {
            if (S) return S = ne(b, p), ha.test(S) ? d(b).position()[p] + "px" : S;
          });
        }), d.each({
          Height: "height",
          Width: "width"
        }, function(u, p) {
          d.each({
            padding: "inner" + u,
            content: p,
            "": "outer" + u
          }, function(b, S) {
            d.fn[S] = function(A, C) {
              var L = arguments.length && (b || typeof A != "boolean"), H = b || (A === true || C === true ? "margin" : "border");
              return Ee(this, function(z, X, oe) {
                var pe;
                return x(z) ? S.indexOf("outer") === 0 ? z["inner" + u] : z.document.documentElement["client" + u] : z.nodeType === 9 ? (pe = z.documentElement, Math.max(z.body["scroll" + u], pe["scroll" + u], z.body["offset" + u], pe["offset" + u], pe["client" + u])) : oe === void 0 ? d.css(z, X, H) : d.style(z, X, oe, H);
              }, p, L ? A : void 0, L);
            };
          });
        }), d.each([
          "ajaxStart",
          "ajaxStop",
          "ajaxComplete",
          "ajaxError",
          "ajaxSuccess",
          "ajaxSend"
        ], function(u, p) {
          d.fn[p] = function(b) {
            return this.on(p, b);
          };
        }), d.fn.extend({
          bind: function(u, p, b) {
            return this.on(u, null, p, b);
          },
          unbind: function(u, p) {
            return this.off(u, null, p);
          },
          delegate: function(u, p, b, S) {
            return this.on(p, u, b, S);
          },
          undelegate: function(u, p, b) {
            return arguments.length === 1 ? this.off(u, "**") : this.off(p, u || "**", b);
          },
          hover: function(u, p) {
            return this.on("mouseenter", u).on("mouseleave", p || u);
          }
        }), d.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(u, p) {
          d.fn[p] = function(b, S) {
            return arguments.length > 0 ? this.on(p, null, b, S) : this.trigger(p);
          };
        });
        var r0 = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
        d.proxy = function(u, p) {
          var b, S, A;
          if (typeof p == "string" && (b = u[p], p = u, u = b), !!g(u)) return S = r.call(arguments, 2), A = function() {
            return u.apply(p || this, S.concat(r.call(arguments)));
          }, A.guid = u.guid = u.guid || d.guid++, A;
        }, d.holdReady = function(u) {
          u ? d.readyWait++ : d.ready(true);
        }, d.isArray = Array.isArray, d.parseJSON = JSON.parse, d.nodeName = w, d.isFunction = g, d.isWindow = x, d.camelCase = I, d.type = M, d.now = Date.now, d.isNumeric = function(u) {
          var p = d.type(u);
          return (p === "number" || p === "string") && !isNaN(u - parseFloat(u));
        }, d.trim = function(u) {
          return u == null ? "" : (u + "").replace(r0, "$1");
        };
        var s0 = e.jQuery, o0 = e.$;
        return d.noConflict = function(u) {
          return e.$ === d && (e.$ = o0), u && e.jQuery === d && (e.jQuery = s0), d;
        }, typeof t > "u" && (e.jQuery = e.$ = d), d;
      });
    }(yc)), yc.exports;
  }
  Q1();
  function eA() {
    document.getElementById("loading-screen");
    const s = document.getElementById("progress-bar"), e = [
      {
        name: "REFERENCES",
        position: {
          x: -150,
          y: -150,
          z: 13
        }
      },
      {
        name: "WELCOME",
        position: {
          x: 0,
          y: 0,
          z: 13
        }
      },
      {
        name: "16 PSYCHE",
        position: {
          x: 20,
          y: 30,
          z: 10
        }
      },
      {
        name: "PSYCHE Jr",
        position: {
          x: -150,
          y: 150,
          z: 13
        }
      },
      {
        name: "COSMIC COMPARISON",
        position: {
          x: 0,
          y: 300,
          z: 13
        }
      },
      {
        name: "MISSION",
        position: {
          x: 150,
          y: 150,
          z: 13
        }
      },
      {
        name: "GAMES",
        position: {
          x: 300,
          y: 0,
          z: 13
        },
        subsections: [
          {
            name: "Temperature Control",
            position: {
              x: 300,
              y: 0,
              z: 13
            }
          },
          {
            name: "Balance Game",
            position: {
              x: 300,
              y: 0,
              z: 13
            }
          },
          {
            name: "Escape Velocity",
            position: {
              x: 300,
              y: 0,
              z: 13
            }
          },
          {
            name: "SpacePic",
            position: {
              x: 300,
              y: 0,
              z: 13
            }
          }
        ]
      },
      {
        name: "SURFACE OF PSYCHE",
        position: {
          x: 150,
          y: -150,
          z: 13
        }
      },
      {
        name: "LOCATION OF PYSCHE",
        position: {
          x: 0,
          y: -300,
          z: 13
        }
      }
    ];
    M1(e);
    const t = new Yv(), n = new Xn(75, window.innerWidth / window.innerHeight, 0.1, 5e3);
    n.position.set(0, 0, 13);
    const i = new ZT({
      antialias: true
    });
    i.setSize(window.innerWidth, window.innerHeight), i.setPixelRatio(window.devicePixelRatio), document.getElementById("canvas-container").appendChild(i.domElement);
    const r = new gg(16777215, 0.5);
    t.add(r);
    const o = new mg(8019774, 10);
    o.position.set(-15, 5, 5), t.add(o), v1(n, e, i);
    const a = navigator.hardwareConcurrency < 4 || window.devicePixelRatio < 1.5, l = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent), c = a ? 0.5 : 1, h = a ? 1 : 2, f = document.getElementById("debug-panel");
    function m() {
      const E = gl();
      f.innerHTML = `
      <strong>DEBUG PANEL:</strong><br>
      <strong>Current Section:</strong>
      ${E}<br>
      <strong>Camera Position:</strong><br>
      X: ${n.position.x.toFixed(2)}<br>
      Y: ${n.position.y.toFixed(2)}<br>
      Z: ${n.position.z.toFixed(2)}<br>
      Is Mobile: ${l}<br>
      Concurrency: ${navigator.hardwareConcurrency}<br>
      PixelRatio: ${window.devicePixelRatio}
    `;
    }
    function _() {
      requestAnimationFrame(_), m(), y ? y.render() : i.render(t, n), D1(n, t), U1(n, t), Y1(), K1();
    }
    Qw(n, t, i);
    const y = u1(t, i, n, h), g = [
      T1(t, n, e),
      w1(t, n, e),
      A1(t, n, e, i),
      P1(t, n, e, i),
      N1(t, n, e, i),
      k1(t, n, e, i),
      z1(t, n, e, i),
      G1(t, n, e),
      q1(t, n, e, i),
      $1(t)
    ];
    let x = 0;
    const v = g.length;
    g.forEach((E) => {
      E.then(() => {
        x++;
        const T = x / v * 100;
        s.style.width = `${T}%`, x === v && (console.log("All sections loaded."), c1(t, {
          density: c
        }), e1(n, i), S1(), _(), tA(), document.getElementById("cn-icon-wrapper").style.display = "flex");
      }).catch((T) => {
        console.error("Error loading a section:", T);
      });
    });
  }
  function tA() {
    const s = document.getElementById("loading-screen");
    s.style.transition = "opacity 0.5s ease", s.style.opacity = "0", setTimeout(() => s.remove(), 500);
  }
  window.addEventListener("resize", () => {
    camera && renderer ? R_(camera, renderer) : console.warn("Resize event fired, but camera or renderer is not defined.");
  });
  eA();
})();
export {
  __tla,
  un as g,
  ml as m
};
